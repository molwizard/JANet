# ### REQUIRES Jmol 14.4.3_2016.02.28 or later ###
############################
### Global Jmol settings ###
############################
load menu "jsnet3d/menu-janet.txt";
set autobond off;
set bondmode or;
set antialiasdisplay on;
set perspectiveDepth off;
color hover black;
background hover translucent 2 [255,255,125];
background black;
bind "MIDDLE-drag" "_translate";
#bind "SHIFT-LEFT-drag" "_translate";
set fontScaling on;
set appendNew on
set selectAllModels off;
#set windowCentered off;
set language en;
set languageTranslation off;

subsetFileNumber = 0;
subsetKeys       = [full: 1, default: 1];

fullLabels           = false;
lastAtomIndexHovered = -1;
lastHoverUnfinished  = false;
hoverTimeoutId       = "";
hoverMode            = "enhance";   # possible modes: enhance -> activate halos (of neighbours) and make bonds opaque, only -> hide non-neighbours
hoverRange           = "neighbours";
hoverRangeNeighbourDistance = 1;
hoverRangeNeighbourMode     = "add";
displayedBeforeHover = {displayed};
hoverEdgeTranslucency = 4;
hoverEdgeEnhanceTranslucency = 2;

pickRange                  = "node";
pickRangeNeighbourDistance = 1;
pickRangeNeighbourMode     = "replace";
debugLevel                 = 0;

######################
### Layout options ###
######################
layoutOptions = {};

layoutOptions.fr = {};
layoutOptions.fr.fullFrameSizeX           = 50;
layoutOptions.fr.fullFrameSizeY           = 50;
layoutOptions.fr.fullFrameSizeZ           = 50;
layoutOptions.fr.frameSizeX               = layoutOptions.fr.fullFrameSizeX;
layoutOptions.fr.frameSizeY               = layoutOptions.fr.fullFrameSizeY;
layoutOptions.fr.frameSizeZ               = layoutOptions.fr.fullFrameSizeZ;
layoutOptions.fr.iterationCount           = 100;
#layoutOptions.fr.burstIterationCount     = 20;
layoutOptions.fr.startTemperature         = 4;
layoutOptions.fr.minimumTemperature       = 0.1;
layoutOptions.fr.temperatureScalingFactor = 0.95;
layoutOptions.fr.kValueModifier           = 0.6;
layoutOptions.fr.startCoordinateMode      = "random";
layoutOptions.fr.randomCoordinateSeed     = "1234567890";
layoutOptions.fr.randomCoordinateFactor   = 0.8;
layoutOptions.fr.displayIntermediates     = true;
layoutOptions.fr.nodeScalingFactor        = 0.3;
layoutOptions.fr.edgeScalingFactor        = 0.05;

layoutOptions["updateDisplay"]            = {};    # dot notation not tolerated here somehow (case change)
layoutOptions["updateDisplay"]["center"]  = true;  # dot notation not tolerated here somehow (case change)
layoutOptions["updateDisplay"]["zoom"]    = true;  # dot notation not tolerated here somehow (case change)
layoutOptions.tiled                       = false;
layoutOptions.tileFactor                  = 8.0;
layoutOptions.labelSubnetworks            = false;

logData                                   = [];
iterationNumber = 0;
edgevisibilitySelectionModeOr = true;

###################################################################
### Network definitions (column names, column assignment, etc.) ###
###################################################################
networkDefinitions = {};

# ### Generic networks (single node type, each column is a node column, no annotation columns ###
networkDefinitions["generic"] = {};
#   column definitions
networkDefinitions["generic"]["columnDefinitions"] = [node: {}, annotation: {}];
#     node column definitions
var cDefs = networkDefinitions["generic"]..columnDefinitions..node;   # shortcut for simpler access (by pointer)
cDefs..generic       = {"columnType": "node", "infoKey": "genericId", "nodeType": "generic"};
cDefs..id_1       = {"columnType": "node", "infoKey": "genericId", "nodeType": "generic"};
cDefs..id_2 = cDefs..id_1;
#     rendering definitions
networkDefinitions["generic"]..renderingDefinitions = {};
rDefs = networkDefinitions["generic"]..renderingDefinitions;   # shortcut for simpler access (by pointer)
#       default
rDefs..default = [default: [size: 15], color: "deepskyblue", labelBackground: "[250, 250, 250]", labelSize: 12, labelOffsetX: 3, labelOffsetY: 3];
#     label definitions
networkDefinitions["generic"]..labelDefinitions = {};
lDefs = networkDefinitions["generic"]..labelDefinitions;   # shortcut for simpler access (by pointer)
lDefs..default = [generic: [short: [[infoKey: "genericId"]],
                             long: [[value: "ID: "], [infoKey: "genericId"], [value: "|(#"], [infoKey: "nodeNumber"], [value: ")"]]
                              ]
                    ];
#   translations
networkDefinitions["generic"]["translations"] = {};
var translations = networkDefinitions["generic"]["translations"];   # shortcut for simpler access (by pointer)
#      typeToTypeId
translations["typeToTypeId"] = {"generic": "UNK"};
#      typeToSingleLetter
translations..typeToSingleLetter = {"generic": "U"};

# ### Boolean networks (PRELIMINARY: single node type, no annotation columns ###
networkDefinitions["boolean"] = {};
networkDefinitions["boolean"]..edgeType = "directed";
#   column definitions
networkDefinitions["boolean"]["columnDefinitions"] = [node: {}, annotation: {}];
#     node column definitions
var cDefs = networkDefinitions["boolean"]..columnDefinitions..node;   # shortcut for simpler access (by pointer)
cDefs..from       = {"columnType": "node", "infoKey": "nodeId", "nodeType": "boolean"};
cDefs..to         = {"columnType": "node", "infoKey": "nodeId", "nodeType": "boolean"};
#   translations
networkDefinitions["boolean"]["translations"] = {};
var translations = networkDefinitions["boolean"]["translations"];   # shortcut for simpler access (by pointer)
#      typeToTypeId
translations["typeToTypeId"] = {"boolean": "UNK"};
#      typeToSingleLetter
translations..typeToSingleLetter = {"boolean": "U"};

  ##########################
  ### AgeFactDB networks ###
  ##########################
networkDefinitions["agefactdb"] = {};
#   column definitions
networkDefinitions["agefactdb"]..columnDefinitions = [node: {}, annotation: {}];
#     node column definitions
cDefs = networkDefinitions["agefactdb"]..columnDefinitions..node;   # shortcut for simpler access (by pointer)
cDefs..entry_stable_id        = [columnType: "node", infoKey: "ageingFactorId", nodeType: "ageingFactor", subTypeInfoKeys: ["ageingFactorType"]];
cDefs..observation_stable_id  = [columnType: "node", infoKey: "observationId",  nodeType: "observation",  subTypeInfoKeys: ["lifespanEffectSignificant", "observationType"], temperatureInfoKey: "lifespanChange"];
cDefs..go_id                  = [columnType: "node", infoKey: "goId",           nodeType: "goTerm",       subTypeInfoKeys: ["goCategory"]];
cDefs..species                = [columnType: "node", infoKey: "species",        nodeType: "species",      subTypeInfoKeys: ["nodeType"]];    # no real subtype available
cDefs..allele_types           = [columnType: "node", infoKey: "alleleType",     nodeType: "alleleType",   subTypeInfoKeys: ["nodeType"]];    # no real subtype available
cDefs..pubmed_id              = [columnType: "node", infoKey: "citationId",     nodeType: "citation",     subTypeInfoKeys: ["nodeType"]];    # no real subtype available
cdefs..bsid                   = [columnType: "node", infoKey: "bioSystemId",    nodeType: "bioSystem",    subTypeInfoKeys: ["bioSystemType"]];
cdefs..biosystem_ncbi_gene_id = [columnType: "node", infoKey: "geneId",         nodeType: "gene",         subTypeInfoKeys: ["nodeType"]];
cdefs..ncbi_gene_id_1         = [columnType: "node", infoKey: "geneId",         nodeType: "gene",         subTypeInfoKeys: ["nodeType"]];
#cdefs..ncbi_gene_id_1 = cdefs..ncbi_gene_id;
cdefs..ncbi_gene_id_2 = cdefs..ncbi_gene_id_1;
cdefs..entry_stable_id_1 = cDefs..entry_stable_id;
cdefs..entry_stable_id_2 = cDefs..entry_stable_id;
cDefs..observation_stable_id_1  = cDefs..observation_stable_id;
cDefs..observation_stable_id_2  = cDefs..observation_stable_id;

#     annotation column definitions
cDefs = networkDefinitions["agefactdb"]..columnDefinitions..annotation;   # shortcut for simpler access (by pointer)
cDefs..entry_type                        = [columnType: "annotation", infoKey: "ageingFactorType",          targetTypes: ["node"], targetNodeTypes: ["ageingFactor"]];
cDefs..entry_name                        = [columnType: "annotation", infoKey: "ageingFactorName",          targetTypes: ["node"], targetNodeTypes: ["ageingFactor"]];
cDefs..species                           = [columnType: "annotation", infoKey: "species",                   targetTypes: ["node"], targetNodeTypes: ["ageingFactor", "observation", "gene"], assignMode: "all", targetStorageTypes: [observation: "hash", ageingFactor: "hash"]];
cDefs..ncbi_gene_id                      = [columnType: "annotation", infoKey: "ncbiGeneId",                targetTypes: ["node"], targetNodeTypes: ["ageingFactor"]];
cDefs..lifespan_data_available           = [columnType: "annotation", infoKey: "lifespanDataAvailable",     targetTypes: ["node"], targetNodeTypes: ["ageingFactor"]];
cDefs..allele_types                      = [columnType: "annotation", infoKey: "alleleTypes",               targetTypes: ["node"], targetNodeTypes: ["observation"], sourceNodeType: "ageingFactor", storageSourceInfoKeys: ["ageingFactorId", "ageingFactorType", "ageingFactorName", "species"]];
cDefs..allele_types_base                 = [columnType: "annotation", infoKey: "alleleTypesBase",           targetTypes: ["node"], targetNodeTypes: ["observation"], sourceNodeType: "ageingFactor", storageSourceInfoKeys: ["ageingFactorId", "ageingFactorType", "ageingFactorName", "species"]];
cDefs..lifespan_change                   = [columnType: "annotation", infoKey: "lifespanChange",            targetTypes: ["node"], targetNodeTypes: ["observation"]];
cDefs..lifespan_effect_significant       = [columnType: "annotation", infoKey: "lifespanEffectSignificant", targetTypes: ["node"], targetNodeTypes: ["observation"]];
cDefs..lifespan_measure                  = [columnType: "annotation", infoKey: "lifespanMeasure",           targetTypes: ["node"], targetNodeTypes: ["observation"]];
cDefs..go_term                           = [columnType: "annotation", infoKey: "goTerm",                    targetTypes: ["node"], targetNodeTypes: ["goTerm"]];
cDefs..go_category                       = [columnType: "annotation", infoKey: "goCategory",                targetTypes: ["node"], targetNodeTypes: ["goTerm"]];
cDefs..homologene_id                     = [columnType: "annotation", infoKey: "homologeneId",              targetTypes: ["node"], targetNodeTypes: ["observation"]];
cDefs..homology_analysis_status          = [columnType: "annotation", infoKey: "homologyAnalysisStatus",    targetTypes: ["node"], targetNodeTypes: ["ageingFactor"]];
cDefs..experimental_evidence_gene_count  = [columnType: "annotation", infoKey: "homologyAnalysisGeneCount", targetTypes: ["node"], targetNodeTypes: ["observation"]];
cDefs..observation_type                  = [columnType: "annotation", infoKey: "observationType",           targetTypes: ["node"], targetNodeTypes: ["observation"]];
cDefs..biosystem_name                    = [columnType: "annotation", infoKey: "bioSystemName",             targetTypes: ["node"], targetNodeTypes: ["bioSystem"]];
cDefs..biosystem_type                    = [columnType: "annotation", infoKey: "bioSystemType",             targetTypes: ["node"], targetNodeTypes: ["bioSystem"]];
cDefs..biosystem_source_db               = [columnType: "annotation", infoKey: "bioSystemSourceDb",         targetTypes: ["node"], targetNodeTypes: ["bioSystem"]];
cDefs..biosystem_source_db_accession     = [columnType: "annotation", infoKey: "bioSystemSourceDbId",       targetTypes: ["node"], targetNodeTypes: ["bioSystem"]];
cDefs..biosystem_description             = [columnType: "annotation", infoKey: "bioSystemDescription",      targetTypes: ["node"], targetNodeTypes: ["bioSystem"]];
cDefs..gene_symbol                       = [columnType: "annotation", infoKey: "geneSymbol",                targetTypes: ["node"], targetNodeTypes: ["gene"]];
cDefs..gene_description                  = [columnType: "annotation", infoKey: "geneDescription",           targetTypes: ["node"], targetNodeTypes: ["gene"]];
cDefs..type_of_gene                      = [columnType: "annotation", infoKey: "geneType",                  targetTypes: ["node"], targetNodeTypes: ["gene"]];
cDefs..base_entry_stable_ids             = [columnType: "annotation", infoKey: "baseEntryStableIds",        targetTypes: ["node"], targetNodeTypes: ["ageingFactor"]];
cDefs..gene_symbol_1 = cDefs..gene_symbol;
cDefs..gene_symbol_2 = cDefs..gene_symbol;

#     rendering definitions
networkDefinitions["agefactdb"]..renderingDefinitions = {};
rDefs = networkDefinitions["agefactdb"]..renderingDefinitions;   # shortcut for simpler access (by pointer)
#       default
rDefs..default = [default: [size: 15], labelBackground: "[250, 250, 250]", labelSize: 12, labelOffsetX: 3, labelOffsetY: 3];
#       ageingFactor
rDefs..ageingFactor = [default: [size: 25, color: "magenta", labelSize: 14],
                       subTypeSpecific: [gene:         [color: "[255,0,255]"],
                                         compound:     [color: "[200,155,200]"],
                                         other_factor: [color: "[176,93,229]"]
                                        ]
                      ];
#       observation
rDefs..observation = [default: [size: 15, color: "royalblue"],
                      subTypeSpecific: [increased:   [color: "yellowgreen", labelBackground: "none"],
                                        decreased:   [color: "red",         labelBackground: "none"],
                                        none:        [color: "grey",        labelBackground: "none"],
                                        homology:    [color: "blue"],
                                        phenotype_1: [color: "lime"]
                                       ]
                     ];
#       goTerm (hash keys "Function" and "Process" must be in quotes due to bug in Jmol 14.4.1 and 14.4.3)
rDefs..goTerm = [default: [size: 10, color: "navy"],
                 subTypeSpecific: ["Component": [color: "mediumturquoise"],
                                   "Function":  [color: "lightskyblue"],
                                   "Process":   [color: "deepskyblue"]
                                  ]
                ];
#       species
rDefs..species = [default: [size: 35, color: "[240,240,65]", labelBackground: "[120,120,120]"]];
#       alleleType
rDefs..alleleType = [default: [size: 18, color: "sandybrown"]];
#       citation
rDefs..citation = [default: [size: 17, color: "tan"]];
#       bioSystem
rDefs..bioSystem = [default: [size: 30, color: "[171,92,0]"]];
#       gene
rDefs..gene = [default: [size: 14, color: "[194,143,143]"]];

#     label definitions
networkDefinitions["agefactdb"]..labelDefinitions = {};
lDefs = networkDefinitions["agefactdb"]..labelDefinitions;   # shortcut for simpler access (by pointer)
lDefs..ageingFactor = [default: [short:   [[infoKey: "ageingFactorName"]],
                                  long:   [[infoKey: "ageingFactorType", setCase: "capitalize"], [value: ": "], [infoKey: "ageingFactorName"], [value: "|("], [infoKey: "nodeId"], [value: ", #"], [infoKey: "nodeNumber"], [value: ")"]],
                                  custom: [[infoKey: "ageingFactorType", setCase: "capitalize"], [value: ": "], [infoKey: "ageingFactorName"], [value: ", "], [infoKey: "species"], [value: "|("], [infoKey: "nodeId"], [value: ")"]]
                                ],
                       infoKeySpecific: [infoKey: "nodeSubType",
                                         infoKeyValues: [gene: [short:  [[infoKey: "ageingFactorName"]],
                                                                long:   [[infoKey: "ageingFactorType", setCase: "capitalize"], [value: ": "], [infoKey: "ageingFactorName"], [value: ", "], [infoKey: "speciesShortcut"], [value: "|("], [infoKey: "nodeId"], [value: ", #"], [infoKey: "nodeNumber"], [value: ")"]],
                                                                custom: [[infoKey: "ageingFactorType", setCase: "capitalize"], [value: ": "], [infoKey: "ageingFactorName"], [value: ", "], [infoKey: "species"], [value: "|("], [infoKey: "nodeId"], [value: ")"]]
                                                               ]
                                                        ]
                                        ]
                      ];

lDefs..species = [default: [short: [{"infoKey": "speciesShortcut"}],
                            long:  [{"value": "Species: "}, {"infoKey": "species"}, {"value": " ("},  {"value": "#"}, {"infoKey": "nodeNumber"}, {"value": ")"}]
                           ]
                 ];

lDefs..observation = [infoKeySpecific: [infoKey: "observationType",
                                        infoKeyValues: [phenotype_1: [short: [[infoKey: "nodeId"], [value: " (#"], [infoKey: "nodeNumber"], [value: ")"]],
                                                                      long:  [[value: "Phenotype: "], [infoKey: "nodeId"], [value: "|"], [infoKey: "species"], [value: " (#"], [infoKey: "nodeNumber"], [value: ")"]]
                                                                     ],
                                                        phenotype_2: [short: [[infoKey: "lifespanChange", format: "+%.1f%"]],
                                                                      long:  [[value: "Lifespan change: "], [infoKey: "lifespanChange", format: "+%.1f%"], [value: "|Lifespan measure: "], [infoKey: "lifespanMeasure"], [value:"|"], [infoKey: "species"], [value: "|("], [infoKey: "nodeId"], [value: ", #"], [infoKey: "nodeNumber"], [value: ")|"], [infoKey: "alleleTypes", separator: "|", subDefinition: [[infoKey: "ageingFactorType", setCase: "capitalize"], [value: ": "], [infoKey: "ageingFactorName"], [value: " ("], [infoKey: "ageingFactorId"], [value: "), Allele type: "], [infoKey: "alleleTypes"], [value: ";"]]]]
                                                                     ],
                                                        homology_analysis: [short: [[infoKey: "nodeId"], [value: " (#"], [infoKey: "nodeNumber"], [value: ")"]],
                                                                            long:  [[value: "Homology: "], [infoKey: "homologeneId"], [value: "|("], [infoKey: "nodeId"], [value: ", #"], [infoKey: "nodeNumber"], [value: ")"]]
                                                                           ]
                                                       ]
                                       ]
                     ];

lDefs..alleleType = [default: [short: [[infoKey: "alleleType"]],
                                long: [[value: "Allele type:|"], [infoKey: "alleleType"], [value: "|(#"], [infoKey: "nodeNumber"], [value: ")"]]
                              ]
                    ];

lDefs..citation = [default: [short: [[value: "PMID "], [infoKey: "citationId"]],
                                long: [[value: "Citation: PubMed ID "], [infoKey: "citationId"], [value: "|(#"], [infoKey: "nodeNumber"], [value: ")"]]
                              ]
                    ];

lDefs..goTerm = [default: [short: [[infoKey: "goTerm"]],
                                  long: [[value: "GO "], [infoKey: "goCategory", setCase: "capitalize"], [value: ":|"], [infoKey: "goTerm"], [value: "|("], [infoKey: "nodeId"], [value: ", #"], [infoKey: "nodeNumber"], [value: ")"]]
                                ]
                      ];

lDefs..gene = [default: [short: [[infoKey: "geneSymbol"]],
                                  long: [[value: "Gene: "], [infoKey: "geneSymbol"], [value: ", "], [infoKey: "speciesShortcut"], [value: "|(NCBI gene ID "], [infoKey: "nodeId"], [value: ", #"], [infoKey: "nodeNumber"], [value: ")"]],
                                  custom: [[value: "Gene: "], [infoKey: "geneSymbol"], [value: ", "], [infoKey: "species"], [value: "|(NCBI gene ID "], [infoKey: "nodeId"], [value: ")"]]
                                ]
                      ];

lDefs..bioSystem = [default: [short: [[infoKey: "bioSystemName"]],
                                  long: [[value: "BioSystem: "], [infoKey: "bioSystemName"], [value: "|(bsid "], [infoKey: "nodeId"], [value: ", #"], [infoKey: "nodeNumber"], [value: ")|Source DB: "], [infoKey: "bioSystemSourceDb"], [value: " - "], [infoKey: "bioSystemSourceDbId"]],
                                  custom: [[value: "BioSystem: "], [infoKey: "bioSystemName"], [value: ", "], [infoKey: "bioSystemType"], [value: "|(bsid "], [infoKey: "nodeId"], [value: ")"]]
                                ]
                      ];

#   translations
networkDefinitions["agefactdb"]..translations = {};
translations = networkDefinitions["agefactdb"]..translations;   # shortcut for simpler access (by pointer)
#      typeToTypeId
translations..typeToTypeId = {}
translations..typeToTypeId..default           = "UNK";
translations..typeToTypeId..ageingFactor      = "AF";
translations..typeToTypeId..observation       = "OB";
translations..typeToTypeId..goTerm            = "GO";
translations..typeToTypeId..species           = "SP";
translations..typeToTypeId..gene              = "GEN";
translations..typeToTypeId..compound          = "COM";
translations..typeToTypeId..other_factor      = "OTF";
translations..typeToTypeId..alleleType        = "ALT";
translations..typeToTypeId..citation          = "CIT";
translations..typeToTypeId..increased         = "INC";
translations..typeToTypeId..decreased         = "DEC";
translations..typeToTypeId..none              = "NON";
translations..typeToTypeId..phenotype_1       = "PHE";
translations..typeToTypeId..phenotype_2       = "LIF";    # just as fallback, usually splitted into increased/decreased/none
translations..typeToTypeId..homology_analysis = "HOM";
translations..typeToTypeId..Component         = "CMP";
translations..typeToTypeId..Function          = "FUN";
translations..typeToTypeId..Process           = "PRO";
translations..typeToTypeId..pathway           = "PW";
translations..typeToTypeId..bioSystem         = "BS";
#      typeToSingleLetter
translations..typeToSingleLetter = {};
translations..typeToSingleLetter..default      = "U";
translations..typeToSingleLetter..ageingFactor = "F";
translations..typeToSingleLetter..observation  = "O";
translations..typeToSingleLetter..goTerm       = "Gd";
translations..typeToSingleLetter..species      = "S";
translations..typeToSingleLetter..alleleType   = "Al";
translations..typeToSingleLetter..citation     = "C";
translations..typeToSingleLetter..gene         = "Ge";
translations..typeToSingleLetter..bioSystem    = "Bi";
#      propertyValueToNumber  (needed for setting custom atom properties which can only have numeric values, e.g.: mark genes of interest by 'property_gof', 1=unknown 2=experimental 3=homology 0=no gene of interest)
translatons..propertyValueToNumber..gof = {};
translatons..propertyValueToNumber..gof..unknown      = 1;
translatons..propertyValueToNumber..gof..experimental = 2;
translatons..propertyValueToNumber..gof..homology     = 3;
#   normalizations
networkDefinitions["agefactdb"]..normalizations = {};
normalizations = networkDefinitions["agefactdb"]..normalizations;   # shortcut for simpler access (by pointer)
#     alleleType  ('true' as value indicates a forbidden nodeId, resulting in skipping the node)
normalizations..alleleType = {"Conditional knockout": "loss of function",
                              "Conditional restoration of Fgf23 activity in Fgf23 knockout mice": "gain of function",
                              "Deletion": "loss of function",
                              "Deletion ": "loss of function",
                              "Deletion in connective tissue": "loss of function",
                              "Deletion of a region": "loss of function",
                              "Gene disruption": "loss of function",
                              "Increased dosage": "overexpression",
                              "Knock-down": "loss of function",
                              "Knockdown": "loss of function",
                              "Knockin": "gain of function",
                              "Knockout": "loss of function",
                              "Mutation": "mutation",
                              "Mutation ": "mutation",
                              "Mutation in adults": "mutation",
                              "Mutations": "mutation",
                              "overexpression": "overexpression",
                              "Overexpression": "overexpression",
                              "Overexpression ": "overexpression",
                              "Overexpression in cardiac and skeletal muscles": "overexpression",
                              "Overexpression in skin": "overexpression",
                              "Overexpression in stem and progenitor cells": "overexpression",
                              "Overexpression of the short isoform of p53 (p44)": "overexpression",
                              "Pharmacological overexpression (Superoxide dismutase/catalase mimetics)": "overexpression",
                              "RNA interference": "RNA interference",
                              "RNA interference ": "RNA interference",
                              "RNA interference and deletion": "RNA interference",
                              "RNA interference in adults": "RNA interference",
                              "RNA interference post development": "RNA interference",
                              "RNA interference post development ": "RNA interference",
                              "RNA interference, Knockdown": "RNA interference",
                              "RNAi knockdown": "RNA interference",
                              "deletion / null": "loss of function",
                              "deletion / null||RNAi knockdown": "RNA interference",
                              "deletion / null||dominant negative": "loss of function",
                              "deletion / null||over-expression": "overexpression",
                              "dominant negative": "loss of function",
                              "gain of function": "gain of function",
                              "loss of function": "loss of function",
                              "loss of function||RNAi knockdown": "RNA interference",
                              "non-null dominant": "mutation",
                              "non-null recessive": "mutation",
                              "non-null semi-dominant": "mutation",
                              "null mutant": "loss of function",
                              "over-expression": "overexpression",
                              "over-expression||over-expression": "overexpression",
                              "over-expression||unknown": "overexpression",
                              "Dominant negative mutation": "mutation",
                              "NULL": true
                              };

  #############################
  ### KEGG pathway networks ###
  #############################
networkDefinitions["pathway"] = {"edgeType": "undirected"};
#   column definitions
networkDefinitions["pathway"]..columnDefinitions = [node: {}, annotation: {}];
#     node column definitions
cDefs = networkDefinitions["pathway"]..columnDefinitions..node;   # shortcut for simpler access (by pointer)
cDefs..KEGG_ENTRY_ID        = [columnType: "node", infoKey: "pathwayNodeId", nodeType: "pathwayNode", subTypeInfoKeys: ["pathwayNodeType"]];
cDefs..KEGG_ENTRY_ID_1 = cDefs..KEGG_ENTRY_ID;
cDefs..KEGG_ENTRY_ID_2 = cDefs..KEGG_ENTRY_ID;

#     annotation column definitions
cDefs = networkDefinitions["pathway"]..columnDefinitions..annotation;   # shortcut for simpler access (by pointer)
cDefs..KEGG_NODE_TYPE             = [columnType: "annotation", infoKey: "pathwayNodeType",  targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..KEGG_ID                    = [columnType: "annotation", infoKey: "keggId",           targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..KEGG_ENTRY_NAME            = [columnType: "annotation", infoKey: "keggName",         targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..KEGG_NODE_LABEL_LIST_FIRST = [columnType: "annotation", infoKey: "nodeName",         targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..KEGG_NODE_LABEL_SHORT = cDefs..KEGG_NODE_LABEL_LIST_FIRST;
cDefs..KEGG_NODE_LABEL_LIST       = [columnType: "annotation", infoKey: "nodeNameSynonyms", targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..KEGG_NODE_LABEL_LONG = cDefs..KEGG_NODE_LABEL_LIST;
cDefs..KEGG_NODE_FILL_COLOR       = [columnType: "annotation", infoKey: "nodeColor",        targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]]
cDefs..KEGG_NODE_BGCOLOR = cDefs..KEGG_NODE_FILL_COLOR;
cDefs..KEGG_DEFINITION            = [columnType: "annotation", infoKey: "nodeDescription",  targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..KEGG_NODE_X                = [columnType: "annotation", infoKey: "x",                targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..KEGG_NODE_Y                = [columnType: "annotation", infoKey: "y",                targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..KEGG_NODE_Z                = [columnType: "annotation", infoKey: "z",                targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];

cDefs..KEGG_NODE_GRAPHICS_TYPE    = [columnType: "annotation", infoKey: "nodeGraphicsType", targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..KEGG_NODE_HEIGHT           = [columnType: "annotation", infoKey: "nodeHeight",       targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..KEGG_NODE_WIDTH            = [columnType: "annotation", infoKey: "nodeWidth",        targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..KEGG_GROUP_COMPONENTS      = [columnType: "annotation", infoKey: "groupComponents",  targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..KEGG_ENTRY_DB_LINK         = [columnType: "annotation", infoKey: "keggDbLink",       targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..KEGG_REACTION_NAME         = [columnType: "annotation", infoKey: "reactionName",     targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..KEGG_REACTION_NAME         = [columnType: "annotation", infoKey: "logicGroupId",     targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..LOGIC_RULE_ID              = [columnType: "annotation", infoKey: "logicRuleId",      targetTypes: ["node","edge"], targetNodeTypes: ["pathwayNode"]];


cDefs..KEGG_NODE_FGCOLOR          = [columnType: "annotation", infoKey: "nodeLabelColor",   targetTypes: ["node"], targetNodeTypes: ["pathwayNode"]];
cDefs..KEGG_RELATION_TYPE         = [columnType: "annotation", infoKey: "relationType",     targetTypes: ["edge"]];
cDefs..KEGG_EDGE_SUBTYPES         = [columnType: "annotation", infoKey: "relationSubtypes", targetTypes: ["edge"]];
cDefs..KEGG_EDGE_LABELS           = [columnType: "annotation", infoKey: "relationLabels",   targetTypes: ["edge"]];


#    default values
dDefs = networkDefinitions["pathway"]..columnDefinitions..default;   # shortcut for simpler access (by pointer)
dDefs..nodeProperties = {};
dDefs..nodeProperties..pathwayNodeId = [subType: "gene"];
dDefs..annotations = {};
dDefs..annotations..pathwayNodeType = "gene";           # or better as nodeProperty?

#     rendering definitions
networkDefinitions["pathway"]..renderingDefinitions = {};
rDefs = networkDefinitions["pathway"]..renderingDefinitions;   # shortcut for simpler access (by pointer)
#       default
rDefs..default = [default: [size: 15]];
#       ageingFactor
rDefs..pathwayNode = [default: [size: 25, color: "magenta"],
		      subTypeSpecific: [gene:         [color: "[255,0,255]",
                                                       size: 40],
                                        compound:     [color: "[200,155,200]",
                                                       size: 23],
                                        ortholog: [color: "[176,93,229]"],
                                        reaction: [color: "[220,220,220]"],
                                        map: [color: "[187,187,187]"]
                                       ]
                      ];

#     label definitions
networkDefinitions["pathway"]..labelDefinitions = {};
lDefs = networkDefinitions["pathway"]..labelDefinitions;   # shortcut for simpler access (by pointer)
lDefs..pathwayNode = [default: [short: [[infoKey: "nodeName"]],
                                  long: [[infoKey: "pathwayNodeType", setCase: "capitalize"], [value: ": "], [infoKey: "nodeName"], [value: "|(KEGG ID:"], [infoKey: "nodeId"], [value: ", #"], [infoKey: "nodeNumber"], [value: ")"]],
                                  custom: [[infoKey: "pathwayNodeType", setCase: "capitalize"], [value: ": "], [infoKey: "nodeName"], [value: "|(KEGG ID:"], [infoKey: "nodeId"], [value: ", #"], [infoKey: "nodeNumber"], [value: ")"]]
                                ]
                      ];

#   translations
networkDefinitions["pathway"]..translations = {};
translations = networkDefinitions["pathway"]..translations;   # shortcut for simpler access (by pointer)
#      typeToTypeId
translations..typeToTypeId = {}
translations..typeToTypeId..default          = "UNK";
translations..typeToTypeId..pathwayNode      = "PW";
translations..typeToTypeId..gene             = "GEN";
translations..typeToTypeId..group            = "GRP";
translations..typeToTypeId..compound         = "CMP";
translations..typeToTypeId..ortholog         = "ORT";
translations..typeToTypeId..map              = "MAP";
translations..typeToTypeId..reaction         = "REA";
#      typeToSingleLetter
translations..typeToSingleLetter = {};
translations..typeToSingleLetter..default     = "U";
translations..typeToSingleLetter..pathwayNode = "P";
translations..typeToSingleLetter..gene        = "Ge";
translations..typeToSingleLetter..group       = "R";
translations..typeToSingleLetter..compound    = "C";
translations..typeToSingleLetter..ortholog    = "O";
translations..typeToSingleLetter..map         = "Mo";
translations..typeToSingleLetter..group       = "Re";

#   normalizations
networkDefinitions["pathway"]..normalizations = {};
normalizations = networkDefinitions["pathway"]..normalizations;   # shortcut for simpler access (by pointer)

###########################################
# #### Input/Output format definitions ####
###########################################
ioDefinitions = {};
ioDefinitions..formats = {};
#   mmCIF format
ioDefinitions..formats..mmcif = {};
var mmcif = ioDefinitions..formats..mmcif;   # shortcut for simpler access (by pointer)
#     general settings
mmcif..general = {};
mmcif..general..extension   = "cif";
mmcif..general..maxLineSize = 2048;
#mmcif..general..header      = "#\#CIF_1.1";

#     translations
mmcif..translations = {};
mmcif..translations..infoKeys = {};
mmcif..translations..infoKeys.["atom_site.group_PDB"]         = "atomClass";
mmcif..translations..infoKeys.["atom_site.id"]                = "nodeNumber";
mmcif..translations..infoKeys.["atom_site.type_symbol"]       = "nodeTypeId";
mmcif..translations..infoKeys.["atom_site.label_alt_id"]      = "altLoc";
mmcif..translations..infoKeys.["atom_site.pdbx_PDB_ins_code"] = "insertionCode";
mmcif..translations..infoKeys.["atom_site.Cartn_x"]           = "x";
mmcif..translations..infoKeys.["atom_site.Cartn_y"]           = "y";
mmcif..translations..infoKeys.["atom_site.Cartn_z"]           = "z";
mmcif..translations..infoKeys.["atom_site.auth_seq_id"]       = "nodeNumber";
mmcif..translations..infoKeys.["atom_site.auth_comp_id"]      = "nodeSubTypeId";
mmcif..translations..infoKeys.["atom_site.auth_asym_id"]      = "subnetworkNumber";
mmcif..translations..infoKeys.["atom_site.auth_atom_id"]      = "nodeTypeId";
mmcif..translations..infoKeys.["atom_site.B_iso_or_equiv"]    = "temperature";
#
mmcif..translations..infoKeys.["struct_conn.id"]                  = "edgeNumber";
mmcif..translations..infoKeys.["struct_conn.conn_type_id"]        = "bondType";
mmcif..translations..infoKeys.["struct_conn.ptnr1_auth_asym_id"] = "subnetworkNumber";
mmcif..translations..infoKeys.["struct_conn.ptnr1_label_atom_id"] = "nodeTypeId1";
mmcif..translations..infoKeys.["struct_conn.ptnr1_auth_comp_id"] = "nodeSubTypeId1";
mmcif..translations..infoKeys.["struct_conn.ptnr1_auth_seq_id"]  = "nodeNumber1";
mmcif..translations..infoKeys.["struct_conn.ptnr2_auth_asym_id"] = "subnetworkNumber";
mmcif..translations..infoKeys.["struct_conn.ptnr2_label_atom_id"] = "nodeTypeId2";
mmcif..translations..infoKeys.["struct_conn.ptnr2_auth_comp_id"] = "nodeSubTypeId2";
mmcif..translations..infoKeys.["struct_conn.ptnr2_auth_seq_id"]  = "nodeNumber2";
#     default values
mmcif..defaults = {};
mmcif..defaults..atomClass        = "HETATM";
mmcif..defaults..insertionCode    = "?";
mmcif..defaults..altLoc           = ".";
mmcif..defaults..x                = 1.0;
mmcif..defaults..y                = 1.0;
mmcif..defaults..z                = 1.0;
mmcif..defaults..nodeNumber       = 0;
mmcif..defaults..subnetworkNumber = "1";
mmcif..defaults..bondType         = "covale";
mmcif..defaults..nodeTypeId       = "U";
mmcif..defaults..nodeTypeId1      = "U";
mmcif..defaults..nodeTypeId2      = "U";
mmcif..defaults..nodeSubTypeId    = "UNK_UNK";
mmcif..defaults..nodeSubTypeId1   = "UNK_UNK";
mmcif..defaults..nodeSubTypeId2   = "UNK_UNK";
mmcif..defaults..nodeNumber1      = 0;
mmcif..defaults..nodeNumber2      = 0;
mmcif..defaults..edgeNumber       = 0;

###################################
### Network data initialization ###
###################################
networkData = [mode: "new",
               networkType: "agefactdb",
               fileType: "tsv",
               networkDefinitions: networkDefinitions,
               ioDefinitions: ioDefinitions,
               fileList: [],
               layoutOptions: layoutOptions,
               subsets: [full: [nodeInfo: {}, edgeInfo: {}]],
               options: [loadCoordinateMode: "random"]
              ];
networkData..networkDefinition = networkData..networkDefinitions..[networkData..networkType];
if (networkData..networkDefinition.type != "hash") {
  networkData..networkDefinition = {};
}

#################
### Functions ###
#################
function isNumeric(value) {
  var numeric   = false;
  var valueType = value.type;

  if (valueType == "integer" OR valueType == "decimal") {
    numeric = true;
  } elseif (valueType == "string") {
    if (value.size > 0) {
      var check     = 0 + value;
      var checkType = check.type;
      if (checkType == "integer" OR checkType == "decimal") {
        var check2 = "" + check;
        if (check2 == value) {
          numeric = true;
        }
      }
    }
  }

  return numeric;
}

function parseNetworkDefinitions(networkDefs) {
  var defaultRendering = [size: 15];

  # Check required parameters
  if (networkDefs.type != "hash") {
    var msg = "no network definition hash provided in call of method 'parseNetworkDefinitions'";
    logMsg([level: "error", msg: msg]);
    return;
  }

  var networkTypes = networkDefs.keys;
  for (var networkType in networkTypes) {
    var networkDef  = networkDefs[networkType];
    if (networkDef..edgeType == "" || networkDef..edgeType.type != "string") {
      networkDef..edgeType = "undirected";
    }
    networkDef..columnTypes = {};
    var columnTypes = networkDef..columnDefinitions.keys;
    if (columnTypes.size > 0) {
      for (var columnType in columnTypes) {
        var columnNames   = networkDef..columnDefinitions.[columnType].keys;
        var columnTypeKey = "" + columnType + "Columns";
        for (var columnName in columnNames) {
          var columnDef     = networkDef..columnDefinitions.[columnType].[columnName];
          if (networkDef[columnTypeKey].type != "hash") {
            networkDef[columnTypeKey] = {};
          }
          networkDef[columnTypeKey].[columnName] = true;
          networkDef..columnTypes.[columnType]   = true;
        }
      }
    }

    networkDef["renderings"] = [default: [size: defaultRendering..size, subTypeSpecific: {}]];   # '..' NOTATION ("networkDef..renderings") PROVOKED ERROR IN THIS CONTEXT in Jmol 14.5.1 and 14.4.0
    var nodeTypes = networkDef..renderingDefinitions.keys;
    if (nodeTypes.size > 0) {
      for (var nodeType in nodeTypes) {
        var currentDef   = networkDef..renderingDefinitions..[nodeType];
        var renderingDef = [subTypeSpecific: {}];
        var defaultSize  = defaultRendering..size;
        var defaultColor = "";

        if (currentDef..default.type == "hash") {
          if (currentDef..default..size != "") {
            defaultSize = currentDef..default..size;
          }
          if (currentDef..default..color != "") {
            defaultColor = currentDef..default..color;
          }
          renderingDef..default = currentDef..default;
        }
        renderingDef..size = defaultSize;
        if (defaultColor != "") {
          renderingDef..color = defaultColor;
        }

        if (currentDef..subTypeSpecific.type == "hash") {
          renderingDef..subTypeSpecific = {};
          for (var nodeSubType in currentDef..subTypeSpecific) {
            var subTypeDef = currentDef..subTypeSpecific..[nodeSubType];
            var size  = defaultSize;
            var color = defaultColor;
            if (subTypeDef..size != "") {
	      size = subTypeDef..size;
            }
            if (subTypeDef..color != "") {
	      color = subTypeDef..color;
            }
            renderingDef..subTypeSpecific..[nodeSubType] = [size: size];
            if (color != "") {
              renderingDef..subTypeSpecific..[nodeSubType]..color = color;
            }
          }
        }

        networkDef..renderings..[nodeType] = renderingDef;
      }
    }

  }
}

function exportAsArrayDefinition(nodeSet) {
  var output = ["  xCoords = [];", "  yCoords = [];", "  zCoords = [];", ""];
  var line   = "";
  if (nodeSet) {
    if (nodeSet.size > 0) {
      var nodeCount = nodeSet.size;
      for (var i=1; i<=nodeCount; i++) {
        x = nodeSet[i].x;
        y = nodeSet[i].y;
        z = nodeSet[i].z;
        line = '  xCoords.push("' + x + '");';
        output.push(line);
        line = '  yCoords.push("' + y + '");';
        output.push(line);
        line = '  zCoords.push("' + z + '");';
        output.push(line);
      }
    }
  }
  print output.join("\n");
}

function infoToTsv(dataHashref) {
  var msg            = "";
  var headerMode     = "withHeader"; # available modes: 'noHeader', 'withHeader', 'headerOnly'
  var outputType     = "string";     # available outputTypes: 'string', 'array', 'htmlTable', 'verticalHtmlTable'
  var lineOutputType = outputType;
  var lineSeparator  = "\n";
  var fieldSeparator = "\t";
  var infoType       = "hash";
  var infoProperty   = "info";
  var cssClass       = "jsnet3d";
  var postfix        = "\n</table>\n";
  var info           = {};
  var output         = [];

  # Check required parameters
  if (dataHashref.type != "hash") {
    msg = msg + "ERROR: parameter 'dataHashref' MUST BE A HASH REFERENCE in call of method 'infoToTsv'\n";
  } else {
    if (dataHashref..infoProperty != "" && dataHashref..infoProperty.type == "string") {
      infoProperty = dataHashref..infoProperty;
    }
    infoType = dataHashref.[infoProperty].type;
    if (infoType != "hash" && infoType != "array") {
      msg = msg + "ERROR: subparameter 'dataHashref..info' MUST BE A HASH OR ARRAY REFERENCE in call of method 'infoToTsv'\n";
    } else {
      info = dataHashref.[infoProperty];
    }
    if (dataHashref..headerMode != "") {
      headerMode = dataHashref..headerMode;
    }
    if (dataHashref..outputType != "") {
      outputType = dataHashref..outputType;
    } else {
      dataHashref..outputType = outputType;
    }
    if (dataHashref..lineOutputType != "") {
      lineOutputType = dataHashref..lineOutputType;
    } else {
      lineOutputType = outputType;
      dataHashref..lineOutputType = lineOutputType;
    }
    if (dataHashref..fieldSeparator != "") {
      fieldSeparator = dataHashref..fieldSeparator;
    } else {
      dataHashref..fieldSeparator = fieldSeparator;
    }
    if (dataHashref..cssClass != "") {
      cssClass = dataHashref..cssClass;
    }
  }
  if (msg != "") {
    logMsg([level: "error", msg: msg]);
    return "";
  }

  var cssClassAttribute = "";
  if (cssClass != "") {
    cssClassAttribute = ' class="' + cssClass + '"';
  }
  var prefix         = "<table" + cssClassAttribute + ">\n";

  if (outputType == "verticalHtmlTable") {
    lineSeparator = '<hr class="separatorSmall">';
    dataHashref..mode = "withHeader";
  }

  if (info.size > 0) {
    if (infoType == "hash") {
      if (outputType == "verticalHtmlTable") {
        dataHashref..infoKeys = "";
      } else {
        # Determine all hash keys for building header
        var infoKeys = {};
        for (var entryKey IN info) {
          if (info.[entryKey].type == "hash") {
            currentKeys = info.[entryKey].keys;
            for (var currentKey IN currentKeys) {
              infoKeys[currentKey]++;
            }
          } else {
            msg = msg + "ERROR: values in second level of parameter 'info' MUST BE HASH REFERENCES in call of method 'infoToTsv'\n";
          }
        }
        dataHashref..infoKeys = infoKeys.keys.sort;
      }

      # Convert entries
      var firstEntry = true;
      for (var entryKey IN info) {
        if (info.[entryKey].type == "hash") {
          dataHashref..currentInfo = info.[entryKey];
          if (outputType == "htmlTable") {
            if (firstEntry) {
              dataHashref..mode = "headerOnly";
              output.push(hashToTsvLine(dataHashref));
              firstEntry = false;
            }
            dataHashref..mode = "noHeader";
            output.push(hashToTsvLine(dataHashref));
          } elseif (outputType == "verticalHtmlTable") {
            dataHashref..mode = "withHeader";
            output.push(hashToTsvLine(dataHashref));
          } else {
            if (headerMode == "withHeader") {
              if (firstEntry) {
                dataHashref..mode = "headerOnly";
                output.push(hashToTsvLine(dataHashref));
                firstEntry = false;
              }
              dataHashref..mode = "noHeader";
              output.push(hashToTsvLine(dataHashref));
            } elseif (mode == "headerOnly") {
              dataHashref..mode = "headerOnly";
              output.push(hashToTsvLine(dataHashref));
              break;
            }
          }
        } else {
          msg = msg + "ERROR: values in second level of parameter 'info' MUST BE HASH REFERENCES in call of method 'infoToTsv'\n";
        }
      }
    } elseif (infoType == "array") {
      for (var currentInfo IN info) {
        if (currentInfo.type == "hash") {
          dataHashref..currentInfo = currentInfo;
          output.push(hashToTsvLine(dataHashref));
        } else {
          msg = msg + "ERROR: values in second level of parameter 'info' MUST BE HASH REFERENCES in call of method 'infoToTsv'\n";
        }
      }
    }
  }

  if (msg != "") {
    logMsg([level: "error", msg: msg]);
    return "";
  }

  switch outputType {
    case "array":
      return output;
      break;
    case "string":
      return output.join(lineSeparator);
    case "htmlTable":
      return prefix + output.join(lineSeparator) + postfix;
    case "verticalHtmlTable":
      return output.join(lineSeparator);
    default:
      logMsg([level: "error", msg: "unknown output type '" + outputType + "' in call of method 'infoToTsv'"]);
      return;
      break;
  }
}

function hashToTsvLine(dataHashref) {
  var msg               = "";
  var output            = [];
  var mode              = "noHeader";   # available modes: 'noHeader', 'headerOnly', 'withHeader'
  var outputType        = "string";     # available outputTypes: 'string', 'array', 'htmlTable', 'verticalHtmlTable'
  var fieldSeparator    = "\t";
  var valueSeparator    = " || ";
  var cssClass          = "";
  var cssClassAttribute = "";
  var prefix            = "";
  var postfix           = "";
  var currentInfo       = {};
  var infoKeys          = [];

  # Check required parameters
  if (dataHashref.type == "hash") {
    if (dataHashref..currentInfo.type != "hash") {
      msg = msg + "ERROR: subparameter 'dataHashref..info' NOT PROVIDED (as hash reference) in call of method 'hashToTsvLine'\n";
    } else {
      currentInfo = dataHashref..currentInfo;
      if (dataHashref..infoKeys.type == "array") {
        infoKeys = dataHashref..infoKeys;
      } else {
        infoKeys = currentInfo.keys.sort;
      }
      if (dataHashref..mode != "") {
        mode = dataHashref..mode;
      }
      if (dataHashref..lineOutputType != "") {
        outputType = dataHashref..lineOutputType;
      }
      if (dataHashref..fieldSeparator != "") {
        fieldSeparator = dataHashref..fieldSeparator;
      }
      if (dataHashref..valueSeparator != "") {
        valueSeparator = dataHashref..valueSeparator;
      }
      if (dataHashref..cssClass != "") {
        cssClass = dataHashref..cssClass;
      }
    }
  } else {
    msg = msg + "ERROR: parameter 'dataHashref' MUST BE A HASH REFERENCE in call of method 'hashToTsvLine'\n";
  }
  if (msg != "") {
    logMsg([level: "error", msg: msg]);
    return;
  }

  if (cssClass != "") {
    cssClassAttribute = ' class="' + cssClass + '"';
  }

  if (outputType == "verticalHtmlTable") {
    fieldSeparator = "";
    prefix         = "<table" + cssClassAttribute + ">";
    postfix        = "</table>";
  } elseif (outputType == "htmlTable") {
    if (mode == "noHeader") {
      fieldSeparator = "</td><td" + cssClassAttribute + ">";
      prefix         = "<tr" + cssClassAttribute + "><td" + cssClassAttribute + ">";
      postfix        = "</td></tr>";
    } else {
      fieldSeparator = "</th><th" + cssClassAttribute + ">";
      prefix         = "<tr" + cssClassAttribute + "><th" + cssClassAttribute + ">";
      postfix        = "</th></tr>";
    }
  }

  if (currentInfo.size > 0) {
    if (currentInfo.type == "hash") {
      for (var infoKey IN infoKeys) {
        var infoData = "";
        if (mode == "headerOnly") {
          infoData = infoKey;
        } elseif (mode == "noHeader" || mode=="withHeader") {
          switch(currentInfo[infoKey].type) {
            case "string":
              infoData = currentInfo[infoKey];
              break;
            case "hash":
              switch(infoKey) {
                case "alleleTypes":
                  var multiInfo = [];
                  for (var nodeKey IN currentInfo[infoKey].keys) {
                    var subInfo = currentInfo[infoKey].[nodeKey];
                    var infoPart = changeCase(subInfo..ageingFactorType) + ": " + subInfo..ageingFactorName + " (" + subInfo..ageingFactorId + "), " + " Allele type: " + subInfo..alleleTypes;
                    multiInfo.push(infoPart);
                  }
                  infoData = multiInfo.join(valueSeparator);
                  break;
                case "alleleTypesBase":
                  var multiInfo = [];
                  for (var nodeKey IN currentInfo[infoKey].keys) {
                    var subInfo = currentInfo[infoKey].[nodeKey];
                    var infoPart = changeCase(subInfo..ageingFactorType) + ": " + subInfo..ageingFactorName + " (" + subInfo..ageingFactorId + "), " + " Allele type: " + subInfo..alleleTypesBase;
                    multiInfo.push(infoPart);
                  }
                  infoData = multiInfo.join(valueSeparator);
                  break;
                default:
                  infoData = currentInfo[infoKey].keys.join(valueSeparator);
                  break;
              }
              break;
            case "array":
              infoData = currentInfo[infoKey].join(valueSeparator);
              break;
            default:
              infoData = currentInfo[infoKey];
              break;
          }
        }
        if (outputType == "verticalHtmlTable") {
	  var outputLine = "<tr" + cssClassAttribute + "><th" + cssClassAttribute + ">" + infoKey + ":</th><td" + cssClassAttribute + ">" + infoData + "</td></tr>";
          output.push(outputLine);
        } else {
          output.push(infoData);
        }
      }
    }
  }

  switch outputType {
    case "array":
      return output;
      break;
    case "string":
      return output.join(fieldSeparator);
    case "htmlTable":
      return prefix + output.join(fieldSeparator) + postfix;
    case "verticalHtmlTable":
      return prefix + output.join(fieldSeparator) + postfix;
    default:
      logMsg([level: "error", msg: "unknown output type '" + outputType + "' in call of method 'hashToTsvLine'"]);
      return;
      break;
  }
}

function tsvToArrayOfHashes(tsvData) {
  var arrayData2 = [];
  if (tsvData.type == "string" || tsvData.type="array") {
    var arrayData = tsvData.split("\t", true);

    if (arrayData.size > 0) {
      arrayData2[arrayData.size - 1] = 0;
      var hKeys = [];
      var hLineData = arrayData[1];
      #print hLineData;
      for (var i=hLineData.size; i>0; i--) {
        hKeys[i] = hLineData[i];
      }
      #print hKeys;
      for (var i=arrayData.size; i>1; i--) {
        var lineData = arrayData[i];
        arrayData2[i] = {};
        var lineData2 = arrayData2[i];
        for (var j=1; j<=lineData.size; j++) {
          var hKey = hKeys[j];
          #print "i=" + i + "  j=" + j + "  hKey=" + hKey + "  data=" + lineData[j];
          linedata2[hKey] = (lineData[j]);
        }
      }
    }
  }

  return arrayData2;
}

function readTsvFile(tsvFilename) {
  var msg = "";
  var startTime = now();
  # Check required parameters
  if (tsvFilename == "") {
    var msg = "parameter 'tsvFilename' NOT PROVIDED in call of method 'readTsvFile'";
    logMsg([level: "error", msg: msg]);
    return;
  }

  logmsg([level: "info", msg: "loading TSV file " + tsvFilename + "..."]);
  var parsedData = [];
  var tsvData    = [];

  while(true) {
     try {    # try/catch does not work with arbitrary files 
       tsvData = load(tsvFilename);
     } catch(errorMessage) {
       print errorMessage
       logMsg([level: "error", msg: "could not load TSV file '" + tsvFilename + "'"]);
       return parsedData;
     }
     tsvData = tsvData.split("\t", true);
     logMsg([level: "info", msg: "    loaded TSV file '" + tsvFilename + "'"]);
     break;
  }


  #logMsg([level: "info", msg: "     finished first step (time=" + now(startTime) + " ms)"]);
  #log script("show tsvData");

  if (tsvData.size > 0) {
    parsedData = tsvData.format(tsvData[1]);
  }

  logMsg([level: "info", msg: "  finished loading TSV file '" + tsvFilename + "' (rows=" + tsvData.size + ", time=" + now(startTime) + " ms)"]);
  return parsedData;
}

function loadNetworkData(dataHashref) {
  var msg           = "";
  var deleteRawData = false;

  # Check required parameters
  if (dataHashref.type != "hash") {
    msg = "parameter 'tsvFilename' NOT PROVIDED in call of method 'loadNetworkData'";
    logMsg([level: "error", msg: msg]);
    return;
  }
  if (dataHashref["mode"] == "") {
    dataHashref["mode"] == "new";
  }
  if (dataHashref["networkType"] == "") {
    dataHashref["networkType"] == "generic";
  }
  if (dataHashref["fileType"] == "") {
    dataHashref["fileType"] == "tsv";
  }
  if (dataHashref["fileList"].type != "array") {
    if (dataHashref["fileList"] != "") {
      dataHashref["fileList"] = [dataHashref["fileList"]];
    }
  }
  if (dataHashref["deleteRawDataAfterParsing"] != "") {
    deleteRawData = dataHashref["deleteRawDataAfterParsing"];
  }

  dataHashref..networkDefinition = dataHashref..networkDefinitions..[dataHashref..networkType];
  if (dataHashref..networkDefinition.type != "hash") {
    dataHashref..networkDefinition = {};
  }


  var mode     = dataHashref["mode"];
  var fileType = dataHashref["fileType"];
  var fileList = dataHashref["fileList"];

  if (fileType == "tsv") {
    var tsvData = [];
    if (mode == "new") {
      dataHashref["tsvData"] = tsvData;
    } elseif (mode == "add") {
      tsvData = dataHashref["tsvData"];
    } else {
      msg = "mode '" + mode + "' NOT SUPPORTED in call of method 'readTsvFile'";
      logMsg([level: "error", msg: msg]);
      return;
    }
    var fileCount    = tsvData.size;
    var newFileCount = fileCount + fileList.size;
    for (var fileNumber from [fileCount+1,  newFileCount]) {
      var fileName = fileList[fileNumber - fileCount];
      tsvData[fileNumber] = {};
      tsvData[fileNumber].["fileName"] = fileName;
      tsvData[fileNumber].["fileType"] = fileType;
      tsvData[fileNumber].["data"]     = readTsvFile(fileName);
    }

    parseNetworkTsvData(dataHashref);

    if (deleteRawData) {
      if (networkData..tsvData.type == "array") {
        for (var dataSet in networkData..tsvData) {
          dataSet..data = [];  # file names etc. are kept to document which data were loaded 
        }
      }
    }
  } else {
    msg = "fileType '" + filetype + "' NOT SUPPORTED in call of method 'readTsvFile'";
    logMsg([level: "error", msg: msg]);
    return;
  }  
}

function parseNetworkTsvData(dataHashref) {
  var msg                    = "";
  var networkType            = "";
  var rowCount               = 0;
  var fileName               = "";
  var tsvData                = "";
  var edgeType               = "undirected";
  var annotationColumns      = {};
  var edgeAnnotationColumns  = {};
  var columnTypes            = [];
  var nodeColumns            = {};
  var networkDefs            = {};
  var columnDefs             = {};
  var allNodes               = {};
  var nodeTypeInfo           = {};
  var nodeColumnsFound       = {};
  var nodeTypesFound         = {};
  var annotationColumnsFound = {};
  var edgeAnnotationColumnsFound = {};
  var normalizations         = {};
  var loadCoordinateMode     = "random";
  var coordinateScalingFactor = 1.0;

  # Check required parameters
  if (dataHashref.type != "hash") {
    msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED in call of method 'parseNetworkTsvData'\n";
  } else {
    networkType = dataHashref.networkType;  # '..' notation fails in Jmol 14.3.13_2015.03.30 if variable name is identical to hash key
    if (networkType == "") {
      networkType == "generic";
    }
    dataHashref..currentSubsetKey = "full";
    if (dataHashref..subsets.type != "hash") {
      dataHashref..subsets = {};
      dataHashref..subsets.[dataHashref..currentSubsetKey] = {};
    } elseif (dataHashref..subsets.[dataHashref..currentSubsetKey].type != "hash") {
      dataHashref..subsets.[dataHashref..currentSubsetKey] = {};
    }
    allNodes = dataHashref..subsets.[dataHashref..currentSubsetKey];
    if (dataHashref..networkDefinitions.type != "hash") {
      msg = msg + "ERROR: parameter 'dataHashref..networkDefinitions' NOT PROVIDED in call of method 'parseNetworkTsvData'\n";
    } else {
      if (dataHashref..networkDefinitions.[networkType].type != "hash") {
        msg = msg + "ERROR: no network definition found for network type '" + networkType + "' in method 'parseNetworkTsvData'\n";
      } else {
        if (dataHashref..networkDefinitions.[networkType]..nodeColumns.type != "hash") {
          # Maybe network definitions just were not parsed yet
          parseNetworkDefinitions(dataHashref..networkDefinitions);
          if (dataHashref..networkDefinitions.[networkType]..nodeColumns.type != "hash") {
            msg = msg + "ERROR: no nodeColumns array reference found in network definition for network type '" + networkType + "' in method 'parseNetworkTsvData'\n";
          }
        }
      }
    }
    if (dataHashref..tsvData.type != "array") {
      msg = msg + "ERROR: parameter 'tsvData' NOT PROVIDED OR NOT AN ARRAY in call of method 'parseNetworkTsvData'\n";
    }
    if (dataHashref..options.type == "hash") {
      if (dataHashref..options..loadCoordinateMode != "") {
        loadCoordinateMode = dataHashref..options..loadCoordinateMode;
      }
      if (dataHashref..options..coordinateScalingFactor != "") {
        coordinateScalingFactor = dataHashref..options..coordinateScalingFactor;
      }
    }
  }
  if (msg != "") {
    logMsg([level: "mixed", msg: msg]);
    return;
  }
  
  var fileCount = dataHashref..tsvData.size;
  #log "DEBUG: networkType=" + networkType + "  fileCount=" + fileCount;
  if (fileCount >0) {
    annotationColumns     = {};
    edgeAnnotationColumns = {};
    var startTime = now();
    logMsg([level: "info", msg: "started parsing " + fileCount + " TSV files (type=" + networkType + ")..."]);
    networkDefs = dataHashref..networkDefinitions.[networkType];
    columnDefs  = networkDefs..columnDefinitions;
    columnTypes = networkDefs..columnTypes.keys;
    nodeColumns = networkDefs..nodeColumns;
    if (networkDefs..edgeType != "") {
      edgeType = networkDefs..edgeType;
    }
    if (networkDefs..annotationColumns.type == "hash") {
      for (var column IN networkDefs..annotationColumns) {
        var targetTypes = ["node"];    # default
        if (networkDefs..annotationColumns.[column]..targetTypes.type == "array") {
          targetTypes = networkDefs..annotationColumns.[column]..targetTypes;
        }
        for (var targetType IN targetTypes) {
          switch(targetType) {
            case "node":
              annotationColumns.push(column);
              break;
            case "edge":
              edgeAnnotationColumns.push(column);
              break;
          }
        }
        annotationColumns = networkDefs..annotationColumns;  # '..' notation fails in Jmol 14.3.13_2015.03.30 if variable name i identical to hash key
      }
    }
    if (networkDefs..normalizations.type == "hash") {
      normalizations = networkDefs..normalizations;
    }
    #log "DEBUG: ===== columnType ============\n" + columnTypes;
    #log "DEBUG: ===== nodeColumns ============\n" + nodeColumns;
    #log "DEBUG: ===== annotationColumns ============\n" + annotationColumns;
    #log "DEBUG: ===== edgeAnnotationColumns ============\n" + edgeAnnotationColumns;
    if (allNodes..nodeInfo.type != hash) {
      allNodes..nodeInfo = {};
    }
    if (allNodes..edgeInfo.type != hash) {
      allNodes..edgeInfo = {};
    }
    if (allNodes..edgeKeysUsed.type != hash) {
      allNodes..edgeKeysUsed = {};
    }
    if (allNodes..neighbours.type != hash) {
      allNodes..neighbours = {};
    }

    # Initialize random number generator
    #print "DEBUG: init random with '" + dataHashref.layoutOptions.fr.randomCoordinateSeed + "'";
    var initRandom = random(0,1,dataHashref.layoutOptions.fr.randomCoordinateSeed);

    var fileNumber = 0;
    var rowLimit   = 0;
    while (fileNumber < fileCount) {
      fileNumber++;
      if (dataHashref..tsvData.[fileNumber].type == "hash") {
        fileName = dataHashref["tsvData"].[fileNumber].fileName;  # '..' notation fails in Jmol 14.3.13_2015.03.30 if variable name is identical to hash key
        tsvData  = dataHashref["tsvData"].[fileNumber]..data;     # '..' notation fails in Jmol 14.3.13_2015.03.30 if variable name is identical to hash key
        if (tsvData.type == "array") {
          rowCount = tsvData.size;
          rowLimit = rowCount;
          if (dataHashref..rowLimit.type == "integer") {
            rowLimit = dataHashref..rowLimit;
          }
          logMsg([level: "info", msg: "   parsing " + rowLimit + " of " + rowCount + " TSV data rows of file '" + fileName + "' (" + fileNumber + " of " + fileCount + ")..."]);
          if (rowCount > 0) {
              nodeColumnsFound       = {};
              nodeTypesFound         = {};
              annotationColumnsFound = {};

            # Look in first row for available node columns first
            var columnNumber = 0;
            var columnType   = "node";
            #print tsvData[1];
            for (var column in tsvData[1].keys) {
              #logMsg("  parsing header row - columnNumber=" + columnNumber + "  column=" + column);
              # Build generic definitions if necessary
              if (networkType == "generic") {
                # Build column definition
                if (columnDefs[columnType].[column].type != "hash") {
                  columnDefs[columnType].[column] = {"columnType": "node"};
                  columnDefs[columnType].[column]..infoKey  = column;
                  columnDefs[columnType].[column]..nodeType = column;
                }
                # Add column to 'nodeColumns' hash
                nodeColumns.[column] = true;
              }
              columnNumber++;
              if (nodeColumns[column]) {
                nodeColumnsFound[column] = { "columnNumber": columnNumber };
                if (columnDefs[columnType].[column].type != "hash") {
                  msg = msg + "ERROR: no column definition subhash found for node column '" + column + "' (networkType=" + networkType + ") in method 'parseNetworkTsvData'\n";
                } else {
                  var nodeType = columnDefs[columnType].[column].nodeType;  # '..' notation fails in Jmol 14.3.13_2015.03.30 if variable name is identical to hash key
                  if (nodeTypesFound[nodeType].type != "hash") {
                    nodeTypesFound[nodeType] = {};
                    #log "DEBUG:  defined 'nodeTypesFound' for nodeType=" + nodeType;
                    #log nodeTypesFound;
                  }
                  if (nodeTypesFound[nodeType]..columnNumbers.type != "array") {
                    nodeTypesFound[nodeType]..columnNumbers = [];
                  }
                  nodeTypesFound[nodeType]..columnNumbers.push(columnNumber);
                  if (nodeTypesFound[nodeType]..minColumnNumber == "") {
                    nodeTypesFound[nodeType]..minColumnNumber = columnNumber;
                  } else {
                    nodeTypesFound[nodeType]..minColumnNumber = [nodeTypesFound[nodeType]..minColumnNumber, columnNumber].min % 0;    # '% 0' needed to convert result back to integer
                  }
                  if (nodeTypesFound[nodeType]..maxColumnNumber == "") {
                    nodeTypesFound[nodeType]..maxColumnNumber = columnNumber;
                  } else {
                    nodeTypesFound[nodeType]..maxColumnNumber = [nodeTypesFound[nodeType]..maxColumnNumber, columnNumber].max % 0;    # '% 0' needed to convert result back to integer
                  }
                  var subTypeInfoKeys = [];
                  if (columnDefs[columnType].[column]..subTypeInfoKeys.type =="array") {
                    subTypeInfoKeys = columnDefs[columnType].[column]..subTypeInfoKeys;
                  }
                  nodeColumnsFound[column]..subTypeInfoKeys = subTypeInfoKeys;

                  if (columnDefs[columnType].[column]..temperatureInfoKey != "") {
                    nodeColumnsFound[column]..temperatureInfoKey = columnDefs[columnType].[column]..temperatureInfoKey;
                  }
                }
                #log "DEBUG: ========== nodeTypesFound (" + column + ", " + columnNumber + ") =============";
                #log nodeTypesFound;

              }
            }

            #log "DEBUG: ========== nodeColumnsFound =============";
            #log nodeColumnsFound;
            #log "DEBUG: ========== nodeTypesFound =============";
            #log nodeTypesFound;

            # Look in first row for available annotation columns (node columns must be determined first)
            columnNumber = 0;
            columnType   = "annotation";
            for (var column in tsvData[1].keys) {
              columnNumber++;
              # Node annotations
              if (annotationColumns[column]) {
                if (columnDefs[columnType].[column].type != "hash") {
                  msg = msg + "ERROR: no column definition subhash found for annotation column '" + column + "' (networkType=" + networkType + ") in method 'parseNetworkTsvData'\n";
                } else {
                  var targetNodeTypes = columnDefs[columnType].[column].targetNodeTypes;  # '..' notation fails in Jmol 14.3.13_2015.03.30 if variable name i identical to hash key
                  var assignMode      = columnDefs[columnType].[column].assignMode;  # '..' notation fails in Jmol 14.3.13_2015.03.30 if variable name i identical to hash key
                  if (targetNodeTypes.type == "array") {
                    for (var targetNodeType in targetNodeTypes) {
                      #log "DEBUG:  columnNumber=" + columnNumber + "  col=" + column + "  targetNodeType=" + targetNodeType;
                      if (nodeTypesFound[targetNodeType].type == "hash") {
                        var targetColumnNumber = 0;
                        if (annotationColumnsFound[column].type != "hash") {
                          annotationColumnsFound[column] = [storageType: "string"];
                        }
                        #if (annotationColumnsFound[column].[targetNodeType].type != "hash") {
                        #  annotationColumnsFound[column].[targetNodeType] = {};
                        #}
                        if (columnDefs[columnType].[column]..sourceNodeType != "") {
                          annotationColumnsFound[column]..sourceNodeType = columnDefs[columnType].[column]..sourceNodeType;
                          if (columnDefs[columnType].[column]..storageSourceInfoKeys.type == "array") {
                            annotationColumnsFound[column]..storageSourceInfoKeys = columnDefs[columnType].[column]..storageSourceInfoKeys;
                            annotationColumnsFound[column]..storageType = "hash";
                          }
                        }
                        if (columnDefs[columnType].[column]..targetStorageTypes.type == "hash") {
                          annotationColumnsFound[column]..targetStorageTypes = columnDefs[columnType].[column]..targetStorageTypes;
                        }

                        # Determine targetColumnNumber (nearest possible target column, lower numbers checked first, then larger numbers)
                        var targetColumnCount = nodeTypesFound[targetNodeType]..columnNumbers.size;
                        if (targetColumnCount > 0) {
                          if (targetColumnCount == 1) {
                            targetColumnNumber = nodeTypesFound[targetNodeType]..minColumnNumber;
                          } else {
                            if (columnNumber < nodeTypesFound[targetNodeType]..minColumnNumber) {
                              targetColumnNumber = nodeTypesFound[targetNodeType]..minColumnNumber;
                            } elseif (columnNumber > nodeTypesFound[targetNodeType]..maxColumnNumber) {
                               targetColumnNumber = nodeTypesFound[targetNodeType]..maxColumnNumber;
                            } else {
                              for (var i=1; i<=targetColumnCount; i++) {
                                var currentTargetColumnNumber = nodeTypesFound[targetNodeType]..columnNumbers.[i];
                                if (targetColumnNumber == 0) {
                                  targetColumnNumber = currentTargetColumnNumber;   # lowest available number as start value
                                } else {
                                  if (columnNumber > currentTargetColumnNumber) {
                                    targetColumnNumber = currentTargetColumnNumber;
                                  } else {
                                    targetColumnNumber = [targetColumnNumber, currentTargetColumnNumber].min % 0;    # '% 0' needed to convert result back to integer
                                  }
                                }
                              }
                            }
                          }
                        }
                        if (annotationColumnsFound[column]..targetNodeTypes.type != "hash") {
                          annotationColumnsFound[column]..targetNodeTypes = {};
                        }
                        if (annotationColumnsFound[column]..targetNodeTypes.[targetNodeType].type != "hash") {
                          annotationColumnsFound[column]..targetNodeTypes.[targetNodeType] = {};
                        }
                        annotationColumnsFound[column]..targetNodeTypes.[targetNodeType]..targetColumnNumber = targetColumnNumber;
                        if (annotationColumnsFound[column]..minTargetColumnNumber == "") {
                          annotationColumnsFound[column]..minTargetColumnNumber = targetColumnNumber;
                        } else {
                          #log "DEBUG: col=" + column + "  tcn=" + targetColumnNumber + "  tcnType=" + targetColumnNumber.type + "  oldMin=" + annotationColumnsFound[column]..minTargetColumnNumber + "  oldMinType=" + annotationColumnsFound[column]..minTargetColumnNumber.type;
                          annotationColumnsFound[column]..minTargetColumnNumber = [targetColumnNumber, annotationColumnsFound[column]..minTargetColumnNumber].min % 0;    # '% 0' needed to convert result back to integer
                          #log "DEBUG: col=" + column + "  tcn=" + targetColumnNumber + "  tcnType=" + targetColumnNumber.type + "  newMin=" + annotationColumnsFound[column]..minTargetColumnNumber + "  newMinType=" + annotationColumnsFound[column]..minTargetColumnNumber.type + "\n=============";
                        }
                        if (annotationColumnsFound[column]..maxTargetColumnNumber == "") {
                          annotationColumnsFound[column]..maxTargetColumnNumber = targetColumnNumber;
                        } else {
                          annotationColumnsFound[column]..maxTargetColumnNumber = [targetColumnNumber, annotationColumnsFound[column]..maxTargetColumnNumber].max % 0;    # '% 0' needed to convert result back to integer
                        }
                      }
                    }

                    if (annotationColumnsFound[column]..columnNumberToNodeType.type != "hash") {
                      annotationColumnsFound[column]..columnNumberToNodeType = {};
                    }
                    if (targetNodeTypesFound.size > 0) {   # needed because of bug in Jmol 14.3.13_2015.04.08
                      for (var targetNodeType in targetNodeTypesFound) {
                         var currentTargetColumnNumber = annotationColumnsFound[column]..targetNodeTypes.[targetNodeType]..targetColumnNumber;
                         annotationColumnsFound[column]..columnNumberToNodeType[currentTargetColumnNumber] =  targetNodeType;
                      }
                    }

                    if (assignMode != "all") {
                      var targetNodeTypesFound = annotationColumnsFound[column]..targetNodeTypes.keys;
                      var singleTargetNodeType     = "";
                      var singleTargetColumnNumber = 0;
                      var targetColumnNumbers      = [];

                      if (targetNodeTypesFound.size > 0) {   # needed because of bug in Jmol 14.3.13_2015.04.08
                        for (var targetNodeType in targetNodeTypesFound) {
                           var currentTargetColumnNumber = annotationColumnsFound[column]..targetNodeTypes.[targetNodeType]..targetColumnNumber;
                           targetColumnNumbers.push(currentTargetColumnNumber);
                        }
                      }

                      if (columnNumber < annotationColumnsFound[column]..minTargetColumnNumber) {
                        singleTargetColumnNumber = annotationColumnsFound[column]..minTargetColumnNumber;
                      } elseif (columnNumber > annotationColumnsFound[column]..maxTargetColumnNumber) {
                        singleTargetColumnNumber = annotationColumnsFound[column]..maxTargetColumnNumber;
                      } else {
                        if (targetColumnNumbers.size > 0) {   # needed because of bug in Jmol 14.3.13_2015.04.08
                        for (var currentTargetColumnNumber in targetColumnNumbers.sort) {
                          if (singleTargetColumnNumber == 0) {
                            singleTargetColumnNumber = currentTargetColumnNumber;   # lowest available number as start value
                          } else {
                            if (columnNumber > currentTargetColumnNumber) {
                              singleTargetColumnNumber = currentTargetColumnNumber;
                            } else {
                              singleTargetColumnNumber = [singleTargetColumnNumber, currentTargetColumnNumber].min % 0;    # '% 0' needed to convert result back to integer
                            }
                          }
                        }
                        }
                      }
                      ##singleTargetNodeType = columnNumberToNodeType[singleTargetColumnNumber];
                      annotationColumnsFound[column]..singleTargetColumnNumber = singleTargetColumnNumber;
                      ##annotationColumnsFound[column]..singleTargetNodeType     = singleTargetNodeType;
                    }
                  }
                }
              }

              # Edge annotations
              if (edgeAnnotationColumnsFound[column].type != "hash") {
                edgeAnnotationColumnsFound[column] = [storageType: "string"];
              }
              if (columnDefs[columnType].[column]..sourceNodeType != "") {
                edgeAnnotationColumnsFound[column]..sourceNodeType = columnDefs[columnType].[column]..sourceNodeType;
                if (columnDefs[columnType].[column]..storageSourceInfoKeys.type == "array") {
                  edgeAnnotationColumnsFound[column]..storageSourceInfoKeys = columnDefs[columnType].[column]..storageSourceInfoKeys;
                  edgeAnnotationColumnsFound[column]..storageType = "hash";
                }
              }
              if (columnDefs[columnType].[column]..targetStorageTypes.type == "hash") {
                edgeAnnotationColumnsFound[column]..targetStorageTypes = columnDefs[columnType].[column]..targetStorageTypes;
              }
            }

            # Build combined target column number list for speedup
            if (annotationColumnsFound.size > 0) {   # needed because of bug in Jmol 14.3.13_2015.04.08
              for (var column in annotationColumnsFound.keys) {
                #var infoKey    = columnDefs[columnType].[column]..infoKey;
                #var assignMode = columnDefs[columnType].[column]..assignMode;  # '..' notation fails in Jmol 14.3.13_2015.03.30 if variable name i identical to hash key
                var targetColumnNumbers      = {};
                if (annotationColumnsFound[column]..targetNodeTypes.type == "hash") {
                  var targetNodeTypes = (annotationColumnsFound[column]..targetNodeTypes);
                  if (targetNodeTypes.size > 0) {   # needed because of bug in Jmol 14.3.13_2015.04.08
                    for (var targetNodeType in targetNodeTypes) {
                      if (annotationColumnsFound[column]..targetNodeTypes.[targetNodeType].type == "hash") {
                        if (annotationColumnsFound[column]..targetNodeTypes.[targetNodeType]..targetColumnNumber > 0) {
                          targetColumnNumbers[annotationColumnsFound[column]..targetNodeTypes.[targetNodeType]..targetColumnNumber] = [targetNodeType: targetNodeType];
                        }
                      }
                    }
                  }
                }
                annotationColumnsFound[column]..targetColumnNumbers = targetColumnNumbers;
              }
            }
            if (msg != "") {
              logMsg([level: "mixed", msg: msg]);
              #return;
            }

            #log "DEBUG: ========== nodeColumnsFound ============\n" + nodeColumnsFound;
            #log "DEBUG: ========== annotationColumnsFound ============\n" + annotationColumnsFound;
            #log "DEBUG: ========== nodeTypesFound ============\n" + nodeTypesFound;

            logMsg([level: "info", msg: "     extracting data from " + rowCount + " TSV data rows of file '" + fileName + "' (" + fileNumber + " of " + fileCount + ")..."]);

            # Extract data
            var targetColumnNumberToNodeKey = {};
            var maxRowCount = [rowCount, rowLimit].min;
            for (var rowNumber from [2 maxRowCount]) {
              #logMsg("parsing row=" + rowNumber + " (file " + fileNumber + " of " + fileCount + ")...");

              # Extract nodes first (annotations need nodes)
              var currentNodeKeyHash = {};
              var currentNodeKeys     = [];
              if (nodeColumnsFound.size > 0) {
                columnType = "node";
                for (var column in nodeColumnsFound.keys) {
                  var infoKey = columnDefs[columnType].[column]..infoKey;
                  var nodeId  = tsvData[rowNumber].[column];

                  # Normalize nodeId
                  if (normalizations[infoKey].type == "hash") {
                    if (normalizations[infoKey].[nodeId] != "") {
                      if (normalizations[infoKey].[nodeId].type == "string" ) {
                        nodeId = normalizations[infoKey].[nodeId];
                        #logMsg([level: "info", msg: "normalized '" + infoKey + "' node '" + tsvData[rowNumber].[column] + "' to '" + nodeId + "'"]);
                      } else {
                        nodeId = "";
                        #logMsg([level: "info", msg: "normalized '" + infoKey + "' node '" + tsvData[rowNumber].[column] + "' to '" + nodeId + "'"]);
                      }
                    }
                  }

                  var nodeKey = "" + infoKey + "||" + nodeId;
                  var targetColumnNumber = nodeColumnsFound[column]..columnNumber;

                  if (nodeId != "") {    # no empty IDs allowed
                    targetColumnNumberToNodeKey[targetColumnNumber] = nodeKey;
                    #log "DEBUG:    row=" + rowNumber + "  col=" + column + "  nodeId=" + nodeId + "  nodeKey=" + nodeKey + "  targetColNum=" + targetColumnNumber;
                    if (allNodes..nodeInfo.[nodeKey].type != "hash") {
                      allNodes..nodeInfo.[nodeKey] = {"infoKey": infoKey, "nodeId": nodeId, "nodeKey": nodeKey, "nodeType": columnDefs[columnType].[column]..nodeType, "subTypeInfoKeys": nodeColumnsFound[column]..subTypeInfoKeys};
                      allNodes..nodeInfo.[nodeKey].[infoKey] = nodeId;
                    } else {
                      allNodes..nodeInfo.[nodeKey].[infoKey] = nodeId;
                      allNodes..nodeInfo.[nodeKey]..infoKey  = infoKey;
                      allNodes..nodeInfo.[nodeKey]..nodeId   = nodeId;
                      allNodes..nodeInfo.[nodeKey]..nodeKey  = nodeKey;
                      allNodes..nodeInfo.[nodeKey]..nodeType = columnDefs[columnType].[column]..nodeType;
                      allNodes..nodeInfo.[nodeKey]..subTypeInfoKeys = nodeColumnsFound[column]..subTypeInfoKeys;
                    }
                    if (currentNodeKeyHash.[nodeKey].type != "boolean") {
                      currentNodeKeyHash.[nodeKey] = true;
                      currentNodeKeys.push(nodeKey);
                    } else {
                      logMsg([level: "warn", msg: "nodeKey '" + nodeKey + "' found again in row '" + rowNumber + "' in column '" + column + "'"]);
                      currentNodeKeyHash.[nodeKey] = true;
                      currentNodeKeys.push(nodeKey);
                    }

                    if (nodeColumnsFound[column]..temperatureInfoKey != "") {
                      allNodes..nodeInfo.[nodeKey]..temperatureInfoKey = nodeColumnsFound[column]..temperatureInfoKey;
                      #logMsg("  temperatureInfoKey '" + nodeColumnsFound[column]..temperatureInfoKey + "' found for column '" + column + "'");
                    }
                  } else {
                    #logMsg([level: "warn", msg: "empty nodeId in column '" + column + "' (no. " + targetColumnNumber + ") of row " + rowNumber + " in file '" + fileName + "' - SKIPPED NODE"]);
                  }
                }

                # Extract edges
                var currentNodeKeyCount = currentNodeKeys.size;
                if (currentNodeKeyCount > 1) {
                  var limit1 = currentNodeKeyCount - 1;
                  for (var i from [1 limit1]) {
                    #log "DEBUG: i=" + i + "  c=" + currentNodeKeyCount;
                    var limit2 = i + 1;
                    for (var j from [currentNodeKeyCount limit2]) {
                      #log "DEBUG:   j=" + j;
                      if (i==j) { logMsg([level: "error", msg: " i(" + i + ") = j(" + j + ")"]); }
                      var edgeKey    = "" + currentNodeKeys[i] + "%%" + currentNodeKeys[j];
                      var edgeKeyRev = "" + currentNodeKeys[j] + "%%" + currentNodeKeys[i];
                      if (allNodes..edgeKeysUsed.[edgeKey] == "") {
                        #log "DEBUG:   edgeKey='" + edgeKey + "'";
                        if (edgeType == "undirected") {
                          if (allNodes..edgeKeysUsed.[edgeKeyRev] == "") {
                            var nodeKey1 = currentNodeKeys[i];
                            var nodeKey2 = currentNodeKeys[j];
                            allNodes..edgeKeysUsed.[edgeKey]    = edgeKey;
                            allNodes..edgeKeysUsed.[edgeKeyRev] = edgeKey;
                            allNodes..edgeInfo[edgeKey] = {"nodeKey1": nodeKey1, "nodeKey2": nodeKey2};
                            if (allNodes..neighbours.[nodeKey1].type != "hash") {
                              allNodes..neighbours.[nodeKey1] = {};
                            }
                            allNodes..neighbours.[nodeKey1].[nodeKey2] = true;
                            if (allNodes..neighbours.[nodeKey2].type != "hash") {
                              allNodes..neighbours.[nodeKey2] = {};
                            }
                            allNodes..neighbours.[nodeKey2].[nodeKey1] = true;

                            # Extract edge annotations
                            if (edgeAnnotationColumnsFound.size > 0) {   # needed because of bug in Jmol 14.3.13_2015.04.08
                              for (var annotationColumn in edgeAnnotationColumnsFound.keys) {
                                var value                  = tsvData[rowNumber].[annotationColumn];
                                var infoKey                = columnDefs["annotation"].[annotationColumn]..infoKey;
                                var assignMode             = columnDefs["annotation"].[annotationColumn]..assignMode;
                                allNodes..edgeInfo[edgeKey].[infoKey] = value;
                              }
                            }

                          } else {
                           allNodes..edgeKeysUsed.[edgeKey] = edgeKeyRev;
                          }
                        } else {   # only 'directed' should be available, might need expansion if other edge types are introduced and edge annotations must be processed
                          var nodeKey1 = currentNodeKeys[i];
                          var nodeKey2 = currentNodeKeys[j];
                          allNodes..edgeKeysUsed.[edgeKey]    = edgeKey;
                          allNodes..edgeInfo[edgeKey] = {"nodeKey1": nodeKey1, "nodeKey2": nodeKey2};
                          if (allNodes..neighbours.[nodeKey1].type != "hash") {
                            allNodes..neighbours.[nodeKey1] = {};
                          }
                          allNodes..neighbours.[nodeKey1].[nodeKey2] = true;
                          if (allNodes..neighbours.[nodeKey2].type != "hash") {
                            allNodes..neighbours.[nodeKey2] = {};
                          }
                          allNodes..neighbours.[nodeKey2].[nodeKey1] = true;

                          # Extract edge annotations
                          if (edgeAnnotationColumnsFound.size > 0) {   # needed because of bug in Jmol 14.3.13_2015.04.08
                            for (var annotationColumn in edgeAnnotationColumnsFound.keys) {
                              var value                  = tsvData[rowNumber].[annotationColumn];
                              var infoKey                = columnDefs["annotation"].[annotationColumn]..infoKey;
                              var assignMode             = columnDefs["annotation"].[annotationColumn]..assignMode;
                              allNodes..edgeInfo[edgeKey].[infoKey] = value;
                            }
                          }
                        } 


                      }
                    }
                  }
                }

                # Extract node annotations (nodes must be extracted already)
                if (networkType != "generic") {
                  if (annotationColumnsFound.size > 0) {   # needed because of bug in Jmol 14.3.13_2015.04.08
                    columnType = "annotation";
                    for (var column in annotationColumnsFound.keys) {
                      var value                  = tsvData[rowNumber].[column];
                      var infoKey                = columnDefs[columnType][column]..infoKey;
                      var assignMode             = columnDefs[columnType].[column]..assignMode;
                      var storageType            = annotationColumnsFound.[column]..storageType;
                      var sourceNodeType         = annotationColumnsFound.[column]..sourceNodeType;
                      var storageSourceInfoKeys  = annotationColumnsFound.[column]..storageSourceInfoKeys;
                      var columnNumberToNodeType = annotationColumnsFound.[column]..columnNumberToNodeType;
                      var targetStorageTypes     = annotationColumnsFound.[column]..targetStorageTypes;
                      var targetColumnNumbers    = [];

                      targetColumnNumbers = annotationColumnsFound.[column]..targetColumnNumbers;

                      for (var targetColumnNumber in targetColumnNumbers) {
                        var nodeKey = targetColumnNumberToNodeKey[targetColumnNumber];
                        if (nodeKey != "") {
                          var nodeType = targetColumnNumbers[targetColumnNumber]..targetNodeType;
                          if (storageType == "string") {
                            if (targetStorageTypes[nodeType] == "hash") {
                              #logMsg(" nodeType='" + nodeType + "'  nodeKey='" + nodeKey + "'  infoKey='" + infoKey + "'  storageType='STRING'  targetStorageType='HASH'");
                              if (value == "" and infoKey == "species")  {
                                # ignore empty species names
                              } else {
                                if (allNodes..nodeInfo.[nodeKey].[infoKey].type != "hash") {
                                  allNodes..nodeInfo.[nodeKey].[infoKey] = {};
                                }
                                allNodes..nodeInfo.[nodeKey].[infoKey].[value] = true;
                              }
                            } else {
                              #logMsg(" nodeType='" + nodeType + "'  nodeKey='" + nodeKey + "'  infoKey='" + infoKey + "'  storageType='STRING'  targetStorageType='STRING'");
                              allNodes..nodeInfo.[nodeKey].[infoKey] = value;
                            }
                          } elseif (storageType == "hash") {
                            if (allNodes..nodeInfo.[nodeKey].[infoKey].type != "hash") {
                              allNodes..nodeInfo.[nodeKey].[infoKey] = {};
                            }
                            #logMsg(" nodeType='" + nodeType + "'  nodeKey='" + nodeKey + "'  infoKey='" + infoKey + "'  storageType='HASH'");
                            var sourceNodeKeys = [];
                            if (currentNodeKeyCount > 0) {
                            for (var sourceNodeKey in currentNodeKeys) {
                              if (allNodes..nodeInfo.[sourceNodeKey]..nodeType == sourceNodeType) {
                                 sourceNodeKeys.push(sourceNodeKey);
                              }
                            }
                            }
                            #logMsg("  infoKey=" + infoKey + "  sourceNodeType=" + sourceNodeType + "  sourceNodeKeys=" + sourceNodeKeys.join(","));
                            if (sourceNodeKeys.count > 0) {
                            for (var sourceNodeKey in sourceNodeKeys) {
                              if (allNodes..nodeInfo.[nodeKey].[infoKey].[sourceNodeKey].type != "hash") {
                                allNodes..nodeInfo.[nodeKey].[infoKey].[sourceNodeKey] = {};
                              }
                              allNodes..nodeInfo.[nodeKey].[infoKey].[sourceNodeKey].[infoKey] = value;
                              for (var sourceInfoKey in storageSourceInfoKeys) {
                                allNodes..nodeInfo.[nodeKey].[infoKey].[sourceNodeKey].[sourceInfoKey] = allNodes..nodeInfo.[sourceNodeKey].[sourceInfoKey];
                              }
                            }
                            }
                          }
                        }
                      }
                    }
                  }
                }

              }
            }


            
            if (loadCoordinateMode == "rescale") {
              if (coordinateScalingFactor != 0) {
                logMsg([level: "info", msg: "rescaling coordinates while loading network data with factor '" + coordinateScalingFactor + "'"]);
              } else {
                logMsg([level: "warn", msg: "rescaling coordinates while loading network data failed because scaling factor is zero - coordinates unchanged"]);
              }
            }
            for (var nodeKey IN allNodes..nodeInfo) {
             # Set initial coordinates
             switch(loadCoordinateMode) {
               case "random":
                  allNodes..nodeInfo.[nodeKey]..x = random(0, 10);
                  allNodes..nodeInfo.[nodeKey]..y = random(0, 10);
                  allNodes..nodeInfo.[nodeKey]..z = random(0, 10);
                  break;
               case "rescale":
                 if (coordinateScalingFactor != 0) {
                   #var oldX = allNodes..nodeInfo.[nodeKey]..x;
                   allNodes..nodeInfo.[nodeKey]..x = 1.0 * coordinateScalingFactor * allNodes..nodeInfo.[nodeKey]..x;
                   allNodes..nodeInfo.[nodeKey]..y = 1.0 * coordinateScalingFactor * allNodes..nodeInfo.[nodeKey]..y;
                   allNodes..nodeInfo.[nodeKey]..z = 1.0 * coordinateScalingFactor * allNodes..nodeInfo.[nodeKey]..z;
                   #var newX = allNodes..nodeInfo.[nodeKey]..x;
                   #logMsg([level: "info", msg: "rescaling coordinates while loading network data with factor '" + coordinateScalingFactor + "' (old: " + oldX + " , new: " + newX + ")"]);
   		 }
                 break;
               case "current":
                 # use current values, nothing to do
                 break;
               DEFAULT:
                 allNodes..nodeInfo.[nodeKey]..x = 0;
                 allNodes..nodeInfo.[nodeKey]..y = 0;
                 allNodes..nodeInfo.[nodeKey]..z = 0;
               }                
            }


            logMsg([level: "info", msg: "    finished parsing " + rowCount + " TSV data rows of file '" + fileName + "' (" + fileNumber + " of " + fileCount + ")"]);
          }
          #log "DEBUG:  finished branch 1";
        } else {
          msg = msg + "actual tsvData for file no. " + fileNumber + " is not an array (type=" + tsvData.type + ")\n";
	  logMsg([level: "error", msg: msg]);
        }
          #log "DEBUG:  finished branch 2";
      } else {
        msg = msg + "ERROR: tsvData for file no. " + fileNumber + " is not a hash (type=" + dataHashref..tsvData.[fileNumber].type + ")\n";
        logMsg([level: "info", msg: msg]);
      }
      #log "DEBUG:  finished branch 3";

    }
    var timeMessage = " (time=" + format("%.1f", now(startTime) / 1000) + " sec)";
    logMsg([level: "info", msg: "finished parsing " + fileCount + " TSV files" + timeMessage]);
  }

  # Determine subnetworks and add subnetwork number to node info, determine node numbers (must be sequential within each subnetwork, mmCIF format restriction)
  logMsg("going to determine raw subnetworks");
  determineRawSubnetworks(dataHashref);
  logMsg("finished determining raw subnetworks");

  # Set node properties required for mmCIF format and labels, collect Information for building legend subset and managing genes of interest
  var legendNodeSubTypeIds = {};
  var legendNodeIds = [];
  var lDefs = networkDefs..labelDefinitions;
  var subnetworkNumbersAvailable = false;
  allNodes..ncbiGeneIdToNodeKey = {};
  allNodes..geneKeyToNodeKey    = {};
  if (allNodes..subnetworkInfo.type == "hash") {
    if (allNodes..subnetworkInfo..nodeKeyToSubnetworkNumber.type == "hash") {
      subnetworkNumbersAvailable = true;
    }
  }
  var translationsAvailable = false;
  if (networkDefs..translations.type == "hash") {
    translationsAvailable = true;
  }
  for (var nodeKey in allNodes..nodeInfo) {
    var nodeType        = "default";
    var nodeSubType     = "default";
    var nodeInfo        = allNodes..nodeInfo.[nodeKey];
    var nodeId          = nodeInfo..nodeId;
    var subTypeInfoKeys = [];

    if (nodeInfo..nodeType != "") {
      nodeType = nodeInfo..nodeType;
    }

    if (nodeInfo..subTypeInfoKeys.type == "array") {
      subTypeInfoKeys = nodeInfo..subTypeInfoKeys;
      for (var subTypeInfoKey in subTypeInfoKeys) {
        #log "DEBUG:   stIK=" + subTypeInfoKey;
        if (nodeInfo.[subTypeInfoKey] != "") {
          nodeSubType = nodeInfo.[subTypeInfoKey];
          nodeInfo..subTypeInfoKey = subTypeInfoKey;
          nodeInfo..nodeSubType = nodeSubType;
          #log "DEBUG:   nsT=" + nodeSubType;
          break;
        }
      }
    }

    var speciesData = [];
    if (nodeInfo..species.type == "hash") {
      if (nodeInfo..species.size == 1) {
        speciesData = nodeInfo..species.keys.[1].split(" ");
      }
    } else {
     speciesData = nodeInfo..species.split(" ");
    }
    if (speciesData.size > 1) {
      var firstWord = speciesData[1];
      var firstCharacter = firstWord[1];
      nodeInfo..speciesShortcut = "" + firstCharacter + ". " + speciesData[2];
    } else {
      nodeInfo..speciesShortcut = nodeInfo..species;
    }

    # Build hashes for speeding up genes of interest handling
    if (nodeSubType == "gene") {
      if (nodeType == "ageingFactor") {
	if (nodeInfo..ncbiGeneId > 0) {
	  allNodes..ncbiGeneIdToNodeKey.[nodeInfo..ncbiGeneId] = nodeKey;
	}
	var geneKey = nodeInfo..ageingFactorName + "||" + speciesData.join(" ");
        allNodes..geneKeyToNodeKey.[geneKey] = nodeKey;
      }
    }


    #   set subnetworkNumber (will become '_atom_site.auth_asym_id', 'chain ID' in PDB format)
    if (subnetworkNumbersAvailable) {
      if (allNodes..subnetworkInfo..nodeKeyToSubnetworkNumber.[nodeKey] != "") {
        nodeInfo..subnetworkNumber = allNodes..subnetworkInfo..nodeKeyToSubnetworkNumber.[nodeKey];
      }
    }
    #print "DEBUG: nk=" + nodeKey + "  nT=" + nodeType + "  nsT=" + nodeSubType + "  stIK=" + subTypeInfoKey + "  ta=" + translationsAvailable + "  sna=" + subnetworkNumbersAvailable;

    var nodeTypeId         = "U";
    var nodeSubTypeIdPart1 = "UNK";
    var nodeSubTypeIdPart2 = "UNK";
    var nodeSubTypeId      = "" + nodeSubTypeIdPart1 + "_" +  nodeSubTypeIdPart2;
    if (translationsAvailable) {
      if (networkDefs..translations..typeToSingleLetter.type == "hash") {
        if (networkDefs..translations..typeToSingleLetter.[nodeType] != "") {
          nodeTypeId = networkDefs..translations..typeToSingleLetter.[nodeType];
        }
      } else {
        #log "DEBUG: no networkDefs..translations..typeToSingleLetter subhash";
      }
      if (networkDefs..translations..typeToTypeId.type == "hash") {
        if (networkDefs..translations..typeToTypeId.[nodeType] != "") {
          nodeSubTypeIdPart1 = networkDefs..translations..typeToTypeId.[nodeType];
        }
        if (networkDefs..translations..typeToTypeId.[nodeSubType] != "") {
          nodeSubTypeIdPart2 = networkDefs..translations..typeToTypeId.[nodeSubType];
        }
        nodeSubTypeId = "" + nodeSubTypeIdPart1 + "_" +  nodeSubTypeIdPart2;
      } else {
        #log "DEBUG: no networkDefs..translations..typeToTypeId subhash";
      }
    }

    if (nodeTypeInfo..[nodeType].type != "hash") {
      nodeTypeInfo..[nodeType] = [subTypes: {}];
      nodeTypeInfo..[nodeType]..selectionExpression = "[" + nodeSubTypeIdPart1 + "_*]";
    }
    if (nodeTypeInfo..[nodeType]..subTypes..[nodeSubType].type != "hash") {
      nodeTypeInfo..[nodeType]..subTypes..[nodeSubType] = [nodeSubTypeId: nodeSubTypeId];
      nodeTypeInfo..[nodeType]..subTypes..[nodeSubType]..selectionExpression = "[" + nodeSubTypeId + "]";
    }
    

    #print "DEBUG:   nstID=" + nodeSubTypeId;
    if (legendNodeSubTypeIds..[nodeSubTypeId] == "") {
      legendNodeSubTypeIds..[nodeSubTypeId] = nodeId;
    }
    #   set nodeTypeId (will become '_atomSite.type_symbol, 'element symbol' in PDB format')
    nodeInfo..nodeTypeId = nodeTypeId;
    #   set nodeSubTypeId (will become '_atomSite.auth_comp_id, 'residue name' in PDB format')
    nodeInfo..nodeSubTypeId = nodeSubTypeId;

    defineLabel({"nodeInfo": nodeInfo, "labelDefinitions": lDefs});
    #logMsg("  defined labels - labelShort='" + nodeInfo..labelShort + "'  labelLong='" + nodeInfo..labelLong + "'");
  }
  
  # Add node properties from annotations to edge infos needed for mmCIF format
  for (var edgeKey in allNodes..edgeInfo) {
    var currentEdgeInfo = allNodes..edgeInfo.[edgeKey];
    var nodeKey1 = currentEdgeInfo..nodeKey1;
    var nodeKey2 = currentEdgeInfo..nodeKey2;
    var node1Info = allNodes..nodeInfo.[nodeKey1];
    var node2Info = allNodes..nodeInfo.[nodeKey2];

    currentEdgeInfo..subnetworkNumber  = node1Info..subnetworkNumber;   # should be identical for both nodes

    currentEdgeInfo..nodeTypeId1       = node1Info..nodeTypeId;
    currentEdgeInfo..nodeSubTypeId1    = node1Info..nodeSubTypeId;

    currentEdgeInfo..nodeTypeId2       = node2Info..nodeTypeId;
    currentEdgeInfo..nodeSubTypeId2    = node2Info..nodeSubTypeId;

    #log "========== currentEdgeInfo '" + edgeKey + "' =====================";
    #log currentEdgeInfo;
  }

  allNodes..nodeLegendInfo = [nodeSubTypeIds: legendNodeSubTypeIds];
  allNodes..nodeTypeInfo   = nodeTypeInfo;

  #log "========== NODE INFO start =====================";
  #log allNodes..nodeInfo;
  #log "========== NODE INFO end =====================";

  #log "========== EDGE INFO start =====================";
  #log allNodes..edgeInfo;
  #log "========== EDGE INFO end =====================";

  #log "========== SUBNETWORK INFO start =====================";
  #log allNodes..subnetworkInfo;
  #log "========== SUBNETWORK INFO end =====================";

  #log "========== NODE TYPE INFO start =====================";
  #log allNodes..nodeTypeInfo;
  #log "========== NODE TYPE INFO end =====================";
}

function defineLabels(dataHashref) {    # works on 'raw network data' level
  var msg      = "";

  #logMsg("====== labelDefinitions (defineLabels) ===========");
  #log dataHashref..labelDefinitions;

  if (dataHashref..nodeInfo.type == "hash") {
    if (dataHashref..nodeInfo..nodeId == "") {
      for (var nodeKey IN dataHashref..nodeInfo) {
        if (dataHashref..nodeInfo..[nodeKey].type == "hash") {
          #print "DEBUG: redefining label for nodeKey '" + nodeKey + "'";
          defineLabel([nodeInfo: dataHashref..nodeInfo..[nodeKey], labelDefinitions: dataHashref..labelDefinitions]);
        }
      }
    } else {
      defineLabel(dataHashref);
    }
  } else {
    msg = msg + "ERROR: parameter subhash 'dataHashref..nodeInfo' NOT PROVIDED in call of method 'defineLabels'\n";
  }
}

function defineLabel (dataHashref) {    # works on 'raw network data' level
  var msg      = "";
  var lDefs    = {};
  var nodeInfo = {};
  var nodeId   = "";
  var nodeType = "";

  # Check required parameters
  if (dataHashref.type != "hash") {
    msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED in call of method 'defineLabel'\n";
  } else {
    networkType = dataHashref.networkType;  # '..' notation fails in Jmol 14.3.13_2015.03.30 if variable name is identical to hash key
    if (dataHashref..labelDefinitions.type != "hash") {
      msg = msg + "ERROR: parameter subhash 'dataHashref..labelDefinitions' NOT PROVIDED in call of method 'defineLabel'\n";
    } else {
      lDefs = dataHashref..labelDefinitions;
    }
    if (dataHashref..nodeInfo.type != "hash") {
      msg = msg + "ERROR: parameter subhash 'dataHashref..nodeInfo' NOT PROVIDED in call of method 'defineLabel'\n";
    } else {
      nodeInfo = dataHashref..nodeInfo;
      if (nodeInfo..nodeId == "") {
        msg = msg + "ERROR: property 'nodeInfo..nodeId' NOT FOUND in call of method 'defineLabel'\n";
      } else {
        nodeId = nodeInfo..nodeId;
      }
      if (nodeInfo..nodeType == "") {
        msg = msg + "ERROR: property 'nodeInfo...nodeType' NOT FOUND in call of method 'defineLabel'\n";
      } else {
        nodeType = nodeInfo..nodeType;
      }
    }
  }
  #log "============ dataHashref (defineLabel) ==============";
  #log dataHashref;
  if (msg != "") {
    logMsg([level: "mixed", msg: msg]);
    #log "==== nodeInfo (defineLabel) =================";
    #log nodeInfo;
    return;
  }

  #   set labels
  nodeInfo..labelShort = "" + nodeId;
  nodeInfo..labelLong  = "" + nodeId + " (#" + nodeInfo..nodeNumber + ")";
  if (lDefs[nodeType].type == "hash") {
    var labelTypeKeys = [];
    var labelDef      = {};

    # Check for specific label definition
    var specificInfoKey    = "";
    var specificValue      = "";
    var specificLabelMatch = false;
    if (lDefs[nodeType]..infoKeySpecific.type == "hash") {
      specificInfoKey = lDefs[nodeType]..infoKeySpecific..infoKey;
      if (specificInfoKey != "") {
        if (nodeInfo.[specificInfoKey] != "") {
          specificValue = nodeInfo.[specificInfoKey];
          if (lDefs[nodeType]..infoKeySpecific..infoKeyValues.type == "hash") {
            if (lDefs[nodeType]..infoKeySpecific..infoKeyValues.[specificValue].type == "hash") {
              specificLabelMatch = true;
            }
          }
        }
      }
    }

    if (specificLabelMatch) {
      labelTypeKeys = lDefs[nodeType]..infoKeySpecific..infoKeyValues.[specificValue].keys;
      labelDef      = lDefs[nodeType]..infoKeySpecific..infoKeyValues.[specificValue];
    } elseif (lDefs[nodeType]..default.type == "hash") {
      labelTypeKeys = lDefs[nodeType]..default.keys;
      labelDef      = lDefs[nodeType]..default;
    } else {
      #logMsg("ERROR: no default label definition found for nodeId '" + nodeId + "' with nodeType '" + nodeType + "' in method 'setLabel'");
    }

    #logMsg("===== labelTypeKeys =======");
    #log labelTypeKeys;
    #logMsg("===== labelDef =======");
    #log labelDef;

    for (var labelType in labelTypeKeys) {
      #logMsg("building label of type '" + labelType + "'");
      if (labelDef[labelType].type == "array") {
        if (labelDef[labelType].size > 0) {
          var currentLabel = "";
          for (var i from [1 labelDef[labelType].size]) {
            var partInfo = labelDef[labelType].[i];
            #logMsg("  building label part '" + i + "' for nodeType=" + nodeType + " labelType=" + labelType);
            #log script("show partInfo");
            if (partInfo..value != "") {
              currentLabel = currentLabel + partInfo..value;
              #logMsg("    added value='" + partInfo..value + "' - currentLabel='" + currentLabel + "'");
            } elseif (partInfo..infoKey != "") {
              var infoKey      = partInfo..infoKey;
              var setCase      = partInfo..setCase;
              var formatString = partInfo..format;
              if (nodeInfo[infoKey].type == "hash") {
                if (partInfo..subDefinition.type == "array") {
                  var subLabelData = [];
                  var separator    = "";
                  if (partInfo..separator != "") {
                    separator = partInfo..separator;
                  }
                  if (nodeInfo[infoKey].size > 0) {
                    for (var subKey in nodeInfo[infoKey]) {
                      if (nodeInfo[infoKey].[subKey].type == "hash") {
                        var subNodeInfo = nodeInfo[infoKey].[subKey];
                        var subLabel    = "";
                        for (var j from [1 partInfo..subDefinition.size]) {
                          var subPartInfo = partInfo..subDefinition.[j];
			  var subInfoKey      = subPartInfo..infoKey;
			  var subSetCase      = subPartInfo..setCase;
			  var subFormatString = subPartInfo..format;
                          if (subPartInfo..value != "") {
			    var subPartValue = "" + subPartInfo..value;   # make sure it is a string
                            if (subSetCase != "") {
                              #logMsg("   subSetCase=" + subSetCase + "  subPartValue=" + subPartValue);
                              subPartValue = changeCase(subPartValue, subSetCase);
                            }
                            if (subFormatString != "") {
                              subPartValue = format(subFormatString, subPartValue);
                              if (subFormatString[0] == "%") {
                                subPartValue = "" + subPartValue + "%";
                                if (subPartValue == "%") {
                                  subPartValue = "n/a";
                                }
                              }
                              subPartValue = subPartValue.replace("+-","-");
                            }
                            subLabel = subLabel + subPartValue;
                            #logMsg("   nodeId=" + nodeInfo..nodeId + "  subPartValue=" + subPartValue + "  subFormatString[0]=" + subFormatString[0]);
                          } elseif (subPartInfo..infoKey != "") {
                            var subInfoKey = subPartInfo..infoKey;
                            if (subNodeInfo[subInfoKey] != "") {
                              subLabel = subLabel + subNodeInfo[subInfoKey];
                            }
                          }
                        }
                        if (subLabel != "") {
                          subLabelData.push(subLabel);
                        }
                      }
                    }
                  }
                  if (subLabelData.size > 0) {
                    currentLabel = currentLabel + subLabelData.join(separator);
                  }
                } elseif (partInfo..subDefinition == "") {
                  currentLabel = currentLabel + nodeInfo[infoKey].keys.sort.join(" || ");
                }
              } elseif (nodeInfo[infoKey] != "") {
                var partValue = "" + nodeInfo[infoKey];   # make sure it is a string
                if (setCase != "") {
                  #logMsg("   setCase=" + setCase);
                  partValue = changeCase(partValue, setCase);
                }
                if (formatString != "") {
                  partValue = format(formatString, partValue);
                  if (formatString[0] == "%") {
                    partValue = "" + partValue + "%";
                    if (partValue == "%") {
                      partValue = "n/a";
                    }
                  }
                  partValue = partValue.replace("+-","-");
                  if (partValue == "") {
                    partValue = "n/a";
                  }

                }
                currentLabel = currentLabel + partValue;
                #logMsg("   partValue=" + partValue + "  formatString[0]=" + formatString[0]);
              }
            }
          }

          if (currentLabel == "") {
            currentLabel = "n/a";
          }

          if (labelType == "short") {
            nodeInfo..labelShort = currentLabel;
          } elseif (labelType == "long") {
            nodeInfo..labelLong = currentLabel;
          } elseif (labelType == "custom") {
            nodeInfo..labelCustom = currentLabel;
          }
          logMsg("    final " + labelType + " label='" + currentLabel + "'");
        }
      }
    }
  }

}

function setLabel(dataHashref) {   # works on 'molecular' level
  var msg      = "";
  var nodeInfo = {};
  var knownActions = {"show": true, "hide": true};
  var action   = "show";      # available actions: 'show', 'hide'
  var labelType = "short";    # available types: 'short', 'long', 'custom'
  var labelProperty = "labelShort";
  var hoverLabelProperty = "labelLong";

  # Check required parameters
  if (dataHashref.type != "hash") {
    if (dataHashref.type != "bitset") {
      msg = msg + "parameter 'dataHashref' NOT PROVIDED in call of method 'setLabel'\n";
    } else {
      nodeInfo = getNodeInfo(dataHashref);
    }
  } else {
    if (dataHashref..labelType != "") {
      labelType = dataHashref..labelType;
    }
    if (dataHashref..hoverLabelProperty != "") {
      hoverLabelProperty = dataHashref..hoverLabelProperty;
    }
    if (dataHashref..action != "") {
      action = dataHashref..action;
    }
    if (dataHashref..nodeInfo != "") {
      nodeInfo = dataHashref..nodeInfo;
    } else {
      nodeInfo = getNodeInfo({selected});
    }
  }

  switch(labelType) {
    case "short":
      labelProperty = "labelShort";
      break;
    case "long":
      labelProperty = "labelLong";
      break;
    case "custom":
      labelProperty = "label";
      break;
    default:
      msg = msg + "unknown labelType '" + labelType + "' PROVIDED in call of method 'setLabel'\n";
      break;
  }

  if (knownActions[action] == "") {
    msg = msg + "unknown action '" + action + "' PROVIDED in call of method 'setLabel'\n";
  }


  #log "============ dataHashref (setLabel) ==============";
  #log dataHashref;
  #log "============ nodeInfo (setLabel) ==============";
  #log nodeInfo;

  if (msg != "") {
    logMsg([level: "error", msg: msg]);
    return;
  }

#  #   set labels
#  var nodeCount = nodeInfo.size;
#  if (nodeCount > 0) {
#    var currentSelection = {selected};
#    var labelledNodes    = {none};
#    var labels           = [];
#    var nodeKeys = nodeInfo.keys;
#    for (var i FROM [1 nodeCount]) {
#      nodeInfo[nodeKeys[i]] = {};
#    }

##    labelledNodes.label = labels;
#    select @labelledNodes;
#        switch(action) {
#          case "display":
#            label display;
#            break;
#          case "hide":
#            label hide;
#            break;
#        }
#    select @currentSelection;
#  }


  #   set labels
  var nodeCount = nodeInfo.size;
  if (nodeCount > 0) {
    var nodeKeys = nodeInfo.keys;
    var currentSelection = {selected};

    for (var i FROM [1 nodeCount]) {
      var nodeKey = nodeKeys[i];
      var currentNodeInfo   = nodeInfo[nodeKey];
      #show currentNodeInfo;
      if (currentNodeInfo.type == "hash") {
        var currentNodeNumber = currentNodeInfo..nodeNumber;
        var currentLabel      = currentNodeInfo[labelProperty];
        var currentHoverLabel = currentNodeInfo[hoverLabelProperty];
        if (currentLabel == "") {
          currentLabel = "N/A";
        }

        #print "DEBUG: nodeKey=" + nodeKey + " fileNumber=" + _currentFileNumber + "  nodeNumber=" + currentNodeNumber + "  label='" + currentLabel +"'  hover='" + currentHoverLabel + "'";
        select file=_currentFileNumber and atomno=@currentNodeNumber;
        label @currentLabel;
        set hoverLabel currentHoverLabel;
        #var dummy = script('set hoverLabel "' +  currentHoverLabel + '"');
        switch(action) {
          case "display":
            set label display;
            break;
          case "hide":
            set label hide;
            break;
        }
      }
    }

    select @currentSelection;
  }


}

function changeCase(inputString, mode) {
  var workingString = "" + inputString;  # make sure it is a string
  var outputString  = inputString;
  var stringSize    = workingString.size;

  if (mode == "") {
    mode = "capitalize";
  }

  if (stringSize > 0) {
    switch(mode) {
      case "upper":
        outputString = workingString % 9999;  # convert to upper case
        break;
      case "lower":
        outputString = workingString % -9999;  # convert to lower case
        break;
      case "capitalize":
        if (stringSize == 1) {
          outputString = workingString % 9999;  # convert to upper case
        } else {
          var firstLetter = workingString[1] % 9999;
          var tail        = workingString[2][stringSize];
          outputString    = "" + firstLetter + tail;
        }
        break;
      case "capitalizeStrict":
        if (stringSize == 1) {
          outputString = workingString % 9999;  # convert to upper case
        } else {
          var firstLetter = workingString[1] % 9999;
          var tail        = workingString[2][stringSize];
          outputString    = "" + firstLetter + (tail % -9999);
        }
        break;
    }
  }

  return outputString;
}

function determineRawSubnetworks(dataHashref) {   # works with raw network data (before 'molecular' import)
  var msg    = "";
  var subset = {};
  var subsetKey = "";

  logMsg("  started determining raw subnetworks...");

  # Check required parameters
  if (dataHashref.type != "hash") {
    msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED in call of method 'determineRawSubnetworks'\n";
  } else {
    if (dataHashref..subsets.type != "hash") {
      msg = msg + "ERROR: subhash 'dataHashref..subsets' NOT PROVIDED in call of method 'determineRawSubnetworks'\n";
    } else {
      if (dataHashref..currentSubsetKey == "") {
        dataHashref..currentSubsetKey = "full";
      }
      subsetKey = dataHashref..currentSubsetKey;
      if (dataHashref..subsets.[subsetKey].type != "hash") {
        msg = msg + "ERROR: no subset subhash found for subset '" + subsetKey + "' in call of method 'determineRawSubnetworks'\n";
      } else {
        subset = dataHashref..subsets.[subsetKey];
        if (subset..nodeInfo.type != "hash") {
          msg = msg + "WARNING: no 'nodeInfo' subhash provided for subset '" + subsetKey + "' in call of method 'determineRawSubnetworks' - SKIPED RAW SUBNETWORK DETERMINATION\n";
        }
        if (subset..edgeInfo.type != "hash") {
          msg = msg + "WARNING: no 'edgeInfo' subhash provided for subset '" + subsetKey + "' in call of method 'determineRawSubnetworks' - SKIPED RAW SUBNETWORK DETERMINATION\n";
        }
      }
    }
  }
  if (msg != "") {
    logMsg([level: "mixed", msg: msg]);
    return;
  } else {
   logMsg("    parameters ok - edgeCount=" + subset..edgeInfo.keys.size + "  nodeCount=" + subset..nodeInfo.keys.size);
  }

  var subnetworkNumber          = 0;
  var newSubnetworkNumber       = 0;
  var recycledSubnetworkNumber  = 0;
  var currentSubnetworkNumber   = 0;
  var subnetworks               = {};
  var nodeKeyToSubnetworkNumber = {};
  var recycledSubnetworkNumbers = {};
  var nodesWithEdges            = {};

  if (subset..nodeInfo.keys.size > 0) {
    if (subset..edgeInfo.keys.size > 0) {
      for (var edgeKey in subset..edgeInfo.keys.sort) {
        var nodeKey1 = subset..edgeInfo.[edgeKey].nodeKey1;
        var nodeKey2 = subset..edgeInfo.[edgeKey].nodeKey2;
        nodesWithEdges[nodeKey1] = true;
        nodesWithEdges[nodeKey2] = true;
        var subnetworkNumberNode1 = nodeKeyToSubnetworkNumber[nodeKey1];
        var subnetworkNumberNode2 = nodeKeyToSubnetworkNumber[nodeKey2];
        if (subnetworkNumberNode1 > 0) {
          if (nodeKeyToSubnetworkNumber[nodeKey2] > 0) {
            if (subnetworkNumberNode1 < subnetworkNumberNode2) {
              subnetworkNumber = subnetworkNumberNode1;
              recycledSubnetworkNumber = subnetworkNumberNode2;       
              nodeKeyToSubnetworkNumber[nodeKey2] = subnetworkNumber;
              if (subnetworks[recycledSubnetworkNumber].type == "array") {
                if (subnetworks[recycledSubnetworkNumber].size > 0) {
                  for (var nodeKey in subnetworks[recycledSubnetworkNumber]) {
                    nodeKeyToSubnetworkNumber[nodeKey] = subnetworkNumber;
                  }
                }
              } else {
                logMsg([level: "error", msg: "subnetwork subarray not found for recycled subnetwork number '" + recycledSubnetworkNumber + "' (type=" + subnetworks[recycledSubnetworkNumber].type + ", nodeKey1=" + nodeKey1 + ", nodeKey2=" + nodeKey2 + ") in call of method 'determineRawSubnetworks'\n"]);
                #print "ERROR: subnetwork subarray not found for recycled subnetwork number '" + recycledSubnetworkNumber + "' (type=" + subnetworks[recycledSubnetworkNumber].type + ", nodeKey1=" + nodeKey1 + ", nodeKey2=" + nodeKey2 + ") in call of method 'determineRawSubnetworks'\n";
                #x = subnetworks[recycledSubnetworkNumber]; show x;
                #log "======= Subnetworks[" + subnetworkNumber + "] start ===============";
                #log subnetworks[subnetworkNumber];
                #log "======= Subnetworks[" + subnetworkNumber + "] end ===============";
                #log "======= Subnetworks[" + recycledSubnetworkNumber + "] start ===============";
                #log subnetworks[recycledSubnetworkNumber];
                #log "======= Subnetworks[" + recycledSubnetworkNumber + "] end ===============";
              }
              #log "DEBUG: merging subnetworks '" + subnetworkNumber + "' and '" + recycledSubnetworkNumber + "' (nodeKey1=" + nodeKey1 + ", nodeKey2=" + nodeKey2 + ")";
              #log subnetworks[subnetworkNumber];
              #log "DEBUG: ==================";
              #log subnetworks[recycledSubnetworkNumber];
              #log "DEBUG: ==================";
              if (subnetworks[subnetworkNumber].type == "array") {
               subnetworks[subnetworkNumber] = subnetworks[subnetworkNumber] + subnetworks[recycledSubnetworkNumber];
               subnetworks.pop(recycledSubnetworkNumber);
              } else {
                logMsg([level: "error", msg: "subnetwork subarray not found for subnetwork number '" + subnetworkNumber + "' (type=" + subnetworks[subnetworkNumber].type + ", nodeKey1=" + nodeKey1 + ", nodeKey2=" + nodeKey2 + ") in call of method 'determineRawSubnetworks'\n"]);
                #print "ERROR: subnetwork subarray not found for subnetwork number '" + subnetworkNumber + "' (type=" + subnetworks[subnetworkNumber].type + ", nodeKey1=" + nodeKey1 + ", nodeKey2=" + nodeKey2 + ") in call of method 'determineRawSubnetworks'\n";
                #x = subnetworks[subnetworkNumber]; show x;
                #log "======= Subnetworks[" + subnetworkNumber + "] start ===============";
                #log subnetworks[subnetworkNumber];
                #log "======= Subnetworks[" + subnetworkNumber + "] end ===============";
                #log "======= Subnetworks[" + recycledSubnetworkNumber + "] start ===============";
                #log subnetworks[recycledSubnetworkNumber];
                #log "======= Subnetworks[" + recycledSubnetworkNumber + "] end ===============";
              }
            } elseif (subnetworkNumberNode1 > subnetworkNumberNode2) {
              subnetworkNumber = subnetworkNumberNode2;
              recycledSubnetworkNumber = subnetworkNumberNode1;       
              nodeKeyToSubnetworkNumber[nodeKey1] = subnetworkNumber;
              if (subnetworks[subnetworkNumber].size > 0) {
                for (var nodeKey in subnetworks[subnetworkNumberNode1]) {
                  nodeKeyToSubnetworkNumber[nodeKey] = subnetworkNumber;
                }
              }
              #log "DEBUG: merging subnetworks '" + subnetworkNumber + "' and '" + recycledSubnetworkNumber + "' (nodeKey1=" + nodeKey1 + ", nodeKey2=" + nodeKey2 + ")";
              #log subnetworks[subnetworkNumber];
              #log "DEBUG: ==================";
              #log subnetworks[recycledSubnetworkNumber];
              #log "DEBUG: ==================";

              subnetworks[subnetworkNumber] = subnetworks[subnetworkNumber] + subnetworks[recycledSubnetworkNumber];
              subnetworks.pop(recycledSubnetworkNumber);
            }
          } else {
            subnetworkNumber = nodeKeyToSubnetworkNumber[nodeKey1];
            nodeKeyToSubnetworkNumber[nodeKey2] = subnetworkNumber;
            subnetworks[subnetworkNumber].push(nodeKey2);
          }
        } elseif (subnetworkNumberNode2 > 0) {
          subnetworkNumber = nodeKeyToSubnetworkNumber[nodeKey2];
          nodeKeyToSubnetworkNumber[nodeKey1] = subnetworkNumber;
          subnetworks[subnetworkNumber].push(nodeKey1);
        } else {
          if (recycledSubnetworkNumbers.size > 0) {
            subnetworkNumber = recycledSubnetworkNumbers.keys.min;
            recycledSubnetworkNumbers.pop(subnetworkNumber);
          } else {
            newSubnetworkNumber++;
            subnetworkNumber = newSubnetworkNumber;
          }
          nodeKeyToSubnetworkNumber[nodeKey1] = subnetworkNumber;
          nodeKeyToSubnetworkNumber[nodeKey2] = subnetworkNumber;
          subnetworks[subnetworkNumber] = [nodeKey1, nodeKey2];
        }
      }
    }

    # Add nodes without edges
    var checkCount   = 0;
    var noEdgesCount = 0;
    for (var nodeKey in subset..nodeInfo.keys.sort) {
      checkCount++;
      if (nodesWithEdges[nodeKey] == "") {
        noEdgesCount++;
        if (recycledSubnetworkNumbers.size > 0) {
          subnetworkNumber = recycledSubnetworkNumbers.keys.min;
          recycledSubnetworkNumbers.pop(subnetworkNumber);
          #print "DEBUG: recycled subnetworkNumber " + subnetworkNumber + " for node '" + nodeKey + "'";
        } else {
          newSubnetworkNumber++;
          subnetworkNumber = newSubnetworkNumber;
          #print "DEBUG: used new subnetworkNumber " + subnetworkNumber + " for node '" + nodeKey + "'";
        }
        nodeKeyToSubnetworkNumber[nodeKey] = subnetworkNumber;
        subnetworks[subnetworkNumber] = [nodeKey];
      }
    }
  }

  logMsg([level: "info", msg: "   " + subnetworks.size + " subnetworks found (" + noEdgesCount + " singletons)"]);

  # Determine 'nodeNumber' (must be sequential within each subnetwork and also overall, mmCIF format restriction)
  subset..nodeNumberToNodeKey = {};   # initialize nodeNumber to nodeKey translation subhash (needed for example for writing nodes sequentially to mmCIF format)
  #subset..nodeKeyToNodeNumber = {};   # initialize nodeKey to nodeNumber translation subhash (needed for example for 'cubic (heatMap)' layout)
  var numberToKey = subset..nodeNumberToNodeKey;
  #var keyToNumber = subset..nodeKeyToNodeNumber;
  var nodeNumber = 0;
  if (subnetworks.size > 0) {
    var subnetworkNumbers = subnetworks.keys;
    var maxSubnetworkNumber = subnetworkNumbers.max;     # maximum must be determined separately (after '.keys', '.keys.max' does not work in Jmol 14.4.1)
    for (var subnetworkNumber from [1 maxSubnetworkNumber]) {
      var subnetwork =  subnetworks[subnetworkNumber];
      if (subnetwork.type == "array") {
        for (var nodeKey in subnetwork) {
          nodeNumber++;
          numberToKey[nodeNumber] = nodeKey;
          #keyToNumber[nodeKey] = nodeNumber;
          if (subset..nodeInfo.[nodeKey].type == "hash") {
            subset..nodeInfo.[nodeKey]..nodeNumber = nodeNumber;
          } else {
            logMsg([level: "warn", msg: " nodeKey '" + nodeKey + "' not found in 'nodeInfo' subhash provided for subset '" + subsetKey + "' in call of method 'determineRawSubnetworks'\n"]);
          }
        }
      } else {
        #log "WARNING:  subnetwork '" + subnetworkNumber + "' not found in 'subnetworks' subhash provided for subset '" + subsetKey + "' in call of method 'determineRawSubnetworks'\n";
      }
    }
  }
  subset..maxNodeNumber = nodeNumber;
  #subset..maxNodeNumber = nodeKeyToSubnetworkNumber.keys.size;
  #logMsg([level: "info", msg: "maxNodeNumber=" + subset..maxNodeNumber]);

  # Add 'edgeNumber', 'nodeNumber1' and 'nodeNumber2' to 'edgeInfo' subhash
  subset..edgeNumberToEdgeKey = {};   # initialize nodeNumber to nodeKey translation subhash (needed for example for writing nodes sequentially to mmCIF format)
  var numberToKey = subset..edgeNumberToEdgeKey;
  var edgeNumber = 0;
  if (subset..edgeInfo.size > 0) {
    for (var edgeKey in subset..edgeInfo.keys) {
      edgeNumber++;
      numberToKey[edgeNumber] = edgeKey;
      var nodeKey1 = subset..edgeInfo.[edgeKey]..nodeKey1;
      var nodeKey2 = subset..edgeInfo.[edgeKey]..nodeKey2;
      subset..edgeInfo.[edgeKey].edgeNumber = edgeNumber;
      subset..edgeInfo.[edgeKey].nodeNumber1 = subset..nodeInfo[nodeKey1]..nodeNumber;
      subset..edgeInfo.[edgeKey].nodeNumber2 = subset..nodeInfo[nodeKey2]..nodeNumber;
    }
  }
  subset..maxEdgeNumber = edgeNumber;

  # Add 'subnetworkInfo' to subset
  subset..subnetworkInfo = {"nodeKeyToSubnetworkNumber": nodeKeyToSubnetworkNumber, "subnetworks": subnetworks};
}

function getNodeInfo(dataHashref) {   # parameter: either 'nodeNumber'/'nodeId'/bitset of current subset or a parameter hash
  var msg                 = "";
  var currentNetworkData  = {};
  var subsetKey           = "";
  var subset              = {};
  var nodeNumber          = 0;
  var nodeInfo            = {};
  var nodeNumberToNodeKey = {};
  var nodeKey             = "";
  var nodeId              = "";
  var nodeNumber          = "";
  var selectInfoKey       = "";
  var selectValue         = "";
  var selectFilter        = "";
  var nodeNumbers         = [];
  var nodeKeys            = [];
  var nodeIds             = [];
  var infoKeys            = [];
  var outputType          = "multiple";
  var outputFormat        = "hash";

  # Check required parameters
  if (dataHashref.type != "hash") {
    if (dataHashref == "") {
      msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED in call of method 'determineRawSubnetworks'\n";
    } elseif (dataHashref.type == "array") {
      var numberTest = dataHashref[1];
      if (numberTest.type == "integer") {
        nodeNumbers = dataHashref;
      } elseif (numberTest.type == "string") {
        nodeIds = dataHashref;
      }
      if (networkData.type == "hash") {
        currentNetworkData = networkData;
      }
      if (currentNetworkData..currentSubsetKey != "") {
        subsetKey = currentNetworkData..currentSubsetKey;
      } else {
        subsetKey = "full";
      }
      if (currentNetworkData..subsets.[subsetKey].type == "hash") {
        subset = currentNetworkData..subsets.[subsetKey];
      }
      if (subset..nodeNumberToNodeKey.type == "hash") {
        nodeNumberToNodeKey = subset..nodeNumberToNodeKey;
      }
    } elseif (dataHashref.type == "bitset") {
      nodeNumbers = dataHashref.atomno.all;
      if (networkData.type == "hash") {
        currentNetworkData = networkData;
      }
      if (currentNetworkData..currentSubsetKey != "") {
        subsetKey = currentNetworkData..currentSubsetKey;
      } else {
        subsetKey = "full";
      }
      if (currentNetworkData..subsets.[subsetKey].type == "hash") {
        subset = currentNetworkData..subsets.[subsetKey];
      }
      if (subset..nodeNumberToNodeKey.type == "hash") {
        nodeNumberToNodeKey = subset..nodeNumberToNodeKey;
      }
    } else {
      if (dataHashref.type == "integer") {
        nodeNumber = dataHashref;
        outputType = "single";
      } else {
        nodeId = dataHashref;
        outputType = "single";
      }
      if (networkData.type == "hash") {
        currentNetworkData = networkData;
      }
      if (currentNetworkData..currentSubsetKey != "") {
        subsetKey = currentNetworkData..currentSubsetKey;
      } else {
        subsetKey = "full";
      }
      if (currentNetworkData..subsets.[subsetKey].type == "hash") {
        subset = currentNetworkData..subsets.[subsetKey];
      }
      if (subset..nodeNumberToNodeKey.type == "hash") {
        nodeNumberToNodeKey = subset..nodeNumberToNodeKey;
      }
    }
  } else {
    if (dataHashref..networkData.type == "hash") {
      currentNetworkData = dataHashref..networkData;
    } else {
      if (networkData.type == "hash") {
        currentNetworkData = networkData;
      }
    }
    if (dataHashref..outputFormat != "") {
      outputFormat = dataHashref..outputFormat;
    }
    if (dataHashref..currentSubsetKey == "") {
      if (currentNetworkData..currentSubsetKey == "") {
        subsetKey = "full";
      } else {
        subsetKey = currentNetworkData..currentSubsetKey;
      }
    } else {
      subsetKey = dataHashref..currentSubsetKey;
    }
    if (currentNetworkData..subsets.[subsetKey].type != "hash") {
      msg = msg + "ERROR: no subset subhash found for subset '" + subsetKey + "' in call of method 'getNodeInfo'\n";
    } else {
      subset = currentNetworkData..subsets.[subsetKey];
    }
    if (subset..nodeNumberToNodeKey.type == "hash") {
      nodeNumberToNodeKey = subset..nodeNumberToNodeKey;
    }
    if (dataHashref..nodeKey != "") {
      nodeKey = dataHashref..nodeKey;
      outputType = "single";
    }
    if (dataHashref..nodeId != "") {
      nodeId = dataHashref..nodeId;
      outputType = "single";
    }
    if (dataHashref..nodeNumber > 0) {
      nodeNumber = dataHashref..nodeNumber;
      outputType = "single";
    }
    if (dataHashref..selectInfoKey != "") {
      selectInfoKey = dataHashref..selectInfoKey;
      selectValue   = dataHashref..selectValue;
      selectValues  = dataHashref..selectValues;
    }
    if (dataHashref..selectFilter != "") {
      selectFilter = dataHashref..selectFilter;
    }

    if (dataHashref..nodeNumbers.type == "array") {
      nodeNumbers = dataHashref..nodeNumbers;
    }
    if (dataHashref..nodeKeys.type == "array") {
      nodeKeys = dataHashref..nodeKeys;
    }
    if (dataHashref..nodeIds.type == "array") {
      nodeIds = dataHashref..nodeIds;
    }
    if (dataHashref..nodeBitset.type == "bitset") {
      logMsg("  getting nodeNumbers from bitset...");
      nodeNumbers = dataHashref..nodeBitset.atomno.all;
      logMsg("    nodeNumbers.size=" + nodeNumbers.size + "  type=" + nodeNumbers.type);
      if (networkData.type == "hash") {
        currentNetworkData = networkData;
      }
      if (subsetkey == "") {
        if (currentNetworkData..currentSubsetKey != "") {
          subsetKey = currentNetworkData..currentSubsetKey;
        } else {
          subsetKey = "full";
        }
      }
      if (currentNetworkData..subsets.[subsetKey].type == "hash") {
        subset = currentNetworkData..subsets.[subsetKey];
      }
      if (subset..nodeNumberToNodeKey.type == "hash") {
        nodeNumberToNodeKey = subset..nodeNumberToNodeKey;
      }
    }

    if (dataHashref..infoKeys.type == "array") {
      infoKeys = dataHashref..infoKeys;
    }

    if (dataHashref..outputType != "") {
      outputType = dataHashref..outputType;
    }

  }
  if (subset..nodeInfo.type != "hash") {
    msg = msg + "WARNING: no 'nodeInfo' subhash provided for subset '" + subsetKey + "' in call of method 'getNodeInfo'\n";
  }
  if (msg != "") {
    logMsg([level: "mixed", msg: msg]);
    return;
  }

  #logMsg([level: "info", msg: "parameters ok in call of method 'getNodeInfo' - nodeNumber='" + nodeNumber + "'  nodeId='" + nodeId + "'  nodeKey='" + nodeKey + "'  subsetKey='" + subsetKey + "'"]);

  if (nodeNumber > 0) {
    logMsg([level: "debug2", msg: "  entering branch 'nodeNumber'..."]);
    var currentNodeKey = nodeNumberToNodeKey[nodeNumber];
    if (subset..nodeInfo.[currentNodeKey].type == "hash") {
      nodeInfo = subset..nodeInfo.[currentNodeKey];
    }
  } elseif (nodeKey != "") {
    logMsg([level: "debug2", msg: "  entering branch 'nodeKey'..."]);
    if (subset..nodeInfo.[nodeKey].type == "hash") {
      nodeInfo = subset..nodeInfo.[nodeKey];
    }
  } elseif (nodeId != "") {
    logMsg([level: "debug2", msg: "  entering branch 'nodeId'..."]);
    var filter = "** WHERE nodeId like '" + nodeId + "'";
    if (isNumeric(nodeId)) {
      filter = "** WHERE nodeId='" + nodeId + "'";
    } 
    var currentNodeInfos = subset..nodeInfo.select(filter);    # IMPORTANT: '@' makes a deep copy
    #logMsg("  === currentNodeInfos =====");
    #log currentNodeInfos;
    if (currentNodeInfos.type == "hash") {
      var currentNodeKeys  = currentNodeInfos.keys;
      if (currentNodeKeys.size > 0) {
        var currentNodeKey = currentNodeKeys[1];
        nodeInfo = currentNodeInfos[currentNodeKey];
      }
    }
  } elseif (selectInfoKey != "") {
    logMsg([level: "debug2", msg: "  entering branch 'selectInfoKey' (valueType=" + selectValues.type + ")..."]);
    if (selectValues.type == "array") {
      for (var currentValue IN selectValues) {
        var nodeFilter = "** WHERE " + selectInfoKey + " like '" + currentValue + "'";
        if (isNumeric(currentValue)) {
          nodeFilter = "** WHERE " + selectInfoKey + "='" + currentValue + "'";
        } 
	var currentNodeInfos = subset..nodeInfo.select(nodeFilter);    # IMPORTANT: '@' makes a deep copy
	if (currentNodeInfos.type == "hash") {
	  var currentNodeKeys  = currentNodeInfos.keys;
	  if (currentNodeKeys.size > 0) {
	    var currentNodeKey = currentNodeKeys[1];      # WHY ONLY THE FIRST ????
	    nodeInfo[currentNodeKey] = currentNodeInfos[currentNodeKey];
	  }
	}
      }
    } else {
      var nodeFilter = "** WHERE " + selectInfoKey + " like '" + selectValue + "'";
      if (isNumeric(selectValue)) {
        nodeFilter = "** WHERE " + selectInfoKey + "='" + selectValue + "'";
      } 
      #var fullNodeInfo = subset..nodeInfo;
      nodeInfo = subset..nodeInfo.select(nodeFilter);
      #logMsg("==== first nodeInfo ============");
      #log nodeInfo;
    }
  } elseif (selectFilter != "") {
    logMsg([level: "debug2", msg: "  entering branch 'selectFilter' (filter=" + selectFilter + ")..."]);
    var filter = "** WHERE " + selectFilter;
    nodeInfo = subset..nodeInfo.select(filter);
  } elseif (nodeNumbers.type == "array") {
    logMsg([level: "debug2", msg: "  entering branch 'nodeNumbers'..."]);
    if (nodeNumbers.size > 0) {
      for (var currentNodeNumber in NodeNumbers) {
        var filter = "** WHERE nodeNumber='" + currentNodeNumber + "'";
        var currentNodeInfos = subset..nodeInfo.select(filter);    # IMPORTANT: '@' makes a deep copy
        if (currentNodeInfos.type == "hash") {
          var currentNodeKeys  = currentNodeInfos.keys;
          if (currentNodeKeys.size > 0) {
            var currentNodeKey = currentNodeKeys[1];
            nodeInfo[currentNodeKey] = currentNodeInfos[currentNodeKey];
          }
        }
      }
    }
  } elseif (nodeKeys.size > 0) {
    logMsg([level: "debug2", msg: "  entering branch 'nodeKeys'..."]);
    for (var currentNodeKey in NodeKeys) {
      var filter = "** WHERE nodeKey like '" + currentNodeKey + "'";
      if (isNumeric(currentNodeKey)) {
        filter = "** WHERE nodeKey='" + currentNodeKey + "'";
      }
      var currentNodeInfos = subset..nodeInfo.select(filter);    # IMPORTANT: '@' makes a deep copy
      if (currentNodeInfos.type == "hash") {
        var currentNodeKeys  = currentNodeInfos.keys;
        if (currentNodeKeys.size > 0) {
          var currentNodeKey = currentNodeKeys[1];
          nodeInfo[currentNodeKey] = currentNodeInfos[currentNodeKey];
        }
	logMsg("    cnk='" + currentNodeKey + "'  count=" + currentNodeKeys.size);
      }
    }
  } elseif (nodeIds.size > 0) {
    logMsg([level: "debug2", msg: "  entering branch 'nodeIds'..."]);
    for (var currentNodeId in NodeIds) {
      var filter = "** WHERE nodeId like '" + currentNodeId + "'";
      if (isNumeric(currentNodeId)) {
        filter = "** WHERE nodeId='" + currentNodeId + "'";
      }
      var currentNodeInfos = subset..nodeInfo.select(filter);    # IMPORTANT: '@' makes a deep copy
      if (currentNodeInfos.type == "hash") {
        var currentNodeKeys  = currentNodeInfos.keys;
        if (currentNodeKeys.size > 0) {
          var currentNodeKey = currentNodeKeys[1];
          nodeInfo[currentNodeKey] = currentNodeInfos[currentNodeKey];
        }
      }
    }
  } else {
    logMsg([level: "debug2", msg: "  entering branch 'full nodes'..."]);
    nodeInfo = subset..nodeInfo;
    #print "WARNING: nodeInfo for all nodes would be returned from method 'getNodeInfo' - CURRENTLY DEACTIVATED";
  }

  # Filter for specific infoKeys
  if (infoKeys.size > 0) {
    var finalNodeInfo = {};
    if (outputType == "single") {
      copyHashKeys(nodeInfo, finalNodeInfo, infoKeys);
      nodeInfo = finalNodeInfo;
    } elseif (outputType == "multiple") {
      if (nodeInfo.size > 0) {
        for (var nodeKey in nodeInfo) {
          if (nodeInfo[nodeKey].type == "hash") {
            finalNodeInfo[nodeKey] = {};
            copyHashKeys(nodeInfo[nodeKey], finalNodeInfo[nodeKey], infoKeys);
          }
        }
        nodeInfo = finalNodeInfo;
      }
    }
  } else {
    if (outputType == "multiple") {
      # Check if already 'multiple'
      var multiple = false;
      var keyList = nodeInfo.keys;
      #logMsg("========== keyList getNodeInfo ==============");
      #log keyList;
      if (keyList.size == 1) {
        if (nodeInfo.[keyList[1]].type == "hash") {
          if (nodeInfo.[keyList[1]]..nodeKey != "") {
            multiple = true;
          }
        }
        if (multiple == false) {
          logMsg("converting 'nodeInfo' to 'multiple' output type...");
          var key = nodeInfo..nodeKey;
          var finalNodeInfo = {};
          finalNodeInfo[nodeInfo..nodeKey] = nodeInfo;
          nodeInfo = finalNodeInfo;
        }
      } elseif (keyList.size > 1) {
        if (nodeInfo.[keyList[1]]..nodeKey != "") {
          multiple = true;
        }
      }
    }
  }

  #logMsg("  === nodeInfo =====");
  #log nodeInfo;
  #logMsg([level: "info", msg: "  finished getting node info"]);

  if (outputFormat == "tsv") {
    if (outputType == "single") {
      return infoToTsv([outputType: "string", info: [1: nodeInfo]]);
    } else {
      return infoToTsv([outputType: "string", info: nodeInfo]);
    }
  } else {   # 'hash'
    return nodeInfo;
  }
}

function getNodeNumbers(nodeBitset) {
  if (nodeBitset.type != "bitset") {
    nodeBitset = {selected};
  }

  return nodeBitset.atomno.all;
}

function printNodeInfo(dataHashref) {
  var nodeInfo = getNodeInfo(dataHashref);

  if (nodeInfo.type == "hash") {
    print nodeInfo;
  }
}

function showNodeInfo(dataHashref) {
  var nodeInfo     = getNodeInfo(dataHashref);
  var htmlNodeInfo = '<span class="atlasCommentItalic">Left-click at a node in mouse mode \'default\' to see detailed information here</span>';
  var domNodeId    = "nodeinfo_content";

  if (nodeInfo.type == "hash") {
    if ("" + nodeInfo..nodeKey != "") {
      htmlNodeInfo = infoToTsv(["info": [node1: nodeInfo], outputType: "verticalHtmlTable", cssClass: "jsnet3dVertical"]);
    } else {
      htmlNodeInfo = infoToTsv(["info": nodeInfo, outputType: "verticalHtmlTable", cssClass: "jsnet3dVertical"]);
    }
  }

  var javascriptCommand = "jaShowControl('nodeinfo', 'show'); $(\"#" + domNodeId + "\").html('" + htmlNodeInfo + "')";
  javascript @javascriptCommand;
}

function showNodeInfo_OLD(dataHashref) {
  var nodeInfo     = getNodeInfo(dataHashref);
  var htmlNodeInfo = '<span class="atlasCommentItalic">Left-click at a node in mouse mode \'default\' to see detailed information here</span>';
  var domNodeId    = "nodeinfo_content";

  if (nodeInfo.type == "hash") {
    htmlNodeInfo = infoToTsv(["info": [node1: nodeInfo], outputType: "verticalHtmlTable", cssClass: "jsnet3dVertical"]);
  }

  var javascriptCommand = "jaShowControl('nodeinfo', 'show'); $(\"#" + domNodeId + "\").html('" + htmlNodeInfo + "')";
  javascript @javascriptCommand;
}

function selectByDegree(dataHashref, maxValue, selectMode, action, outputType) {
  var minValue           = "";
  var nodeInfo           = {};
  var nodeNumbers        = [];
  var subsetKey          = "";
  var nodeBitset         = {none};

  # Check required parameters
  if (dataHashref.type == "hash") {
    if ("" + dataHashref..minValue != "") {
      minValue = dataHashref..minValue;
    }
    if ("" + dataHashref..maxValue != "") {
      maxValue = dataHashref..maxValue;
    }
    if (dataHashref..subsetKey != "") {
      subsetKey = dataHashref..subsetKey;
    }
    if (dataHashref..selectMode != "") {
      selectMode = dataHashref..selectMode;
    } else {
      selectMode = "only";
    }
    if (dataHashref..action != "") {
      action = dataHashref..action;
    } else {
      action = "select";
    }
    if (dataHashref..outputType != "") {
      outputType = dataHashref..outputType;
    } else {
      outputType = "nodeNumbers";
    }
  } elseif (dataHashref.type != "array") {
    minValue = dataHashref;
    if (selectMode == "") {
      selectMode = "only";
    }
    if (action == "") {
      action = "select";
    }
    if (outputType == "") {
      outputType = "nodeNumbers";
    }
    subsetKey = networkData..currentSubsetKey;
  } else {
   logMsg([level: "error", msg: "parameter hash not provided in call of method 'selectByDegree' - EMPTY SELECTION"]);
  }

  if ("" + minValue != "") {
    if ("" +  maxValue != "") {
      nodeBitset = {bondcount>=@minValue and bondcount<=@maxValue};
      nodeInfo = getNodeInfo([currentSubsetKey: subsetKey, nodeBitset: nodeBitset, outputType: "multiple"]);
    }
  }

  logMsg("====== nodeBitset - selectByDegree (min=" + minValue + "  max=" + maxValue + ") ===========");
  log "====== nodeBitset - selectByDegree (min=" + minValue + "  max=" + maxValue + ") ===========";
  log nodeBitset;
  logMsg("====== nodeInfo - selectByDegree ===========");
  log nodeInfo;

  if (nodeInfo.size > 0) {
    nodeNumbers = nodeInfo.array("id").select("(nodeNumber)");
  }

  switch(selectMode) {
    case "only":
      nodeBitset = {atomno=@nodeNumbers};
      break;
    case "add":
      nodeBitset = {selected | atomno=@nodeNumbers};
      break;
    case "subtract":
      nodeBitset = {selected & NOT atomno=@nodeNumbers};
      break;
    case "and":
      nodeBitset = {selected & atomno=@nodeNumbers};
      break;
    case "not":
      nodeBitset = {NOT atomno=@nodeNumbers};
      break;
  }

  switch(action) {
    case "select":
      select @nodeBitset;
      break;
  }

  switch(outputType) {
    default case "nodeNumbers":
      return nodeNumbers;
      break;
    case "bitset":
      return nodeBitset;
      break;
  }
}

function selectByInfoKey(dataHashref, value, selectMode, action, outputType) {   # called either by a hash as single parameter ('selectByInfoKey([infoKey: "labelShort", value: "daf-2"])') or by up to five string parameters 'infoKey', 'value' ('selectByInfoKey("labelShort", "daf-2")')
  var infoKey            = "";
  var values             = [];
  var nodeInfo           = {};
  var nodeNumbers        = [];
  var subsetKey          = "";

  # Check required parameters
  if (dataHashref.type == "hash") {
    if (dataHashref..infoKey != "") {
      infoKey = dataHashref..infoKey;
    }
    if (dataHashref..value.type == "array") {
      values = dataHashref..values;    
      logMsg("  valuesType=" + values.type + " in selectByInfoKey (hash)");
    }
    value = dataHashref..value;
    if (dataHashref..subsetKey != "") {
      subsetKey = dataHashref..subsetKey;
    }
    if (dataHashref..selectMode != "") {
      selectMode = dataHashref..selectMode;
    } else {
      selectMode = "only";
    }
    if (dataHashref..action != "") {
      action = dataHashref..action;
    } else {
      action = "select";
    }
    if (dataHashref..outputType != "") {
      outputType = dataHashref..outputType;
    } else {
      outputType = "nodeNumbers";
    }
  } elseif (dataHashref.type == "string") {
    infoKey = dataHashref;
    if (value.type == "array") {
      #print "DEBUG:   valuesType=" + values.type + " in selectByInfoKey (string)";
    } else {
      #print "DEBUG:   valueType=" + value.type + " in selectByInfoKey (string)";
    }
    if (selectMode == "") {
      selectMode = "only";
    }
    if (action == "") {
      action = "select";
    }
    if (outputType == "") {
      outputType = "nodeNumbers";
    }
  } else {
   logMsg([level: "error", msg: "parameter hash not provided in call of method 'selectByInfoKey' - EMPTY SELECTION"]);
  }

  if (infoKey != "") {
    if (infoKey == "species") {
      nodeInfo = checkSpecies([species: value, nodeInfoType: "multiple", returnMode: "nodeInfo", speciesFree: [], nodeInfo: networkData..subsets.[networkData..currentSubsetKey]..nodeInfo]);

    } else {
      if (value.type == "array") {
        nodeInfo = getNodeInfo([currentSubsetKey: subsetKey, selectInfoKey: infoKey, selectValues: value, outputType: "multiple"]);
      } else {
        nodeInfo = getNodeInfo([currentSubsetKey: subsetKey, selectInfoKey: infoKey, selectValue: value, outputType: "multiple"]);
      }
    }
  }

  #logMsg("====== nodeInfo - selectByInfoKey ===========");
  #log nodeInfo;

  if (nodeInfo.size > 0) {
    nodeNumbers = nodeInfo.array("id").select("(nodeNumber)");
  }

  switch(selectMode) {
    case "only":
      nodeBitset = {atomno=@nodeNumbers};
      break;
    case "add":
      nodeBitset = {selected | atomno=@nodeNumbers};
      break;
    case "subtract":
      nodeBitset = {selected & NOT atomno=@nodeNumbers};
      break;
    case "and":
      nodeBitset = {selected & atomno=@nodeNumbers};
      break;
    case "not":
      nodeBitset = {NOT atomno=@nodeNumbers};
      break;
  }

  switch(action) {
    case "select":
      select @nodeBitset;
      break;
  }

  switch(outputType) {
    default case "nodeNumbers":
      return nodeNumbers;
      break;
    case "bitset":
      return nodeBitset;
      break;
  }
}
function selectByFilter(dataHashref, selectMode, action, outputType) {   # called either by a hash as single parameter ('selectByFilter([filter: "labelShort='daf-2'"])') or by four string parameters 'filter', 'selectMode', 'action', 'outputType' ('selectByFilter("labelShort", "daf-2")')
  var filter      = "";
  var nodeBitset  = "";
  var nodeInfo    = {};
  var nodeNumbers = [];
  var subsetKey   = "";

  # Check required parameters
  if (dataHashref.type == "hash") {
    if (dataHashref..infoKey != "") {
      infoKey = dataHashref..infoKey;
    }
    filter = dataHashref..filter;
    if (dataHashref..subsetKey != "") {
      subsetKey = dataHashref..subsetKey;
    }
    if (dataHashref..selectMode != "") {
      selectMode = dataHashref..selectMode;
    } else {
      selectMode = "only";
    }
    if (dataHashref..action != "") {
      action = dataHashref..action;
    } else {
      action = "select";
    }
    if (dataHashref..outputType != "") {
      outputType = dataHashref..outputType;
    } else {
      outputType = "nodeNumbers";
    }
  } elseif (dataHashref.type == "string") {
    filter = dataHashref;
    if (selectMode == "") {
      selectMode = "only";
    }
    if (action == "") {
      action = "select";
    }
    if (outputType == "") {
      outputType = "nodeNumbers";
    }
  } else {
   logMsg([level: "error", msg: "parameter hash not provided in call of method 'selectByInfoKey' - EMPTY SELECTION"]);
  }

  nodeInfo = getNodeInfo([currentSubsetKey: subsetKey, selectFilter: filter, outputType: "multiple"]);

  #logMsg("====== nodeInfo - selectByInfoKey ===========");
  #log nodeInfo;

  if (nodeInfo.size > 0) {
    nodeNumbers = nodeInfo.array("id").select("(nodeNumber)");
  }

  switch(selectMode) {
    case "only":
      nodeBitset = {atomno=@nodeNumbers};
      break;
    case "add":
      nodeBitset = {selected | atomno=@nodeNumbers};
      break;
    case "subtract":
      nodeBitset = {selected & NOT atomno=@nodeNumbers};
      break;
    case "and":
      nodeBitset = {selected & atomno=@nodeNumbers};
      break;
    case "not":
      nodeBitset = {NOT atomno=@nodeNumbers};
      break;
  }

  switch(action) {
    case "select":
      select @nodeBitset;
      break;
  }

  switch(outputType) {
    default case "nodeNumbers":
      return nodeNumbers;
      break;
    case "bitset":
      return nodeBitset;
      break;
  }
}

function selectByEdgeInfoKey(dataHashref, value, selectMode, action, outputType) {   # called either by a hash as single parameter ('selectByInfoKey([infoKey: "labelShort", value: "daf-2"])') or by up to five string parameters 'infoKey', 'value' ('selectByInfoKey("labelShort", "daf-2")')
  var currentNetworkData = {};
  var subset             = {};
  var infoKey          = "";
  var values           = [];
  var bondSets         = [];
  var edgeInfo         = {};
  var nodeNumbers      = [];
  var subsetKey        = "";

  # Check required parameters
  if (dataHashref.type == "hash") {
    if (dataHashref..infoKey != "") {
      infoKey = dataHashref..infoKey;
    }
    if (dataHashref..value.type == "array") {
      values = dataHashref..values;    
      logMsg("  valuesType=" + values.type + " in selectByInfoKey (hash)");
    }
    value = dataHashref..value;
    if (dataHashref..subsetKey != "") {
      subsetKey = dataHashref..subsetKey;
    }
    if (dataHashref..selectMode != "") {
      selectMode = dataHashref..selectMode;
    } else {
      selectMode = "only";
    }
    if (dataHashref..action != "") {
      action = dataHashref..action;
    } else {
      action = "";
    }
    if (dataHashref..outputType != "") {
      outputType = dataHashref..outputType;
    } else {
      outputType = "bondsetArray";
    }

    if (dataHashref..networkData.type == "hash") {
      currentNetworkData = dataHashref..networkData;
    } else {
      if (networkData.type == "hash") {
        currentNetworkData = networkData;
      }
    }
    if (dataHashref..currentSubsetKey == "") {
      if (currentNetworkData..currentSubsetKey == "") {
        subsetKey = "full";
      } else {
        subsetKey = currentNetworkData..currentSubsetKey;
      }
    } else {
      subsetKey = dataHashref..currentSubsetKey;
    }
    if (currentNetworkData..subsets.[subsetKey].type != "hash") {
      msg = msg + "ERROR: no subset subhash found for subset '" + subsetKey + "' in call of method 'selectByInfoKey'\n";
    } else {
      subset = currentNetworkData..subsets.[subsetKey];
    }
  } elseif (dataHashref.type == "string") {
    infoKey = dataHashref;
    if (value.type == "array") {
      #print "DEBUG:   valuesType=" + values.type + " in selectByInfoKey (string)";
    } else {
      #print "DEBUG:   valueType=" + value.type + " in selectByInfoKey (string)";
    }
    if (selectMode == "") {
      selectMode = "only";
    }
    if (action == "") {
      #action = "";
    }
    if (outputType == "") {
      outputType = "bondsetArray";
    }

    if (networkData.type == "hash") {
      currentNetworkData = networkData;
    }
    if (currentNetworkData..currentSubsetKey != "") {
      subsetKey = currentNetworkData..currentSubsetKey;
    } else {
      subsetKey = "full";
    }
    if (currentNetworkData..subsets.[subsetKey].type == "hash") {
      subset = currentNetworkData..subsets.[subsetKey];
    }
  } else {
   logMsg([level: "error", msg: "parameter hash not provided in call of method 'selectByInfoKey' - EMPTY SELECTION"]);
  }

  if (infoKey != "") {
    #logMsg("  entering branch 'selectInfoKey' (valueType=" + value.type + ")...");
    if (value.type == "array") {
      for (var currentValue IN values) {
        var edgeFilter = "** WHERE " + infoKey + " like '" + currentValue + "'";
        if (isNumeric(currentValue)) {
          edgeFilter = "** WHERE " + infoKey + "='" + currentValue + "'";
        }
	var currentEdgeInfos = subset..edgeInfo.select(edgeFilter);    # IMPORTANT: '@' makes a deep copy
	if (currentEdgeInfos.type == "hash") {
	  var currentEdgeKeys  = currentEdgeInfos.keys;
	  if (currentEdgeKeys.size > 0) {
	    for (var currentEdgeKey IN currentEdgeKeys) {
 	      edgeInfo[currentEdgeKey] = currentEdgeInfos[currentEdgeKey];
            }
	  }
	}
      }
    } else {
      var edgeFilter = "** WHERE " + infoKey + " like '" + value + "'";
      if (isNumeric(value)) {
        edgeFilter = "** WHERE " + infoKey + "='" + value + "'";
      }
      #var fullNodeInfo = subset..nodeInfo;
      edgeInfo = subset..edgeInfo.select(edgeFilter);
      #logMsg("==== first edgeInfo ============");
      #log edgeInfo;
    }

    #var nodeNumberHash = {};
    if (edgeInfo.type == "hash") {
      if (edgeInfo.size > 0) {
        for (var edgeKey IN edgeInfo) {
          var currentEdgeInfo = edgeInfo[edgeKey];
          var nodeNumber1 = currentEdgeInfo..nodeNumber1;
          var nodeNumber2 = currentEdgeInfo..nodeNumber2;

          set bondmode and;
          var bondSet = {atomno=@nodeNumber1 OR atomno=@nodeNumber2}.bonds;
          bondSets.push(bondSet);
        }
      }
    }
    #nodeNumbers = nodeNumberHash.keys;

    #if (value.type == "array") {
    #  nodeInfo = getNodeInfo([currentSubsetKey: subsetKey, selectInfoKey: infoKey, selectValues: value, outputType: "multiple"]);
    #} else {
    #  nodeInfo = getNodeInfo([currentSubsetKey: subsetKey, selectInfoKey: infoKey, selectValue: value, outputType: "multiple"]);
    #}
  }

  #logMsg("====== edgeInfo - selectByEdgeInfoKey ===========");
  #log edgeInfo;

#  switch(selectMode) {
#    case "only":
#      nodeBitset = {atomno=@nodeNumbers};
#      break;
#    case "add":
#      nodeBitset = {selected | atomno=@nodeNumbers};
#      break;
#    case "subtract":
#      nodeBitset = {selected & NOT atomno=@nodeNumbers};
#      break;
#    case "and":
#      nodeBitset = {selected & atomno=@nodeNumbers};
#      break;
#    case "not":
#      nodeBitset = {NOT atomno=@nodeNumbers};
#      break;
#  }

  switch(action) {
    case "select":
      #select @nodeBitset;
      break;
  }

  switch(outputType) {
    default case "nodeNumbers":
      #return nodeNumbers;
      break;
    case "bitset":
      #return nodeBitset;
      break;
    case "bondsetArray":
      return bondSets;
      break;
  }
}

function colorEdgeSets(edgeSets, color, translucency) {
  var msg = "";

  if ("" + translucency == "") {
    translucency = 4;
  }

  if (color != "") {
    if (edgeSets.type == "bondset") {
      color @edgeSets @color;
    } elseif (edgeSets.type == "array") {
      for (var edgeSet IN edgeSets) {
        color @edgeSet @color translucent @translucency;
      }
    }
  }
}


function setValue(nodeInfo, infoKey, value) {   # value of 'infoKey' set for all nodes in 'nodeInfo' hash
  var msg         = "";

  # Check required parameters
  if (nodeInfo.type != "hash") {
    msg = msg +  "ERROR: parameter 'nodeInfo' must be a hash in call of method 'selectByInfoKey'";
  }
  if ("" + infoKey == "") {
    msg = msg +  "ERROR: parameter 'infoKey' must be a non-empty string in call of method 'selectByInfoKey'";    
  }

  if (msg != "") {
    logMsg({"level": "mixed", "msg": msg});
    return;
  }

  if (nodeInfo.size > 0) {
    for (var nodeKey IN nodeInfo) {
      #logMsg("setting infoKey '" infoKey + "' to value '" + value + "' for nodeKey '" + nodeKey + "'");
      nodeInfo[nodeKey].[infoKey] = value;
    }
  } else {
    logMsg([level: "info", msg: "empty node set provided in call of method 'setValue' - nothing changed"]);
  }

}

function logMsg(data) {
  var message        = "";
  var methodCall     = "";
  var logCommandName = "";
  var logCommandData = "";
  var levelIndicator = "";

  var level          = "debug";
  var logChannels    = [];
  var methods        = [];

  var dataType       = data.type;

  if (dataType == "hash") {
    if (data..msg != "") {
      message = data..msg;
    }
    if (data..level != "") {
      level = data..level;
    }
    if (data..channel.type == "array") {
      logChannels = data..channel;
    } elseif (data..channel.type == "string") {
      if (data..channel !="") {
        logChannels = [data..channel];
      }
    }
  } elseif (dataType == "array") {
    message = data.join("\n");
  } else {
    message = data;
  }

  # Define log level indicators (printed at the beginning of a message)
  var levelIndicators = {"info":   "NOTE: ",
                         "warn":   "WARNING: ",
                         "error":  "ERROR: ",
                         "iError": "INTERNAL ERROR: ",
                         "debug":  "DEBUG: ",
                         "debug2": "DEBUG_L2: ",
                         "debug3": "DEBUG_L3: "
                        };

  # Define level to channel translation  (log: logfile and java console, sconsole: script console, jsconsole: javascript console)
  var levelChannels = {"error":  ["log", "sconsole", "jsconsole"],
                       "iError": ["log", "sconsole", "jsconsole"],
                       "warn":   ["log", "sconsole", "jsconsole"],
                       "info":   ["log", "sconsole", "jsconsole"],
                       "debug":  ["log", "jsconsole"],
                       "debug2": ["log", "jsconsole"],
                       "debug3": ["log", "jsconsole"],
                       "mixed":  ["log", "sconsole", "jsconsole"]
                     };

  # Define channel to method translation
  var channelMethods = {"log": "log",
                        "sconsole": "print",
                        "jsconsole" : "javascript console.log("
                       };

  var channelMethodPostfixes = {"jsconsole": ")"};
  var postfixes              = [];

  switch(level) {
    case "debug":
      if (debugLevel < 1) {
        return;
      }
      break
    case "debug2":
      if (debugLevel < 2) {
        return;
      }
      break
    case "debug3":
      if (debugLevel < 3) {
        return;
      }
      break
  }

  if (levelIndicators[level] != "") {
    levelIndicator = levelIndicators[level];
  } else {
    if (level == "mixed") {
      levelIndicator = "";
    } else {
      levelIndicator = "" + level + ": ";
    }
  }
  logCommandData = levelIndicator + message;

  if (logChannels.size == 0) {
    if (levelChannels[level].type == "array") {
      logChannels = levelChannels[level];
    }    
  }

  if (logChannels.size > 0) {
    for (var logChannel in logChannels) {
      if (channelMethods[logChannel] != "") {
        methods.push(channelMethods[logChannel]);
        if (channelMethodPostfixes[logChannel] != "") {
          postfixes.push(channelMethodPostfixes[logChannel]);
        } else {
          postfixes.push("");
        }
      }
    }
  }

  if (methods.size > 0) {
    var i = 0;
    for (var method in methods) {
      i++;
      var logCommand = "" + method + ' "' + logCommandData + '"' + postfixes[i];
      var logCommandOutput = script(logCommand);
      if (logCommandOutput != "") {
        print logCommandOutput.trim("\n");   # 'trim' used to remove the extra newline added by the 'script' command to 'logCommandOutput'
      }
    }
  }
}

function copyHashKeys(sourceHash, destinationHash, keyList) {   # DOES NOT ACTUALLY COPY (due to Jmol bug?)
  var msg = "";

  # Check parameters
  if (sourceHash.type != "hash") {
    msg = msg + "ERROR: parameter 'sourceHash' must be a hash in call of method 'copyHashKeys'\n";
  }
  if (destinationHash.type != "hash") {
    msg = msg + "ERROR: parameter 'destinationHash' must be a hash in call of method 'copyHashKeys'\n";
  }
  if (msg != "") {
    logMsg({"level": "mixed", "msg": msg});
    return;
  }

  if (keyList.type != "array" || keyList.size == 0) {
    keyList = sourceHash.keys;
  }

  if (keyList.size > 0) {
    for (var currentKey in keyList) {
      destinationHash[currentKey] = sourceHash[currentKey];
    }
  }
}

function copyHash(sourceHash) {   # IMPORTANT: no deep copy, just strings/numbers are actually copied, hashes/arrays are "copied" by pointer
  var destinationHash = {};

  if (sourceHash.type == "hash") {
    copyHashKeys(sourceHash, destinationHash);
  }

  return destinationHash;
}

function tokenizeExpression(expression) {
  var tokenList     = [];
  var wordList      = [];

  var knownTokens   = {"(":   {"tokenType": "open", "leftBindingPower": 0},
                       ")":   {"tokenType": "close", "leftBindingPower": 10},
                       "&":   {"tokenType": "operator", "operatorType": "logical", "argumentCount": 2, "leftBindingPower": 20},
                       "and": {"tokenType": "operator", "operatorType": "logical", "argumentCount": 2, "leftBindingPower": 20},
                       "AND": {"tokenType": "operator", "operatorType": "logical", "argumentCount": 2, "leftBindingPower": 20},
                       "|":   {"tokenType": "operator", "operatorType": "logical", "argumentCount": 2, "leftBindingPower": 10},
                       "or":  {"tokenType": "operator", "operatorType": "logical", "argumentCount": 2, "leftBindingPower": 10},
                       "OR":  {"tokenType": "operator", "operatorType": "logical", "argumentCount": 2, "leftBindingPower": 10},
                       "!":   {"tokenType": "operator", "operatorType": "logical", "argumentCount": 1, "leftBindingPower": 30},
                       "not": {"tokenType": "operator", "operatorType": "logical", "argumentCount": 1, "leftBindingPower": 30},
                       "NOT": {"tokenType": "operator", "operatorType": "logical", "argumentCount": 1, "leftBindingPower": 30},
                       "=":   {"tokenType": "operator", "operatorType": "comparative", "argumentCount": 2, "leftBindingPower": 40},
                       "==":  {"tokenType": "operator", "operatorType": "comparative", "argumentCount": 2, "leftBindingPower": 40},
                       "<=":  {"tokenType": "operator", "operatorType": "comparative", "argumentCount": 2, "leftBindingPower": 40},
                       ">=":  {"tokenType": "operator", "operatorType": "comparative", "argumentCount": 2, "leftBindingPower": 40},
                       "<":   {"tokenType": "operator", "operatorType": "comparative", "argumentCount": 2, "leftBindingPower": 40},
                       ">":   {"tokenType": "operator", "operatorType": "comparative", "argumentCount": 2, "leftBindingPower": 40}
                       };

  var tokenTranslation = {"and": "&",
                          "AND": "&",
                          "or":  "|",
                          "OR":  "|",
                          "not": "!",
                          "NOT": "!"
                          };

  var knownTokensByFirstCharacter = {};
  var maxKnownTokenSize     = 1;
  for (var knownToken in knownTokens) {
    maxKnownTokenSize = [maxKnownTokenSize, knownToken.size].max;
    if (knownToken.size > 0) {
      var firstCharacter = knownToken[1];
      if (knownTokensByFirstCharacter[firstCharacter].type != "array") {
        knownTokensByFirstCharacter[firstCharacter] = [knownToken];
      } else {
        knownTokensByFirstCharacter[firstCharacter].push(knownToken);
      }
    }
  }
  var maxOffset         = maxKnownTokenSize - 1;
  var tokenNumber       = 0;
  var closeMatchCounter = 0;

  # Trim spaces
  expression = expression.replace();

  if (expression.type == "string") {
    if (expression != "") {
      var token          = "";
      var tokenType      = "";
      var quoteCharacter = "";
      var literalType    = "";
      var tokenStart     = false;
      var tokenEnd       = false;
      var i              = 1;
      while (i <= expression.size) {
        var offsetUsed = 0;
        for (var offset from [maxOffset 0]) {
          token = expression[i][i + offset];
          #logMsg("i=" + i + "  offset=" + offset + "  token='" + token + "'");
          if (knownTokens[token].type == "hash") {
            offsetUsed = offset;
            tokenEnd   = true;
            tokenType  = knownTokens[token]..tokenType;
            #logMsg("  tokenType=" + tokenType);
            break;
          }
        }
        if (tokenType == "") {   # no token identified yet?
          var character = expression[i];
          #logMsg("i=" + i + "  character='" + character + "'");
          if (character == '"' || character == "'") {
            var endCharacter = character;
            tokenType      = "literal";
            literalType    = "quoted";
            quoteCharacter = endCharacter;
            token          = "";
            tokenEnd       = false;
            offset         = 1;
            while ((i + offset) <= expression.size && tokenEnd == false) {
              character = expression[i + offset];
              if (character == endCharacter) {
                tokenEnd   = true;
                offsetUsed = offset;
              } else {
                token = token + character;
                offset++;
                offsetUsed = offset;
              }
            }
          } elseif (character != " ") {
            tokenType    = "literal";
            literalType = "unquoted";
            token        = character;
            tokenEnd     = false;
            offset       = 1;
            while ((i + offset) <= expression.size && tokenEnd == false) {
              var character = expression[i + offset];
              if (knownTokensByFirstCharacter[character].type == "array") {
                for (var knownToken in knownTokensByFirstCharacter[character]) {
                  var knownTokenSize = knownToken.size;
                  if (expression[i + offset][i + offset + knownTokenSize - 1] == knownToken) {
                    offsetUsed = offset - 1;
                    tokenEnd   = true;
                  }
                }
              }
              if (tokenEnd == false) {
                token = token + character;
                offset++;
              }
            }
          }
        }

        if (tokenEnd) {
          if (token != "") {
            tokenNumber++;
            tokenList.push({"tokenNumber": tokenNumber, "tokenType": tokenType, "token": token});
            if (knownTokens[token].type == "hash") {
              copyHashKeys(knownTokens[token], tokenList[tokenNumber]);
            }
            if (literalType != "") {
              tokenList[tokenNumber]..literalType = literalType;
            }
            if (quoteCharacter != "") {
              tokenList[tokenNumber]..quoteCharacter = quoteCharacter;
            }
            if (tokenType == "open") {
              closeMatchCounter++;
            } elseif (tokenType == "close") {
              closeMatchCounter--;
            }
            token          = "";
            tokenType      = "";
            literalType    = "";
            quoteCharacter = "";
            tokenEnd       = false;
          }
        }
        i = i + offsetUsed + 1;
      }

      if (tokenEnd == false) {
        if (tokenType == "literal") {
          if (token != "") {
            tokenNumber++;
            tokenList.push({"tokenNumber": tokenNumber, "tokenType": tokenType, "token": token, "literalType": literalType});
            if (quoteCharacter != "") {
              tokenList[tokenNumber]..quoteCharacter = quoteCharacter;
            }
          }
        }
      }
    }

  } else {
    logMsg({"level": "error", "msg": "parameter 'expression' must be a string in call of method 'tokenizeLogicExpression'"});
  }

  # Normalize operators
  if (tokenList.size > 0) {
    for (var tokenInfo in tokenList) {
      if (tokenInfo.type == "hash") {
        var tokenType = tokenInfo..tokenType;
        #print "DEBUG: tokenType=" + tokenType;
        if (tokenType[1][8] == "operator") {
          var token = tokenInfo..token;
          #print "DEBUG:  token='" + token + "'";
          if (tokenTranslation[token] != "") {
            tokenInfo..token = (tokenTranslation[token]);
            #print "DEBUG:    translated to '" + tokenInfo..token + "'";
          }
        }
      }
    }
  }

  #show tokenTranslation;
  print tokenList;

  if (closeMatchCounter != 0) {
    logMsg({"level": "error", "msg": "unbalanced brackets (missing closing brackets=" + closeMatchCounter + ") for expression '" + expression + "' in method 'tokenizeExpression'"});
    tokenList = [];
  }
  return tokenList;
}


function buildSubset(dataHashref) {   # works with raw network data, copies 'nodeInfo' data 
  var msg                    = "";
  var subset                 = {};
  var subsetKey              = "";
  var baseSubsetKey          = "";
  var base                   = {};
  var nodeFilter             = {};
  var edgeFilter             = {};
  var nodeInfo               = {};
  var edgeInfo               = {};
  var neighbours             = {};
  var processedNodeKeys      = {};
  var lDefs                  = {};
  var stopConditions         = [];
  var stopConditionAvailable = false;
  var nodePairs              = {};          # pairs of node types for edge filter
  var pairMode               = "exclude";   # available modes: 'exclude', 'only'
  var pairMinPathLength      = 1;

  # Check required parameters
  if (dataHashref.type != "hash") {
    msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED in call of method 'buildSubset'\n";
  } else {
    if (dataHashref..subsets.type != "hash") {
      msg = msg + "ERROR: subhash 'dataHashref..subsets' NOT PROVIDED in call of method 'buildSubset'\n";
    } else {
      if ("" + dataHashref..baseSubsetKey == "") {
        dataHashref..baseSubsetKey = "full";
      }
      baseSubsetKey = dataHashref..baseSubsetKey;
      if ("" + dataHashref..currentSubsetKey == "") {
        dataHashref..currentSubsetKey = "set1";
      }
      subsetKey = dataHashref..currentSubsetKey;
      if (subsetKey == baseSubsetKey) {
        msg = msg + ": subsetKey '" + subsetKey + "' MUST BE DIFFERENT from baseSubsetKey '" + baseSubsetKey + "'";
      } else {
        if (dataHashref..subsets.[subsetKey].type == "hash") {
          logMsg({"level": "info", "msg": "overwriting existing subset '" + subsetKey + "' in method 'buildSubset'\n"});
          dataHashref..subsets.[subsetKey] = {};
        } else {
          dataHashref..subsets.[subsetKey] = {};
          subset = dataHashref..subsets.[subsetKey];
        }
        if (dataHashref..subsets.[baseSubsetKey].type == "hash") {
          base = dataHashref..subsets.[baseSubsetKey];
          if (base..nodeInfo.type != "hash") {
            base..nodeInfo = {};
            msg = msg + "WARNING: no 'nodeInfo' subhash provided for base subset '" + baseSubsetKey + "' while building subset '" + subsetKey + "' in call of method 'buildSubset' - SKIPED BUILDING SUBSET\n";
          }
          nodeInfo = base..nodeInfo;
          if (base..edgeInfo.type != "hash") {
            base..edgeInfo = {};
            logMsg({"level": "info", "msg": "no 'edgeInfo' subhash provided for base subset '" + baseSubsetKey + "' while building subset '" + subsetKey + "' in call of method 'buildSubset' - CREATED EMPTY SUBHASH\n"});
          }
          edgeInfo = base..edgeInfo;
          if (base..neighbours.type != "hash") {
            base..neighbours.type = {};
          }
          neighbours = base..neighbours;
        } else {
        }
      }
    }

    if (dataHashref..nodeFilter.type != "hash" && dataHashref..nodeFilter.type != "bitset") {
      dataHashref..nodeFilter = {};
      msg = msg + "WARNING: subhash 'dataHashref..nodeFilter' NOT PROVIDED in call of method 'buildSubset'\n";
    }
    nodeFilter = dataHashref..nodeFilter;

    if (dataHashref..edgeFilter.type != "hash" && dataHashref..edgeFilter.type != "bitset") {
      dataHashref..edgeFilter = {};
      msg = msg + "WARNING: subhash 'dataHashref..edgeFilter' NOT PROVIDED in call of method 'buildSubset'\n";
    } else {
      edgeFilter = dataHashref..edgeFilter;
      if (dataHashref..edgeFilter.type == "hash") {
        if (edgeFilter..stopConditions.type == "array") {
          stopConditions = edgeFilter..stopConditions;
        } else {
          if (edgeFilter..stopConditions.type != "") {
            logMsg("  'stopConditions' parameter is not an array ('" + edgeFilter..stopConditions.type + "') in call of method 'buildSubset'\n");
          }
        }
        if (edgeFilter..nodePairs.type == "hash") {
          nodePairs = edgeFilter..nodePairs;
        } else {
          if (edgeFilter..nodePairs.type != "") {
            logMsg("  'nodePairs' parameter is not a hash ('" + edgeFilter..nodePairs.type + "') in call of method 'buildSubset'\n");
          }
        }
	if ("" + edgeFilter..pairMode != "") {
	  pairMode = edgeFilter..pairMode;
	}
        if ("" + edgeFilter..pairMinPathLength != "") {
          pairMinPathLength = edgeFilter..pairMinPathLength;
        }
      }
    }


   if (dataHashref..networkDefinitions.type == "hash") {
    lDefs = dataHashref..networkDefinitions.[dataHashref..networkType]..labelDefinitions;
   } else {
    lDefs = networkData..networkDefinitions.[dataHashref..networkType]..labelDefinitions;
   }

  }
  logMsg("   started building subset '" + subsetKey + "' from  base subset '" + baseSubsetKey + "' network data...");
  if (msg != "") {
    logMsg({"level": "mixed", "msg": msg});
    return;
  } else {
   logMsg("     parameters ok - initial edgeCount=" + base..edgeInfo.keys.size + "  initial nodeCount=" + base..nodeInfo.keys.size) ;
  }
  logMsg(" edgeInfo: type=" + edgeInfo.type + "  size=" + edgeInfo.size);

  var nodeFilterNodeInfo = {};
  if (nodeFilter.type == "bitset") {
    nodeFilterNodeInfo = getNodeInfo([nodeBitset: nodeFilter, currentSubsetKey: baseSubsetKey]);
  } else {
    if (nodeFilter..filterExpression !="") {
      var filter = "** WHERE " + nodeFilter..filterExpression;
      #nodeFilterNodeInfo = copyHash(getProperty(nodeInfo, filter));    # IMPORTANT: 'getProperty' makes a copy
      nodeFilterNodeInfo = @{nodeInfo.select(filter)};    # IMPORTANT: '@' makes a deep copy

      # Check for species match (extra check needed because 'getProperty()' cannot filter for multiValue property values like 'species', coded as subhash)
      if (nodeFilter..species != "") {
        if (nodeFilterNodeInfo.size > 0) {
          for (var currentNodeKey in nodeFilterNodeInfo) {
            if (checkSpecies([nodeInfo: nodeFilterNodeInfo[currentNodeKey], species: nodeFilter..species, speciesFree: nodeFilter..speciesFree]) == false) {
              var removedNodeInfo = nodeFilterNodeInfo.pop(currentNodeKey);   # remove nodes with wrong species
            }
          }
        }
      }
    }
  }

  #logMsg("filterExpression=" + nodeFilter..filterExpression);
  #log nodeFilterNodeInfo;

  var newSubset     = {};
  var newNodeInfo   = {};
  var maxPathLength = nodeInfo.size;
  newSubset..nodeInfo = newNodeInfo;
  if (edgeFilter.type == "hash") {
    if ("" + edgeFilter..maxPathLength != "") {
      if (edgeFilter..maxPathLength == "any") {
        maxPathLength = nodeInfo.size;
      } elseif (edgeFilter..maxPathLength >= 0) {
        maxPathLength = edgeFilter..maxPathLength;
      }
    }
  }

  if (nodeFilterNodeInfo.size > 0) {
    if (maxPathLength == 0) {   # no additional nodes added
      newNodeInfo = nodeFilterNodeInfo;
      newSubset..nodeInfo = newNodeInfo;
      var edgeFilterNodeInfo = nodeFilterNodeInfo;
      getRawNeighbours({"newSubset": newSubset, "baseNodeInfo": nodeInfo, "nodeFilterNodeInfo": nodeFilterNodeInfo, "edgeFilterNodeInfo": edgeFilterNodeInfo, "edgeInfo": edgeInfo, "neighbours": neighbours, "processedNodeKeys": processedNodeKeys, "maxPathLength": 1, "stopConditions": stopConditions, "nodePairs": nodePairs, "pairMode": pairMode, "pairMinPathLength": pairMinPathLength});
    } else {  # add nodes connected to filtered nodes (until 'maxPathLength' is reached)
      newNodeInfo = nodeFilterNodeInfo;    # IMPORTANT: '@' makes a deep copy
      newSubset..nodeInfo = newNodeInfo;
      #logMsg("======== newNodeInfo start ===========");
      #log newNodeInfo;
      #logMsg("======== newNodeInfo end ===========");
      var edgeFilterNodeInfo = "";
      if (edgeFilter.type == "bitset") {
        edgeFilterNodeInfo = getNodeInfo([nodeBitset: nodeFilter, currentSubsetKey: baseSubsetKey]);
      } else {
        if (edgeFilter..filterExpression !="") {   # build additional node filter for connected nodes
          var filter = "** WHERE " + edgeFilter..filterExpression;
          edgeFilterNodeInfo = @{nodeInfo.select(filter)};    # IMPORTANT: '@' makes a deep copy
          logMsg("  edgeFilter=" + filter);

          # Check for species match (extra check needed because 'getProperty()' cannot filter for multiValue property values like 'species', coded as subhash)
          if (edgeFilter..species != "") {
            if (edgeFilterNodeInfo.size > 0) {
              for (var currentNodeKey in edgeFilterNodeInfo) {
                if (checkSpecies([nodeInfo: edgeFilterNodeInfo[currentNodeKey], species: edgeFilter..species, speciesFree: edgeFilter..speciesFree]) == false) {
                  var removedNodeInfo = edgeFilterNodeInfo.pop(currentNodeKey);   # remove nodes with wrong species
                }
              }
            }
          }
          #log edgeFilterNodeInfo;
        }
      }
      #logMsg("  nodeFilterNodeInfo: " + nodeFilterNodeInfo.keys.join(" || "));
      getRawNeighbours({"newSubset": newSubset, "baseNodeInfo": nodeInfo, "nodeFilterNodeInfo": nodeFilterNodeInfo, "edgeFilterNodeInfo": edgeFilterNodeInfo, "edgeInfo": edgeInfo, "neighbours": neighbours, "processedNodeKeys": processedNodeKeys, "maxPathLength": maxPathLength, "stopConditions": stopConditions, "nodePairs": nodePairs, "pairMode": pairMode, "pairMinPathLength": pairMinPathLength});
    }
  }

  #   Rebuild 'newNodeInfo' as 'finalNewNodeInfo' (must be copies in 'newSubset' like the 'getProperty' command provides them)
  var finalNewNodeInfo = {}
  if (newSubset..nodeInfo.type == "hash") {
    if (newSubset..nodeInfo.size > 0) {
      finalNewNodeInfo = @newSubset..nodeInfo;    # '@' makes deep copy
      #logMsg("======== finalNewNodeInfo start ===========");
      #log finalNewNodeInfo;
      #logMsg("======== finalNewNodeInfo end ===========");
      if (finalNewNodeInfo.type != "hash") {
        finalNewNodeInfo = {};
      }
    } else {
      logMsg({"level": "info", "msg": "  no nodes matching filter criteria for subset '" + subsetKey + "' found in method 'buildSubset'"});
      return;
    }
  } else {
    logMsg({"level": "iError", "msg": "  newSubset..nodeInfo must be a hash in method 'buildSubset'"});
    #log newSubset..nodeInfo;
  }


  newSubset..nodeInfo = finalNewNodeInfo;
  newSubset..baseSubsetKey = baseSubsetKey;

  dataHashref..subsets.[subsetKey] = newSubset;
  #logMsg("======== newSubset (" + subsetKey + ") start ===========");
  #log newSubset;
  #logMsg("======== newSubset (" + subsetKey + ") end ===========");

  determineRawSubnetworks(dataHashref);

  #   Redefine labels
  #logMsg("  ==== redefining labels in method 'buildSubset'...");
  defineLabels([nodeInfo: finalNewNodeInfo, labelDefinitions: lDefs]);

}

function resetGuiAfterLoadNetworkData(mode) {   # SPECIFIC FOR JSNET3D-AGEFACTDB GUI
  var startTime         = now();

  logMsg([level: "info", msg: "Reinitializing interface..."]);


  if (mode != "init") {
    # #########################################################################################################################################################
    # ### Build subset 'full (all loaded network data' (needed for 'gee of interest' analysis overview) ###
    # #########################################################################################################################################################
    subsetKeys = [full: 1];
    subsetFileNumber = 1;
    mmcifData = "";
    logMsg([level: "info", msg: "Processing new full subset (all loaded network data)..."]);

    networkData..currentSubsetKey = "full";
    var subnetworkSize = networkData..subsets.[networkData..currentSubsetKey]..nodeInfo.size;

    zap;
    if (subnetworkSize > 1) {
      #networkData..exportSubset = networkData..currentSubsetKey;
      #networkData..exportFilename = "biolayout/agefactdb-jsnet3d_full.txt";
      #networkData..exportFormat = "pairTSV";
      #exportSubset(networkData);

      #networkData..importFormat = "biolayout3d";
      #networkData..importFilename = "biolayout/agefactdb-jsnet3d_full-fmmm_100_eades_10.layout";
      #networkData..importSubsetKey = networkData..currentSubsetKey;
      #networkData..importCoordinateScalingFactor = 0.2;
      #importSubsetCoordinates(networkData);

      buildMmcifData(networkData);
      mmcifData = networkData..subsets.[networkData..currentSubsetKey]..mmcifData;
      #zap @{networkData..currentSubsetKey};
      load APPEND "@mmcifData" FILTER "addBonds";
      initDisplay(layoutOptions);
      frame ID @{networkData..currentSubsetKey};
      setScale({"node": 0.5, "edge": 0.04, "frameSize": 50});
      initHover;

      select all; color bonds opaque;
      adjustEdgeLength(0.4);

      # Set orientation
      center all;
      rotate best;
      #
      # ### Zoom ###
      zoom 0;

      var subsetName        = "Full";
      var optionHtml        = '<option value="full">Full</option>';
      var x                 = javascript("document.getElementById('displaysubset_menu').innerHTML = '" + optionHtml + "';");
      var javascriptCommand = "idbSetSelected(document.getElementById('displaysubset_menu'), '" + networkData..currentSubsetKey + "'); subsetKeyToName['" + networkData..currentSubsetKey + "']='" + subsetName + "'; $('#page_name').text('" + subsetName + "');";
      javascript @javascriptCommand;


      if (networkData..subsets.[networkData..currentSubsetKey].type == "hash") {
        networkData..subsets.[networkData..currentSubsetKey]..storedOrientation = script("show orientation").split("#").[1];    
        networkData..subsets.[networkData..currentSubsetKey]..storedSelection = {all};    
      }
      var subsetName = "Full";
      networkData..subsets.[networkData..currentSubsetKey]..subsetName = subsetName;

      javascriptCommand = "last_model=" + subsetFileNumber + "; document.getElementById('subset_count').innerHTML = '" + subsetFileNumber + "'; subset_names.push('" + networkData..currentSubsetKey + "'); subsetKeyToName['" + networkData..currentSubsetKey + "']='" + subsetName + "'; $('#page_name').text('" + subsetName + "');";
      javascript @javascriptCommand;
    } else {
      logMsg([level: "info", msg: "   no network data found for full subset - SKIPPED SUBSET GENERATION"]);
    }

    var timeMessage = " (time=" + format("%.1f", now(startTime) / 1000) + " sec)";
    logMsg([level: "info", msg: "finished reinitializing interface" + timeMessage]);
  }

}

function manageStandardSubset(action, subsetValue, subsetType, extraNodeTypeString, mode) {   # SPECIFIC FOR JSNET3D-AGEFACTDB GUI
  var startTime         = now();
  var nodeId            = "";
  var subsetKey         = "";
  var extension         = "";
  var filterExtension   = "";
  var subsetValueData   = subsetValue.split("||");
  var extraNodeTypes    = extraNodeTypeString.split("||").sort;
  var speciesInfo       = {};
  var species_shortcut1 = "";
  var species_shortcut2 = "";
  var optionHtml        = "";
  var nodeName          = "";
  var subsetNameExtension = "";
  var skipLayout          = false;
  var skipLayoutReason    = " (switched off manually in layout options)";
  var speciesIncluded     = false;

  if (mode.find("skipLayout","im") == "skipLayout") {
    skipLayout = true;
  }
  #logMsg("subsetValue='" + subsetValue + "'");
  #show subsetValueData;
  if (subsetValueData.size >= 2) {
    var subsetBaseName = subsetValueData[1] + "_" + subsetType;
    nodeId             = subsetValueData[2];

    if (extraNodeTypes.size > 0) {
      for (var i FROM [1 extraNodeTypes.size]) {
        var extraNodeType   = extraNodeTypes[i];
        var extraNodeTypeId = networkData..networkDefinition..translations..typeToTypeId.[extraNodeType];
        if (extraNodeTypeId != "") {
          extension = extension + "_" + extraNodeTypeId;
        }
        if (extraNodeType == "species") {
          speciesIncluded = true;
        }
        switch(extraNodeType) {
          case "homology_analysis":
            filterExtension = filterExtension + " OR nodeSubType='" + extraNodeType + "'";
            break;
          case "go_process":
            filterExtension = filterExtension + " OR goCategory='Process'";
            break;
          case "go_function":
            filterExtension = filterExtension + " OR goCategory='Function'";
            break;
          case "go_component":
            filterExtension = filterExtension + " OR goCategory='Component'";
            break;
          case "keggPathway":
            filterExtension = filterExtension + " OR bioSystemType='pathway'";
            break;
          case "keggPathwayGene":
            filterExtension = filterExtension + " OR nodeType='gene'";
            break;
          DEFAULT:
            filterExtension = filterExtension + " OR nodeType='" + extraNodeType + "'";
        }
      }
    }

    nodeKey     = "ageingFactorId||" + nodeId;
    nodeInfo    = networkData..subsets..full..nodeInfo.[nodeKey];
    nodeName    = nodeInfo..ageingFactorName.replace("'","`");
    nodeSubType = nodeInfo..nodeSubType;
    speciesInfo = nodeInfo..species;

    # Determine species shortcut
    var speciesData = [];
    if (speciesInfo.type == "hash") {
      if (speciesInfo.size == 1) {
        species = speciesInfo.keys[1];
        speciesData = speciesInfo.keys.[1].split(" ");
      }
    } else {
     speciesData = speciesInfo.split(" ");
    }
    if (speciesData.size > 1) {
      var firstWord = speciesData[1];
      var firstCharacter = firstWord[1];
      speciesShortcut1 = "" + firstCharacter + "."  + speciesData[2];
      speciesShortcut2 = "" + firstCharacter + ". " + speciesData[2];
    } else {
      speciesShortcut = speciesInfo;
    }

    if (nodeSubType != "gene") {
      if (!speciesIncluded) {
        var extraNodeTypeId = networkData..networkDefinition..translations..typeToTypeId..species;
        if (extraNodeTypeId != "") {
          extension = extension + "_" + extraNodeTypeId;   # 'species' is included automatically in subset for compounds/other_factors
        }

      }
    }

    subsetKey = subsetBaseName + extension;
    if (subsetKeys[subsetKey] == "") {
      subsetKeys[subsetKey] = 1;
      subsetNameExtension   = "";
    } else {
      subsetKeys[subsetKey]++;
      var number = subsetKeys[subsetKey];
      subsetKey = subsetKey + "-" + number;
      subsetNameExtension = " - " + number;
    }

    logMsg([level: "info", msg: "action='" + action + "'  nodeId='" + nodeId + "'  subsetKey='" + subsetKey + "'  subsetNameExtension='" + subsetNameExtension + "'"]);

    if (action == "add") {
    layoutOptions.tiled = false;

    mmcifData = "";
    logMsg([level: "info", msg: "Processing ageing factor '" +  nodeName + " " + species + " - " + nodeId + "'..."]);
    logMsg("filterExtension=" + filterExtension);

    # Filter network data
    networkData..currentSubsetKey = subsetKey;
    networkData..nodeFilter = [filterExpression: "ageingFactorId='" + nodeId + "'"];
    if (subsetType == "direct") {
      if (nodeInfo..ageingFactorType == "gene") {
        networkData..edgeFilter = [maxPathLength: 3,
                                  filterExpression: "nodeType='ageingFactor' OR (nodeType='observation' AND lifespanEffectSignificant!='')" + filterExtension,
                                  stopConditions: [{"infoKey": "nodeType", "value": "species"}, {"infoKey": "nodeType", "value": "alleleType"}, {"infoKey": "nodeType", "value": "citation"}, {"infoKey": "nodeType", "value": "goTerm"}, {"infoKey": "nodeType", "value": "gene"}],
                                  pairMode: "exclude",
                                  pairMinPathLength: 2,
                                  nodePairs: {"ageingFactor": {"observation": true}, "bioSystem": {"ageingFactor": true}}];
      } else {
        networkData..edgeFilter = [maxPathLength: 4,
                                   filterExpression: "nodeType='ageingFactor' OR (nodeType='observation' AND lifespanEffectSignificant!='') or nodeType='species'" + filterExtension,
                                   stopConditions: [{"infoKey": "nodeType", "value": "species"}, {"infoKey": "nodeType", "value": "alleleType"}, {"infoKey": "nodeType", "value": "citation"}, {"infoKey": "nodeType", "value": "goTerm"}, {"infoKey": "nodeType", "value": "gene"}],
                                   pairMode: "exclude",
                                   pairMinPathLength: 2,
                                   nodePairs: {"ageingFactor": {"observation": true}, "bioSystem": {"ageingFactor": true}}];
      }
    } elseif (subsetType == "complete") {
      if (nodeInfo..ageingFactorType == "gene") {
        networkData..edgeFilter = [maxPathLength: 10000,
                                   filterExpression: "nodeType='ageingFactor' OR nodeType='observation'" + filterExtension,
                                   species: species,
                                   stopConditions: [{"infoKey": "nodeType", "value": "species"}, {"infoKey": "nodeType", "value": "alleleType"}, {"infoKey": "nodeType", "value": "citation"}, {"infoKey": "nodeType", "value": "goTerm"}, {"infoKey": "nodeType", "value": "gene"}]];
      } else {
        networkData..edgeFilter = [maxPathLength: 10000,
                                   filterExpression: "nodeType='ageingFactor' OR nodeType='observation' or nodeType='species'" + filterExtension,
                                   species: species,
                                   speciesFree: ["alleleType", "citation"],
                                   stopConditions: [{"infoKey": "nodeType", "value": "species"}, {"infoKey": "nodeType", "value": "alleleType"}, {"infoKey": "nodeType", "value": "citation"}, {"infoKey": "nodeType", "value": "goTerm"}, {"infoKey": "nodeType", "value": "gene"}]];
      }
    } else {
    }
    buildSubset(networkData);

    #######################    
    var subnetworkSize = networkData..subsets.[networkData..currentSubsetKey]..nodeInfo.size;
    if (subnetworkSize > 1) {
      subsetFileNumber++;
      # Determine nodeNumber of central ageing factor
      var centralNodeInfo = getNodeInfo(nodeId);
      var nodeNumber = 0;
      var nodeSubType       = nodeInfo..nodeSubType;

      networkData..subsets.[networkData..currentSubsetKey]..subsetType = "standard"; 
      networkData..subsets.[networkData..currentSubsetKey]..centralNodeInfo = centralNodeInfo;
      if (centralNodeInfo.type == "hash") {
        if (centralNodeInfo..nodeNumber > 0) {
          nodeNumber = centralNodeInfo..nodeNumber;
        }
      }
    
      networkData..importFormat = "coordinateTSV";
      networkData..importFilename = "data/agefactdb-" + networkData..currentSubsetKey + "-coordinates.txt";
      networkData..importSubsetKey = networkData..currentSubsetKey;
      networkData..importCoordinateScalingFactor = 1.0;
      importSubsetCoordinates(networkData);
    
      # Convert into molecular format and visualize
      buildMmcifData(networkData);
      mmcifData = networkData..subsets.[networkData..currentSubsetKey]..mmcifData;
      load APPEND "@mmcifdata" FILTER "addBonds";
      frame ID @{networkData..currentSubsetKey};
      setScale({"node": 4, "edge": 0.04, "frameSize": 50});
      var currentFontscaling = fontScaling;
      set fontscaling off;
      setLabel([nodeInfo: networkData..subsets.[networkData..currentSubsetKey]..nodeInfo, action: "hide"]);
      set fontScaling @currentFontscling;
    
      labelMessage = networkData..subsets.[networkData..currentSubsetKey]..nodeInfo.[nodeKey]..labelCustom;
      logMsg([level: "info", msg: labelMessage]);
    
      select [ALT_ALT]; label display;
      select ([OB_INC] OR [OB_DEC]) and temperature=0; halo on;
    
      initDisplay(layoutOptions);
    
      # Build layout
      if (skipLayout) {
        logMsg([level: "info", msg: "skipped layout generation"]);
      } else {
        var buildNodes = {all};
        buildLayout(buildNodes, layoutOptions);
      }

      # Store new coordinates in mmCIF data
      #buildMmcifData(networkData);
      #mmcifData = networkData..subsets.[networkData..currentSubsetKey]..mmcifData;
    
      storeCoordinates(networkData)
      networkData..exportSubset = networkData..currentSubsetKey;
      networkData..exportFilename = "data/agefactdb-" + networkData..currentSubsetKey + "-coordinates.txt";
      networkData..exportFormat = "coordinateTSV";
    #  exportSubset(networkData);
    
      if (nodeNumber > 0) {
        select file=@subsetFileNumber AND atomno=@nodeNumber; label display;
      }      
      setSizeByChange("node", 0.05, {[OB_INC] OR [OB_DEC] OR [OB_NON]});
      setScale({"node": 4, "edge": 0.04, "frameSize": 50});
      select all;
      adjustEdgeLength(0.4);
      color bonds translucent 4;
    
      # window size: 600x600
    
      # Set orientation
      center all;
      rotate best;
      #
      # ### Zoom ###
      zoom 0;
    
      initHover;
      if (networkData..subsets.[networkData..currentSubsetKey].type == "hash") {
        networkData..subsets.[networkData..currentSubsetKey]..storedOrientation = script("show orientation").split("#").[1];    
        networkData..subsets.[networkData..currentSubsetKey]..storedSelection = {all};    
      }
      javascriptCommand = "last_model=" + subsetFileNumber + "; document.getElementById('subset_count').innerHTML = '" + subsetFileNumber + "'; subset_names.push('" + networkData..currentSubsetKey + "');";
      javascript @javascriptCommand;

      #############
      var extraNodeTypeStringExtended = extraNodeTypeString;
      if (nodeSubType != "gene") {
        if (!speciesIncluded) {
          if (extraNodeTypeString == "") {
            extraNodeTypeStringExtended = "species";
          } else {
            extraNodeTypeStringExtended = extraNodeTypeString + "||" + "species";
          }
        }
      }
      var optionExtension = " (" + subsetType + " + " + extraNodeTypeStringExtended.replace("||", " + ") + ")";
      var subsetName = networkData..currentSubsetKey;
      if (extraNodeTypeString == "") {
        optionExtension = " (" + subsetType + ")";
      }
      if (nodeSubType == "gene") {
        subsetName =  nodeName + ' ' + speciesShortcut2 + ' - ' + nodeId + optionExtension + subsetNameExtension;
      } else {
        subsetName = nodeName + ' - ' + nodeId + optionExtension + subsetNameExtension;
      }
      networkData..subsets.[networkData..currentSubsetKey]..subsetName = subsetName;
      optionHtml = '<option value="' + subsetKey + '">' + subsetName + '</option>';
  
      if (subsetFileNumber == 1) {
        var x = javascript("document.getElementById('displaysubset_menu').innerHTML = '" + optionHtml + "';");
      } else {
        var x = javascript("document.getElementById('displaysubset_menu').innerHTML = document.getElementById('displaysubset_menu').innerHTML + '" + optionHtml + "';");
      }
      javascriptCommand = "idbSetSelected(document.getElementById('displaysubset_menu'), '" + networkData..currentSubsetKey + "'); subsetKeyToName['" + networkData..currentSubsetKey + "']='" + subsetName + "'; $('#page_name').text('" + subsetName + "'); menu_state['displaysubset_menu'] = '" + networkData..currentSubsetKey + "';";
      javascript @javascriptCommand;
      var timeMessage = " (time=" + format("%.1f", now(startTime) / 1000) + " sec)";
      logMsg([level: "info", msg: "finished building subset '" + networkData..currentSubsetKey + "'" + timeMessage]);
  
    } else {
      logMsg([level: "info", msg: "   no network data found for ageing factor '" +  name + " " + species + " - " + nodeId + "' - NO SUBSET GENERATED"]);
    }
    } elseif (ation == "delete") {
      # NOT IMPLEMENTED YET
    }

  }
    
}

function storeCoordinates(dataHashref) {   # store current 'molecular' coordinates into 'raw' node info
  var msg            = "";
  var subset         = {};
  var subsetKey      = "";
  var nodeInfo       = {};
  var nodeNumberToNodeKey = {};

  # Check required parameters
  if (dataHashref.type != "hash") {
    msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED in call of method 'storeCoordinates'\n";
  } else {
    if (dataHashref..subsets.type != "hash") {
      msg = msg + "ERROR: subhash 'dataHashref..subsets' NOT PROVIDED in call of method 'storeCoordinates'\n";
    } else {
      if (dataHashref..currentSubsetKey == "") {
        dataHashref..currentSubsetKey = "full";
      }
      subsetKey = dataHashref..currentSubsetKey;

      if (dataHashref..subsets.[subsetKey].type != "hash") {
        msg = msg + "ERROR: subset '" + subsetKey + "' NOT FOUND in call of method 'storeCoordinates'\n";
      } else {
        subset = dataHashref..subsets.[subsetKey];
        if (subset..nodeInfo.type != "hash") {
          msg = msg + "ERROR: no 'nodeInfo' subhash provided for subset '" + subsetKey + "' in call of method 'storeCoordinates'\n";
        } else {
          nodeInfo = subset..nodeInfo;
        }
        if (subset..nodeNumberToNodeKey.type != "hash") {
          msg = msg + "ERROR: no 'nodeNumberToNodeKey' subhash provided for subset '" + subsetKey + "' in call of method 'storeCoordinates'\n";
        } else {
          nodeNumberToNodeKey = subset..nodeNumberToNodeKey;
        }
      }
    }
  }

  nodeCount = nodeInfo.size;
  logMsg([level: "info", msg: "   started storing ccordinates of subset '" + subsetKey + "' with " + nodeCount + " nodes..."]);
  if (msg != "") {
    logMsg({"level": "mixed", "msg": msg});
    return;
  }

  if (nodeCount > 0) {
    var skippedCount = 0;
    for (var nodeKey in nodeInfo) {
      var currentNodeInfo = nodeInfo[nodeKey];
      var nodeNumber = currentNodeInfo..nodeNumber;
      if (nodeNumber > 0) {
        currentNodeInfo..x = {atomno=@nodeNumber}.x;
        currentNodeInfo..y = {atomno=@nodeNumber}.y;
        currentNodeInfo..z = {atomno=@nodeNumber}.z;
      } else {
        skippedCount++;
      }
    }
  }
  logMsg([level: "info", msg: "   finished storing ccordinates of  " + nodeCount + " nodes (skipped: " + skippedCount + ") of subset '" + subsetKey + "'"]);
}

function restoreCoordinates(dataHashref) {   # restore 'molecular' coordinates from 'raw' node info
  var msg            = "";
  var subset         = {};
  var subsetKey      = "";
  var nodeInfo       = {};
  var nodeNumberToNodeKey = {};

  # Check required parameters
  if (dataHashref.type != "hash") {
    msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED in call of method 'storeCoordinates'\n";
  } else {
    if (dataHashref..subsets.type != "hash") {
      msg = msg + "ERROR: subhash 'dataHashref..subsets' NOT PROVIDED in call of method 'storeCoordinates'\n";
    } else {
      if (dataHashref..currentSubsetKey == "") {
        dataHashref..currentSubsetKey = "full";
      }
      subsetKey = dataHashref..currentSubsetKey;

      if (dataHashref..subsets.[subsetKey].type != "hash") {
        msg = msg + "ERROR: subset '" + subsetKey + "' NOT FOUND in call of method 'storeCoordinates'\n";
      } else {
        subset = dataHashref..subsets.[subsetKey];
        if (subset..nodeInfo.type != "hash") {
          msg = msg + "ERROR: no 'nodeInfo' subhash provided for subset '" + subsetKey + "' in call of method 'storeCoordinates'\n";
        } else {
          nodeInfo = subset..nodeInfo;
        }
        if (subset..nodeNumberToNodeKey.type != "hash") {
          msg = msg + "ERROR: no 'nodeNumberToNodeKey' subhash provided for subset '" + subsetKey + "' in call of method 'storeCoordinates'\n";
        } else {
          nodeNumberToNodeKey = subset..nodeNumberToNodeKey;
        }
      }
    }
  }

  nodeCount = nodeInfo.size;
  logMsg([level: "info", msg: "   started restoring ccordinates of subset '" + subsetKey + "' with " + nodeCount + " nodes..."]);
  if (msg != "") {
    logMsg({"level": "mixed", "msg": msg});
    return;
  }

  if (nodeCount > 0) {
    var skippedCount = 0;
    for (var nodeKey in nodeInfo) {
      var currentNodeInfo = nodeInfo[nodeKey];
      var nodeNumber = currentNodeInfo..nodeNumber;
      if (nodeNumber > 0) {
        {atomno=@nodeNumber}.x = currentNodeInfo..x;
        {atomno=@nodeNumber}.y = currentNodeInfo..y;
        {atomno=@nodeNumber}.z = currentNodeInfo..z;
      } else {
        skippedCount++;
      }
    }
  }
  logMsg([level: "info", msg: "   finished restoring ccordinates of  " + nodeCount + " nodes (skipped: " + skippedCount + ") of subset '" + subsetKey + "'"]);
}

function exportSubset(dataHashref) {
  var msg            = "";
  var exportFormat   = "";
  var exportFilename = "";
  var exportTarget   = "file";
  var subset         = {};
  var subsetKey      = "";
  var edgeInfo       = {};
  var nodeInfo       = {};
  var nodeKeysFound  = {};
  var nodeCount      = 0;
  var edgeCount      = 0;

  # Check required parameters
  if (dataHashref.type != "hash") {
    msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED in call of method 'exportSubset'\n";
  } else {
    if (dataHashref..exportFormat == "") {
      msg = msg + "ERROR: parameter 'dataHashref..exportFormat' NOT PROVIDED in call of method 'exportSubset'\n"; 
    } else {
      exportFormat = dataHashref..exportFormat;
    }
    if (dataHashref..exportFilename == "") {
      msg = msg + "ERROR: parameter 'dataHashref..exportFilename' NOT PROVIDED in call of method 'exportSubset'\n"; 
    } else {
      exportFilename = dataHashref..exportFilename;
    }
    if (dataHashref..exportTarget != "") {
      exportTarget = dataHashref..exportTarget;
    }
    if (dataHashref..subsets.type != "hash") {
      msg = msg + "ERROR: subhash 'dataHashref..subsets' NOT PROVIDED in call of method 'exportSubset'\n";
    } else {
      if (dataHashref..exportSubsetKey == "") {
        if (networkData..currentSubsetKey == "") {
          dataHashref..currentSubsetKey = "full";
        } else {
          dataHashref..currentSubsetKey = networkData..currentSubsetKey;
        }
        subsetKey = dataHashref..currentSubsetKey;
      } else {
        subsetKey = dataHashref..exportSubsetKey;
      }
      if (dataHashref..subsets.[subsetKey].type != "hash") {
        msg = msg + "ERROR: subset '" + subsetKey + "' NOT FOUND in call of method 'exportSubset'\n";
      } else {
        subset = dataHashref..subsets.[subsetKey];
        if (subset..edgeInfo.type != "hash") {
          msg = msg + "ERROR: no 'edgeInfo' subhash provided for subset '" + subsetKey + "' in call of method 'exportSubset'\n";
        } else {
          edgeInfo = subset..edgeInfo;
        }
        if (subset..nodeInfo.type != "hash") {
          msg = msg + "ERROR: no 'nodeInfo' subhash provided for subset '" + subsetKey + "' in call of method 'exportSubset'\n";
        } else {
          nodeInfo = subset..nodeInfo;
          
        }
      }
    }
  }

  nodeCount = nodeInfo.size;
  edgeCount = edgeInfo.size;  
  logMsg([level: "info", msg: "   started exporting subset '" + subsetKey + "' with " + nodeCount + " nodes in format '" + exportFormat + "'..."]);
  if (msg != "") {
    logMsg({"level": "mixed", "msg": msg});
    return;
  }

  if (exportFilename != "") {
    var exportDataLines = [];
    if (exportFormat == "pairTSV") {
      if (edgeCount > 0) {
        for (var edgeKey in edgeInfo) {
          var nodeKey1 = edgeInfo[edgeKey]..nodeKey1;
          var nodeKey2 = edgeInfo[edgeKey]..nodeKey2;
          var lineData = '"' + nodeKey1 + '"\t"' + nodeKey2 + '"';
          exportDataLines.push(lineData);
          nodeKeysFound[nodeKey1]++;
          nodeKeysFound[nodeKey2]++;
        }
      }
    } elseif (exportFormat == "TGF") {
      exportDataLines.push("#");
      if (edgeCount > 0) {
        for (var edgeKey in edgeInfo) {
          var nodeKey1 = edgeInfo[edgeKey]..nodeKey1;
          var nodeKey2 = edgeInfo[edgeKey]..nodeKey2;
          var lineData = '"' + nodeKey1 + '"\t"' + nodeKey2 + '"';
          exportDataLines.push(lineData);
          nodeKeysFound[nodeKey1]++;
          nodeKeysFound[nodeKey2]++;
        }
      }
    } elseif (exportFormat == "coordinateTSV") {
      exportDataLines.push(["nodeKey", "x", "y", "z"].join("\t"));
      if (nodeCount > 0) {
        for (var nodeKey in nodeInfo) {
          var currentNodeInfo = nodeInfo[nodeKey];
          var lineData = [nodeKey, currentNodeInfo..x, currentNodeInfo..y, currentNodeInfo..z].join("\t");
          exportDataLines.push(lineData);
        }
      }
    } elseif (exportFormat == "XGMML") {
      var headerLines = ['<?xml version="1.0" encoding="UTF-8" standalone="yes"?>'];
      headerLines.push('<graph label="' + subsetKey + '"');
      headerLines.push('  xmlns:dc="http://purl.org/dc/elements/1.1/"');
      headerLines.push('  xmlns:xlink="http://www.w3.org/1999/xlink"');
      headerLines.push('  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"');
      headerLines.push('  xmlns:cy="http://www.cytoscape.org"');
      headerLines.push('  xmlns="http://www.cs.rpi.edu/XGMML"');
      headerLines.push('  directed="0">');
      exportDataLines.push(headerLines.join("\n"));

      if (nodeCount > 0) {
        for (var nodeKey in nodeInfo) {
          var currentNodeInfo = nodeInfo[nodeKey];
          var nodeLabel       = currentNodeInfo..nodeId;
          var nodeId          = currentNodeInfo..nodeNumber;
          var x               = currentNodeInfo..x;
          var y               = currentNodeInfo..y;
          var z               = currentNodeInfo..z;
          var lineData        = '  <node label="' + nodeLabel + '" id="' + nodeId + '">';
          exportDataLines.push(lineData);
          for (var infoKey IN currentNodeInfo) {
            var value    = currentNodeInfo.[infoKey].replace('"',"'",true);
            var lineData = '    <att name="' + infoKey + '" type="string" value="' + value + '"/>';
	    exportDataLines.push(lineData);
	  }
          exportDataLines.push("  </node>'");
        }
      }

      if (edgeCount > 0) {
        for (var edgeKey in edgeInfo) {
          var currentEdgeInfo = edgeInfo[edgeKey];
          var nodeKey1        = currentEdgeInfo..nodeKey1;
          var nodeKey2        = currentEdgeInfo..nodeKey2;
          var edgeLabel       = nodeKey1 + "%%" + nodeKey2;
          var sourceId        = currentEdgeInfo..nodeNumber1;
          var targetId        = currentEdgeInfo..nodeNumber2;
          var lineData        = '  <edge label="' + edgeLabel + '" source="' + sourceId + '" target="' + targetId + '">';
          exportDataLines.push(lineData);
          for (var infoKey IN currentEdgeInfo) {
            var value    = currentEdgeInfo.[infoKey].replace('"',"'",true);
            var lineData = '    <att name="' + infoKey + '" type="string" value="' + value + '"/>';
	    exportDataLines.push(lineData);
	  }
          exportDataLines.push("  </edge>'");
          nodeKeysFound[nodeKey1]++;
          nodeKeysFound[nodeKey2]++;
        }
      }

      exportDataLines.push('</graph>');
    } else {
      logMsg([level: "error", msg: "unknown subset export format '" + exportFormat + "' in call of method 'exportSubset'"]);
    }

    if (exportFormat == "pairTSV" || exportFormat == "TGF") {
      # Check for missing disconnected 'singleton' nodes
      if (nodeKeysFound.size != nodeInfo.size) {
        for (var nodeKey in nodeInfo) {
          if (nodeKeysFound[nodeKey] == "") {
            var lineData = '"' + nodeKey + '"\t"dummyNode"';   # 'dummy' node needed for 'Biolayout Express3D' to prevent spreading 'singletons' as tiles
            exportDataLines.push(lineData);
          }
        }
      }
    }

    var exportData = exportDataLines.join("\n");

    if (exportTarget == "file") {
      write VAR exportData @exportFilename;
    } elseif (exportTarget == "stdout") {
      print exportData;
    } else {
      logMsg([level: "error", msg: "ERROR: undefined export target " + exportTarget + " in call of method 'exportSubset'\n"]);
    }
    
  } else {
    logMsg([level: "error", msg: "ERROR: export filename IS EMPTY in call of method 'exportSubset'\n"]); 
  }
}

function exportJson(typesLoaded) {  # export network data in JSON format for Javascript version, split into two parts because of 'out of memory' problem with network data including GO
  if (typesLoaded == "") {
    typesLoaded = networkData..typesLoaded;
  }

  if (typesLoaded != "") {
    var jsonData           = "";
    var path               = "jsnet3d/";
    var prefix             = "networkData-";
    var jsonFileMain       = path + prefix + typesLoaded + "-without_full_subset_edge_info.json";
    var jsonFileFullSubset = path + prefix + typesLoaded + "-full_subset_edge_info.json";

    networkData..subsets..full..mmcifData    = "";
    networkData..subsets..default..mmcifData = "";

    logMsg([level: "info", msg: "Exporting subset 'full' in JSON format to file '" + jsonFileFullSubset + "'..."]);
    jsonData = format("JSON",networkData..subsets..full..edgeInfo);
    write var jsonData @jsonFileFullSubset;

    logMsg([level: "info", msg: "Exporting network data without subset 'full' in JSON format to file '" + jsonFileMain + "'..."]);
    var fullSubset = networkData..subsets..full..edgeInfo;
    networkData..subsets..full..edgeInfo = {};
    jsonData = format("JSON",networkData);
    write var jsonData @jsonFileMain;
    networkData..subsets..full..edgeInfo = fullSubset;
  } else {
    logMsg([level: "error", msg: "could NOT DETERMINE export file names (missing info about loaded network data)"]);
  }
}

function exportMmcif(typesLoaded) {  # export 'molecular' network data in MMCIF format
  if (typesLoaded == "") {
    typesLoaded = networkData..typesLoaded;
  }

  if (typesLoaded != "") {
    var mmcifData              = "";
    var path                   = "jsnet3d/";
    var prefix                 = "janet-";
    var mmcifFileDefaultSubset = path + prefix + typesLoaded + "-default.mmcif";
    var mmcifFileFullSubset    = path + prefix + typesLoaded + "-full.mmcif";
    var storedSubsetKey        = networkData..currentSubsetKey;

    networkData..subsets..default..mmcifData = "";

    logMsg([level: "info", msg: "Exporting subset 'full' in MMCIF format to file '" + mmcifFileFullSubset + "'..."]);
    networkData..currentSubsetKey = "full";
    buildMmcifData(networkData);
    mmcifData = networkData..subsets.[networkData..currentSubsetKey]..mmcifData;
    write var mmcifData @mmcifFileFullSubset;
    networkData..subsets..full..mmcifData    = "";

    logMsg([level: "info", msg: "Exporting subset 'default' in MMCIF format to file '" + mmcifFileDefaultSubset + "'..."]);
    networkData..currentSubsetKey = "default";
    buildMmcifData(networkData);
    mmcifData = networkData..subsets.[networkData..currentSubsetKey]..mmcifData;
    write var mmcifData @mmcifFileDefaultSubset;
    networkData..subsets..default..mmcifData    = "";

    networkData..currentSubsetKey = storedSubsetKey;
  } else {
    logMsg([level: "error", msg: "could NOT DETERMINE export file names (missing info about loaded network data)"]);
  }
}


function importSubsetCoordinates(dataHashref) {
  var msg            = "";
  var importFormat   = "";
  var importFilename = "";
  var subset         = {};
  var subsetKey      = "";
  var assignedCount  = 0;
  var skippedCount   = 0;
  var nodeCount      = 0;
  var nodeInfo       = {};
  var scalingFactor  = 0.1;   # must be provided as decimal number (with dot)
  var applyCoordinates = true;

  # Check required parameters
  if (dataHashref.type != "hash") {
    msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED in call of method 'importSubsetCoordinates'\n";
  } else {
    if (dataHashref..importFormat == "") {
      msg = msg + "ERROR: parameter 'dataHashref..importFormat' NOT PROVIDED in call of method 'importSubsetCoordinates'\n"; 
    } else {
      importFormat = dataHashref..importFormat;
    }
    if (dataHashref..importFilename == "") {
      msg = msg + "ERROR: parameter 'dataHashref..importFilename' NOT PROVIDED in call of method 'importSubsetCoordinates'\n"; 
    } else {
      importFilename = dataHashref..importFilename;
    }
    if (dataHashref..importCoordinateScalingFactor != "") {
      scalingFactor = 1.0 * dataHashref..importCoordinateScalingFactor;   # multiplication with '1.0' as first factor ensures that the scalingFactor is decimal
    } else {
      dataHashref..importCoordinateScalingFactor = scalingFactor;
    }
    if (dataHashref..importApplyCoordinates.type == "boolean") {
      applyCoordinates = dataHashref..importApplyCoordinates;
    }
    if (dataHashref..subsets.type != "hash") {
      msg = msg + "ERROR: subhash 'dataHashref..subsets' NOT PROVIDED in call of method 'importSubsetCoordinates'\n";
    } else {
      if (dataHashref..importSubsetKey == "") {
        if (dataHashref..currentSubsetKey == "") {
          dataHashref..currentSubsetKey = "full";
        }
        subsetKey = dataHashref..currentSubsetKey;
      } else {
        subsetKey = dataHashref..importSubsetKey;
      }
      if (dataHashref..subsets.[subsetKey].type != "hash") {
        msg = msg + "ERROR: subset '" + subsetKey + "' NOT FOUND in call of method 'importSubsetCoordinates'\n";
      } else {
        subset = dataHashref..subsets.[subsetKey];
        if (subset..nodeInfo.type != "hash") {
          msg = msg + "ERROR: no 'nodeInfo' subhash provided for subset '" + subsetKey + "' in call of method 'importSubsetCoordinates'\n";
        } else {
          nodeInfo = subset..nodeInfo;
        }
      }
    }
  }

  nodeCount = nodeInfo.size;
  logMsg([level: "info", msg: "   started importing coordinates for subset '" + subsetKey + "' with " + nodeCount + " nodes in format '" + importFormat + "' from file '" + importFilename + "'..."]);
  if (msg != "") {
    logMsg({"level": "mixed", "msg": msg});
    return -1;
  }

  if (importFilename != "") {

    if (importFormat == "biolayout3d") {
      var importData   = load(importFilename).split("\t", true);
  
      if (importData.size > 0) {
        for (var i from [importData.size 1]) {
          var lineData       = importData[i];
          if (lineData[1] == "//NODECOORD") {
            var nodeKeyString = lineData[2];
            var nodeKey       = nodeKeyString.replace('"', '', true);
            var x             = lineData[3];
            var y             = lineData[4];
            var z             = lineData[5];
  
            if (nodeInfo[nodeKey].type == "hash") {
              nodeInfo[nodeKey]..x = scalingFactor * x;
              nodeInfo[nodeKey]..y = scalingFactor * y;
              nodeInfo[nodeKey]..z = scalingFactor * z;
              assignedCount++;
              if (applyCoordinates) {
                var nodeNumber = nodeInfo[nodeKey]..nodeNumber;
                var currentNode = {atomno=@nodeNumber};
                if (currentNode.size > 0) {
                  currentNode.x = nodeInfo[nodeKey]..x;
                  currentNode.y = nodeInfo[nodeKey]..y;
                  currentNode.z = nodeInfo[nodeKey]..z;
                }
              }
            } else {
              skippedCount++;
            }
          }
        }
      } else {
        logMsg([level: "warn", msg: "coordinate import file " + importFilename + " in format " + importFormat + " seems empty"]);
      }
    } elseif (importFormat == "coordinateTSV") {
      var importData   = load(importFilename).split("\t", true);
  
      if (importData.size > 0) {
        if (importData.type == "array") {
          # Convert header columns to lower key
          var headerData = importData[1];
          for (var i from [1 headerData.size]) {
            headerData[i] = changeCase(headerData[i], "lower");
          }

          # Convert into hash using first array row content (= header array) as hash keys
          importData = importData.format(headerData);

          for (var i from [2 importData.size]) {
            var nodeKey = importData[i]..nodekey;
            var x       = importData[i]..x;
            var y       = importData[i]..y;
            var z       = importData[i]..z;

            if (nodeKey != "") {
              if (nodeInfo[nodeKey].type == "hash") {
                if ([x] != [""] && [y] != [""] && [z] != [""]) {
                  nodeInfo[nodeKey]..x = scalingFactor * x;
                  nodeInfo[nodeKey]..y = scalingFactor * y;
                  nodeInfo[nodeKey]..z = scalingFactor * z;
                  assignedCount++;
                  if (applyCoordinates) {
                    var nodeNumber = nodeInfo[nodeKey]..nodeNumber;
                    var currentNode = {atomno=@nodeNumber};
                    if (currentNode.size > 0) {
                      currentNode.x = nodeInfo[nodeKey]..x;
                      currentNode.y = nodeInfo[nodeKey]..y;
                      currentNode.z = nodeInfo[nodeKey]..z;
                    }
                  }
                } else {
                  skippedCount++;
                }
              } else {
                skippedCount++;
              }
            } else {
              skippedCount++;
            }
          }
        }
      }
    } else {
      logMsg([level: "error", msg: "unknown import format '" + importFormat + "' in call of method 'importSubsetCoordinates'\n"]);
    }
    logMsg([level: "info", msg: "   finished importing coordinates of " + assignedCount + " nodes (skipped: " + skippedCount + ") from subset '" + subsetKey + "' in format '" + importFormat + "' from file '" + importFilename + "'"]);
  } else {
    logMsg([level: "error", msg: "ERROR: import filename IS EMPTY in call of method 'importSubsetCoordinates'\n"]); 
  }

  if (assignedCount != nodeCount) {
    if (assignedCount > 0) {
      logMsg([level: "warn", msg: "mismatch between node count (" + nodeCount + ") and imported coordinate count (" + assignedCount + ") in call of method importSubsetCoordinates"]);
    }
  }

  return assignedCount;
}

function getRawNeighbours(dataHashref) {
  var msg                = "";
  var nodeKey            = "";
  var parentNodeKey      = "";
  var newSubset          = {};
  var newNodeInfo        = {};
  var newEdgeInfo        = {};
  var neighbours         = {};
  var newNeighbours      = {};
  var nodeFilterNodeInfo = {};
  var edgeFilterNodeInfo = {};
  var baseNodeInfo       = {};
  var newEdgeKeysUsed    = {};
  var processedNodeKeys  = {};
  var maxPathLength      = 0;
  var filterNeighbours   = false;
  var stopConditions     = [];
  var stopConditionAvailable = false;
  var nodePairs          = {};
  var pairMode           = "exclude";
  var pairMinPathLength  = 1;
  var nodePairAvailable  = false;

  # Check required parameters
  if (dataHashref.type != "hash") {
    msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED in call of method 'getRawNeighbours'\n";
  } else {
    if (dataHashref..newSubset.type != "hash") {
      msg = msg + "ERROR: subhash 'dataHashref..newSubset' NOT PROVIDED in call of method 'getRawNeighbours'\n";
    } else {
      newSubset = dataHashref..newSubset;
    }
    if (dataHashref..baseNodeInfo.type != "hash") {
      msg = msg + "ERROR: subhash 'dataHashref..baseNodeInfo' NOT PROVIDED in call of method 'getRawNeighbours'\n";
    } else {
      baseNodeInfo = dataHashref..baseNodeInfo;
    }
    #if (dataHashref..nodeKey.type != "string") {
    #  msg = msg + "ERROR: string 'dataHashref..nodeKey' NOT PROVIDED in call of method 'getRawNeighbours'\n";
    #} else {
    #  nodeKey = dataHashref..nodeKey;
    #}
    if (dataHashref..edgeInfo.type != "hash") {
      msg = msg + "ERROR: subhash 'dataHashref..edgeInfo' NOT PROVIDED in call of method 'getRawNeighbours'\n";
    }
    if (dataHashref..neighbours.type != "hash") {
      msg = msg + "ERROR: subhash 'dataHashref..neighbours' NOT PROVIDED in call of method 'getRawNeighbours'\n";
    } else {
      neighbours = dataHashref..neighbours;
    }
    if ("" + dataHashref..maxPathLength == "") {
      logMsg([level: "info", msg: "  no path length limit set in call of method 'getRawNeighbours' - including all connected nodes\n"]);
      maxPathLength = dataHashref..baseNodeInfo.size;
    } else {
      maxPathLength = dataHashref..maxPathLength;
    }
    if (dataHashref..nodeFilterNodeInfo.type != "hash") {
      msg = msg + "ERROR: subhash 'dataHashref..nodeFilterNodeInfo' NOT PROVIDED in call of method 'getRawNeighbours'\n";
    } else {
      nodeFilterNodeInfo = dataHashref..nodeFilterNodeInfo;
    }

    if (dataHashref..edgeFilterNodeInfo.type == "hash") {
      edgeFilterNodeInfo = dataHashref..edgeFilterNodeInfo;
      filterNeighbours   = true;
    }
    #log "DEBUG: filterNeighbours=" + filterNeighbours;
    #log edgeFilterNodeInfo;

    if (dataHashref..stopConditions.type == "array") {
      if (dataHashref..stopConditions.size > 0) {
        stopConditionAvailable = true;
      }
    }

    if ("" + dataHashref..pairMinPathLength != "") {
      pairMinPathLength = dataHashref..pairMinPathLength;
      if (pairMinPathLength < 1) {
        pairMinPathLength = 1;
      }
    }

    if (dataHashref..nodePairs.type == "hash") {
      if (dataHashref..nodePairs.size > 0) {
        nodePairs = dataHashref..nodePairs;
        nodePairAvailable = true;
      }
    }

    if (dataHashref..pairMode != "") {
      pairMode = dataHashref..pairMode;
    }

    if (newSubset..nodeInfo.type != "hash") {
      newSubset..nodeInfo = {};
    }
    newNodeInfo = newSubset..nodeInfo;

    if (newSubset..edgeInfo.type != "hash") {
      newSubset..edgeInfo = {};
    }
    newEdgeInfo = newSubset..edgeInfo;

    if (newSubset..edgeKeysUsed.type != "hash") {
      newSubset..edgeKeysUsed = {};
    }
    newEdgeKeysUsed = newSubset..edgeKeysUsed;

    if (newSubset..neighbours.type != "hash") {
      newSubset..neighbours = {};
    }
    newNeighbours = newSubset..neighbours;
  }

  if (stopConditionAvailable) {
    stopConditionAvailable = false;   # check needed first
    if (dataHashref..stopConditions.size > 0) {
      for (var stopCondition in dataHashref..stopConditions) {
        if (stopCondition.type == "hash") {
          if (stopCondition..infoKey != "") {
            stopConditions.push(stopCondition);
            stopConditionAvailable = true;
          }
        } else {
          msg = msg + "ERROR: 'dataHashref..stopConditions' array elements must be hash references in call of method 'getRawNeighbours'\n";
        }
      }
    } else {
      #logMsg("  'stopConditions' array is empty in call of method 'getRawNeighbours'\n");
    }
  } else {
   #logMsg("  'stopConditions' parameter is not an array in call of method 'getRawNeighbours'\n");
  }

  if (msg != "") {
    logMsg({"level": "mixed", "msg": msg});
    return;
  }

  logMsg("  started getRawNeighbours with maxPathLength=" + maxPathLength + " ...");
  #log " pairMode=" + pairMode + "  nodePairs=" + nodePairs;

  if (nodeFilterNodeInfo.size > 0) {
    if (neighbours.size > 0) {
      var currentLevelNodeKeys = {};
      var nextLevelNodeKeys    = {};
      var lastLevelNodeKeys    = {};
      for (var nodeKey in nodeFilterNodeInfo) {
        currentLevelNodeKeys[nodeKey] = true;
      }
      var pathLength = 1;
      while (pathLength <= maxPathLength) {
        for (var nodeKey in currentLevelNodeKeys) {
          if (processedNodeKeys[nodeKey].type != "boolean") {   # avoid processing a node multiple times
            processedNodeKeys[nodeKey] = true
            # Determine new neighbours and build edge info
            if (neighbours[nodeKey].type == "hash") {
              if (neighbours[nodeKey].size > 0) {
                for (var neighbourNodeKey in neighbours[nodeKey]) {
                  var includeNeighbour = true;
                  if (neighbourNodeKey == nodeKey) {   # skip "backwards" edges to "parent" node
                    includeNeighbour = false;
                    #logMsg("    nodeKey=" + nodeKey + "  neighbour=" + neighbourNodeKey + "  include=" + includeNeighbour + " - backwards edge");
                  }
                  if (filterNeighbours) {
                    if (edgeFilterNodeInfo[neighbourNodeKey].type != "hash") {
		      #if (nodeFilterNodeInfo[neighbourNodeKey].type == "hash") {
                      includeNeighbour = false;
                      #logMsg("    nodeKey=" + nodeKey + "  neighbour=" + neighbourNodeKey + "  include=" + includeNeighbour + " - neighbour not in edgeFilterNodeInfo");
		      #}
                    }
                  }
                  #logMsg("    pathLength=" + pathLength + "  nodeKey=" + nodeKey + "  neighbour=" + neighbourNodeKey + "  include=" + includeNeighbour);
                  if (includeNeighbour) {
                    var edgeKey    = "" + nodeKey + "%%" + neighbourNodeKey;
                    var edgeKeyRev = "" + neighbourNodeKey + "%%" + nodeKey;

                    var skipEdge = false;
                    if (nodePairAvailable) {
                      var nodeType = baseNodeInfo[nodeKey]..nodeType;
                      if (nodePairs[nodeType].type == "hash") {
                        var neighbourNodeType = baseNodeInfo[neighbourNodeKey]..nodeType;
                        #logMsg("  checking nodePair (edge) -  pathLength=" + pathLength + "  pairMinPathLength=" + pairMinPathLength + "  nodeType='" + nodeType + "'  neighbourNodeType='" + neighbourNodeType + "' for node '" + nodeKey + "' and neighbour '" + neighbourNodeKey + "'");
                        if (nodePairs[nodeType].[neighbourNodeType] == true) {
                          #logMsg("    pair match - pairMode='" + pairMode + "'");
                          if (pairMode == "exclude") {
			    if (pathLength >= pairMinPathLength) {
			      skipEdge = true;
#logMsg("    nodeKey=" + nodeKey + "  neighbour=" + neighbourNodeKey + "  skipEdge=" + skipEdge + " - node pair match (edge) for nodeType='" + nodeType + "'  neighbourNodeType='" + neighbourNodeType + "'  pathLength=" + pathLength + " >= pairMinPathLength=" + pairMinPathLength + "  pairMode='" + pairMode + "'");
			    }
			  }
                        } else {
                          #logMsg("    no pair match - pairMode='" + pairMode + "'");
                          if (pairMode == "only") {
			    if (pathLength >= pairMinPathLength) {
			      skipEdge = true;
			    }
                          }
                        }
                      }
                    }


                    if (skipEdge == false) {
                      # Include node
                      if (filterNeighbours) {
                        newNodeInfo[neighbourNodeKey] = edgeFilterNodeInfo[neighbourNodeKey];
                      } else {
                        newNodeInfo[neighbourNodeKey] = dataHashref..baseNodeInfo[neighbourNodeKey];
                      }
                      #logMsg("skipEdge=false - checking edgeKey '" + edgeKey + "'  type='" + newEdgeKeysUsed.[edgeKey] + "'  revType='" + newEdgeKeysUsed.[edgeKeyRev] + "'");
                      
                      if (newEdgeKeysUsed.[edgeKey] == "") {
                        #logMsg("  edgeKey '" + edgeKey + "' not found - checking reverse '" + edgeKeyRev + "'");
                        if (newEdgeKeysUsed.[edgeKeyRev] == "") {
                          #logMsg("  reverse edgeKey '" + edgeKeyRev + "' not found - adding '" + edgeKey + "'");
                          var nodeKey1 = nodeKey;
                          var nodeKey2 = neighbourNodeKey;

                          # Include edge
                          newEdgeKeysUsed.[edgeKey]    = edgeKey;
                          newEdgeKeysUsed.[edgeKeyRev] = edgeKey;
                          newEdgeInfo[edgeKey] = {};
                          newEdgeInfo[edgeKey]..nodeKey1 = nodeKey;
                          newEdgeInfo[edgeKey]..nodeKey2 = neighbourNodeKey;

                          # Include neighbour
                          if (newNeighbours[nodeKey].type != "hash") {
                            newNeighbours[nodeKey] = {};
                          }
                          newNeighbours[nodeKey].[neighbourNodeKey] = true;
                          if (newNeighbours[neighbourNodeKey].type != "hash") {
                            newNeighbours[neighbourNodeKey] = {};
                          }
                          newNeighbours[neighbourNodeKey].[nodeKey] = true;
                        } else {
                          newEdgeKeysUsed.[edgeKey] = edgeKeyRev;
                        }
                      }

                      if (pathLength < maxPathLength) {
                        if (processedNodeKeys[neighbourNodeKey].type != "boolean") {   # skip already processed nodes
                          var skipNeighbour = false;
                          if (stopConditionAvailable) {
                            var skipNeighbour = false;
                            for (var stopCondition in stopConditions) {
                              var infoKey = stopCondition..infoKey;
                              var value   = stopCondition..value;
                              #logMsg("  checking stopCondition -  pathLength=" + pathLength + "  infoKey='" + infoKey + "'  value='" + value + "' for node '" + neighbourNodeKey + "'");
                              if ("" + baseNodeInfo[neighbourNodeKey].[infoKey] != "") {
                                if (baseNodeInfo[neighbourNodeKey].[infoKey] == value) {
                                  skipNeighbour = true;
                                  #logMsg("    nodeKey=" + nodeKey + "  neighbour=" + neighbourNodeKey + "  skipNeighbour=" + skipNeighbour + " - stop condition '" + infoKey + "'='" + value + "' matched");
                                }
                              }
                            }
                          }

                          if (skipNeighbour == false) {
                            if (nodePairAvailable) {
                              var nodeType = baseNodeInfo[nodeKey]..nodeType;
                              if (nodePairs[nodeType].type == "hash") {
                                var neighbourNodeType = baseNodeInfo[neighbourNodeKey]..nodeType;
                                #logMsg("  checking nodePair -  pathLength=" + pathLength + "  pairMinPathLength=" + pairMinPathLength + "  nodeType='" + nodeType + "'  neighbourNodeType='" + neighbourNodeType + "' for node '" + nodeKey + "' and neighbour '" + neighbourNodeKey + "'");
                                if (nodePairs[nodeType].[neighbourNodeType].type == "boolean") {
                                  #logMsg("    pair match - pairMode='" + pairMode + "'");
                                  if (pairMode == "exclude") {
				    if(pathLength >= pairMinPathLength) {
				      skipNeighbour = true;
#logMsg("    nodeKey=" + nodeKey + "  neighbour=" + neighbourNodeKey + "  skipNeighbour=" + skipNeighbour + " - node pair match for nodeType='" + nodeType + "'  neighbourNodeType='" + neighbourNodeType + "'  pathLength=" + pathLength + " >= pairMinPathLength=" + pairMinPathLength + "  pairMode='" + pairMode + "'");
				    }
				  }
			        } else {
                                  #logMsg("    no pair match - pairMode='" + pairMode + "'");
                                  if (pairMode == "only") {
				    if(pathLength >= pairMinPathLength) {
				      skipNeighbour = true;
#logMsg("    nodeKey=" + nodeKey + "  neighbour=" + neighbourNodeKey + "  skipNeighbour=" + skipNeighbour + " - node pair match for nodeType='" + nodeType + "'  neighbourNodeType='" + neighbourNodeType + "'  pathLength=" + pathLength + " >= pairMinPathLength=" + pairMinPathLength + "  pairMode='" + pairMode + "'");
				    }
				  }
                                }
                              }
                            }
                          }

                          if (skipNeighbour == false) {
                            nextLevelNodeKeys[neighbourNodeKey] = true;
                            #logMsg("    including neighbour '" + neighbourNodeKey + "'");
                          } else {
                            #logMsg("    skipping neighbour '" + neighbourNodeKey + "'");
                          }
                        }
                      }
                    } else {
                      #logMsg("     skipped edge '" + edgeKey + "'");
                    }
                  }
                }
              }
            }
          }
        }
        pathLength++;
        if (nextLevelNodeKeys.size > 0) {
          #lastLevelNodeKeys    = currentLevelNodeKeys;
          currentLevelNodeKeys = @nextLevelNodeKeys;
          nextLevelNodeKeys    = {};
        } else {
          break;
        }
      }
    }
  }

  # Transfer node properties from annotations to edge infos needed for mmCIF format
  for (var edgeKey in newEdgeInfo) {
    var currentEdgeInfo = newEdgeInfo.[edgeKey];
    var nodeKey1 = currentEdgeInfo..nodeKey1;
    var nodeKey2 = currentEdgeInfo..nodeKey2;
    var node1Info = newNodeInfo.[nodeKey1];
    var node2Info = newNodeInfo.[nodeKey2];

    currentEdgeInfo..subnetworkNumber  = node1Info..subnetworkNumber;   # should be identical for both nodes

    currentEdgeInfo..nodeTypeId1       = node1Info..nodeTypeId;
    currentEdgeInfo..nodeSubTypeId1    = node1Info..nodeSubTypeId;

    currentEdgeInfo..nodeTypeId2       = node2Info..nodeTypeId;
    currentEdgeInfo..nodeSubTypeId2    = node2Info..nodeSubTypeId;

    #log "========== currentEdgeInfo '" + edgeKey + "' =====================";
    #log currentEdgeInfo;
  }


  #logMsg("======== newNodeInfo (getRawNeighbours) start ===========");
  #log newSubset;
  #logMsg("======== newNodeInfo (getRawNeighbours) end ===========");
  #logMsg("======== newSubset (getRawNeighbours) start ===========");
  #log newSubset;
  #logMsg("======== newSubset (getRawNeighbours) end ===========");
  #logMsg("======= stopConditions =========");
  #log stopConditions;
  return newSubset;
}

function checkSpecies(dataHashref) {
  var msg             = "";
  var nodeInfo        = {};
  var speciesList     = [];
  var speciesProperty = "species";
  var nodeInfoType    = "single";
  var matchStatus     = false;
  var speciesFree     = ["goTerm", "citation", "alleleType"];
  var alwaysMatching  = {};
  var matchInfoKey    = "nodeId";
  var returnMode      = "";
  var resultNodeInfo  = {};

  #logMsg("running 'checkSpecies'...");

  # Check required and optional parameters
  if (dataHashref.type != "hash") {
    msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED in call of method 'checkSpecies'\n";
  } else {
    if (dataHashref..nodeInfo.type != "hash") {
      msg = msg + "ERROR: parameter 'dataHashref..nodeInfo' NOT PROVIDED in call of method 'checkSpecies'\n";
    } else {
      nodeInfo = dataHashref..nodeInfo;
    }
    if (dataHashref..speciesProperty != "") {
      speciesProperty = dataHashref..speciesProperty;
    }
    if (dataHashref..nodeInfoType != "") {
      nodeInfoType = dataHashref..nodeInfoType;
    }
    if (dataHashref..matchInfoKey != "") {
      matchInfoKey = dataHashref..matchInfoKey;
    }
    if (dataHashref..returnMode != "") {
      returnMode = dataHashref..returnMode;
    }
    if (dataHashref..species == "") {   # if no species provided all nodes automatically match (removes option to check for empty species but simplifies filtering)
      #msg = msg + "ERROR: parameter 'dataHashref..species' NOT PROVIDED in call of method 'checkSpecies'\n";
      return true;
    } else {
      if (dataHashref..species.type == "array") {
        speciesList = dataHashref..species;
      } elseif (dataHashref..species.type == "hash") {
        speciesList = dataHashref..species.keys;
      } elseif (dataHashref..species.type == "string") {
        speciesList.push(dataHashref..species);
      }
    }
    if (dataHashref..speciesFree.type == "array") {
      speciesFree = dataHashref..speciesFree;
    }
  }

  #print "  nodeInfoType=' " + nodeInfoType + "'  speciesList='" + speciesList.join("||") + "'";

  if (msg != "") {
    logMsg([level: "mixed", msg: msg]);
    return;
  }

  for (var nodeType IN speciesFree) {
    alwaysMatching[nodeType] = true;
  }

  if (nodeInfoType == "single") {
    var nodeType = nodeInfo..nodeType;
    if (alwaysMatching[nodeType] == true) {
      matchStatus    = true;
      resultNodeInfo = nodeInfo;
    } else {
      for (var species IN speciesList) {
        var speciesValues = [];
        var propertyType  = nodeInfo[speciesProperty].type;
        if (propertyType == "string") {
          speciesValues.push(nodeInfo[speciesProperty]);
        } elseif  (propertyType == "hash") {
          speciesValues = nodeInfo[speciesProperty].keys;
        } elseif  (propertyType == "array") {
          speciesValues = nodeInfo[speciesProperty];
        }
        for (var currentSpecies IN speciesValues) {
          if (currentSpecies == species) {
            matchStatus    = true;
	    resultNodeInfo = nodeInfo;
            break;
          }
       }
      }
    }
  } elseif (nodeInfoType == "multiple") {
    matchStatus  = {};
    for (var nodeKey IN nodeInfo) {
      var currentNodeInfo = nodeInfo[nodeKey];
      if (currentNodeInfo.type == "hash") {
        var matchKey = currentNodeInfo.[matchInfoKey];
        var nodeType = currentNodeInfo..nodeType;
        if (alwaysMatching[nodeType] == true) {
          matchStatus = true;
	  #print "DEBUG:  always matching '" + nodeType + "'\n";
	  if (returnMode == "nodeInfo") {
	    resultNodeInfo[nodeKey] = currentNodeInfo;
	  }
        } else {
          matchStatus[matchKey] = false;
          for (var species IN speciesList) {
            var speciesValues = [];
            var propertyType  = currentNodeInfo[speciesProperty].type;
            if (propertyType == "string") {
              speciesValues.push(currentNodeInfo[speciesProperty]);
            } elseif  (propertyType == "hash") {
              speciesValues = currentNodeInfo[speciesProperty].keys;
            } elseif  (propertyType == "array") {
              speciesValues = currentNodeInfo[speciesProperty];
            }
            #print "DEBUG:  ===== speciesValues (" + matchKey + ") =========\n";
	    #show speciesValues;
            for (var currentSpecies IN speciesValues) {
              if (currentSpecies == species) {
		#var logMessage = "DEBUG: matchKey='"+ matchKey + "'  currentSpecies='" + currentSpecies + "'\n";
                #print logMessage;
                matchStatus[currentNodeInfo.[matchInfoKey]] = true;
		if (returnMode == "nodeInfo") {
		  resultNodeInfo[nodeKey] = currentNodeInfo;
		}
                break;
              }
            }
          }
        }
      } else {
        logMsg([level: "warn", msg: "currentNodeInfo for nodeKey '" + nodeKey + "' is not a hash - IGNORING NODE"]);
      }
    }
  } else {
    logMsg([level: "error", msg: "unknown nodeInfoType '" + nodeInfoType + "' in call of method 'checkSpecies'"]);
  }

  if (returnMode == "nodeInfo") {
    return resultNodeInfo;
  } else {
    return matchStatus;
  }
}

function buildMmcifData(dataHashref) {
  var msg         = "";
  var mmcifData   = [];
  var mmcifDef    = {};
  var infoKeys    = {};
  var defaults    = {};
  var general     = {};
  var subset      = {};
  var subsetKey   = "";
  var subsetName  = "";
  var maxLineSize = 2048;
  var subParts    = {};

  subParts..atom = {"infoName": "nodeInfo", "numberToKeyName": "nodeNumberToNodeKey", "maxNumberName": "maxNodeNumber"};
  subParts..bond = {"infoName": "edgeInfo", "numberToKeyName": "edgeNumberToEdgeKey", "maxNumberName": "maxEdgeNumber"};

   subParts..atom..columns = ["atom_site.group_PDB", "atom_site.id", "atom_site.type_symbol", "atom_site.label_alt_id", "atom_site.pdbx_PDB_ins_code", "atom_site.Cartn_x", "atom_site.Cartn_y", "atom_site.Cartn_z", "atom_site.auth_seq_id", "atom_site.auth_comp_id", "atom_site.auth_asym_id", "atom_site.auth_atom_id", "atom_site.B_iso_or_equiv"];

  subParts..bond..columns = ["struct_conn.id", "struct_conn.conn_type_id", "struct_conn.ptnr1_auth_asym_id", "struct_conn.ptnr1_label_atom_id", "struct_conn.ptnr1_auth_comp_id", "struct_conn.ptnr1_auth_seq_id", "struct_conn.ptnr2_auth_asym_id", "struct_conn.ptnr2_label_atom_id", "struct_conn.ptnr2_auth_comp_id", "struct_conn.ptnr2_auth_seq_id"];

  # Check required parameters
  if (dataHashref.type != "hash") {
    msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED in call of method 'buildMmcif'\n";
  } else {
    if (dataHashref..subsets.type != "hash") {
      msg = msg + "ERROR: subhash 'dataHashref..subsets' NOT PROVIDED in call of method 'determineRawSubnetworks'\n";
    } else {
      if (dataHashref..currentSubsetKey == "") {
        dataHashref..currentSubsetKey = "full";
      }
      subsetKey = dataHashref..currentSubsetKey;
      if (dataHashref..currentSubsetName == "") {
        if (subsetKey == "") {
          dataHashref..currentSubsetName = "full";
        } else {
          dataHashref..currentSubsetName = subsetKey;
        }
      }
      subsetName = dataHashref..currentSubsetName;
      if (dataHashref..subsets.[subsetKey].type != "hash") {
        msg = msg + "ERROR: no subset subhash found for subset '" + subsetKey + "' in call of method 'determineRawSubnetworks'\n";
      } else {
        subset = dataHashref..subsets.[subsetKey];
        if (subset..nodeInfo.type != "hash") {
          msg = msg + "ERROR: subhash subset..nodeInfo' NOT PROVIDED in call of method 'buildMmcif'\n";
        }
        if (subset..edgeInfo.type != "hash") {
          msg = msg + "ERROR: subhash subset..edgeInfo' NOT PROVIDED in call of method 'buildMmcif'\n";
        }
        if (dataHashref..ioDefinitions.type != "hash") {
          msg = msg + "ERROR: subhash 'dataHashref..ioDefinitions' NOT PROVIDED in call of method 'buildMmcif'\n";
        } else {
          if (dataHashref..ioDefinitions..formats.type != "hash") {
            msg = msg + "ERROR: subhash 'dataHashref..ioDefinitions..formats' NOT PROVIDED in call of method 'buildMmcif'\n";
          } else {
            if (dataHashref..ioDefinitions..formats..mmcif.type != "hash") {
              msg = msg + "ERROR: subhash 'dataHashref..ioDefinitions..formats..mmcif' NOT PROVIDED in call of method 'buildMmcif'\n";
            } else {
              mmcifDef = dataHashref..ioDefinitions..formats..mmcif;   # shortcut for simpler access (by pointer)
              if (mmcifDef..general.type != "hash") {
                logMsg([level: "warn", msg: "subhash 'mmcifDef..general' NOT PROVIDED in call of method 'buildMmcif'\n"]);
              } else {
                general = mmcifDef..general;
                if (general..maxLineSize != "") {
                  maxLineSize = general..maxLineSize;
                }
              }
              if (mmcifDef..translations.type != "hash") {
                msg = msg + "ERROR: subhash 'mmcifDef..translations' NOT PROVIDED in call of method 'buildMmcif'\n";
              } else {
                if (mmcifDef..translations..infoKeys.type != "hash") {
                  msg = msg + "ERROR: subhash 'mmcifDef..translations..infoKeys' NOT PROVIDED in call of method 'buildMmcif'\n";
                } else {
                  infoKeys = mmcifDef..translations..infoKeys;   # shortcut for simpler access (by pointer)
                }
              }
              if (mmcifDef..defaults.type != "hash") {
                logMsg([level: "warn", msg: "subhash 'mmcifDef..defaults' NOT PROVIDED in call of method 'buildMmcif'\n"]);
              } else {
                defaults = mmcifDef..defaults;
              }
            }
          }
        }
      }
    }
  }
  if (msg != "") {
    logMsg([level: "error", msg: msg]);
    print msg;
    return;
  }

  # Build header part
  if (general..header != "") {
    mmcifData.push(general..header);
  }
  mmcifData.push("data_" + subsetName);
  mmcifData.push("");
  mmcifData.push("_database_PDB_rev.num 1");
  mmcifData.push("");

  # Build subparts
  for (var subPart in ["atom", "bond"]) {
    var columns       = subparts.[subPart]..columns;
    var infoName = subparts.[subPart]..infoName;
    var numberToKeyName = subparts.[subPart]..numberToKeyName;
    var maxNumberName   = subparts.[subPart]..maxNumberName;
    var info = subset.[infoName];
    mmcifData.push("loop_");
    for (var column in columns) {
      mmcifData.push("_" + column);
    }
    for (var entryNumber from [1 subset.[maxNumberName]]) {
      var entryKey = subset.[numberToKeyName].[entryNumber];
      var lineData = [];
      var lineSize = 0;
      var temperature = 0.0;
      var temperatureInfoKey = "";
      var entryInfo = info.[entryKey];

      if (entryInfo..temperatureInfoKey != "") {
        var temperatureInfoKey = entryInfo..temperatureInfoKey;
        if (entryInfo.[temperatureInfoKey] != "" || entryInfo.[temperatureInfoKey].type == "decimal" || entryInfo.[temperatureInfoKey].type == "integer") {
          temperature = entryInfo.[temperatureInfoKey];
        }
      }
      entryInfo..temperature = temperature;

      for (var column in columns) {
        var cData   = "?";
        var infoKey = "";
        if (infoKeys.[column] != "") {
          infoKey = infoKeys.[column];
        }
        if (entryInfo.[infoKey].type != "string") {
          cData = entryInfo.[infoKey];
        } elseif (entryInfo.[infoKey] != "") {
          cData = entryInfo.[infoKey];
        } elseif (defaults.[infoKey].type != "string") {
          cData = defaults.[infoKey];
        } elseif (defaults.[infoKey] != "") {
          cData = defaults.[infoKey];
        }
        if ((lineSize + cData.size) >= maxLineSize) {   # '>=' because of separating blank
          cData = cData + "\n";
          lineSize = cData.size + 1;
        } else {
          lineSize += cData.size + 1;
        }
        lineData.push(cData);
      }
      mmcifData.push(lineData.join(" "));
    }
  }

  subset..mmcifData = mmcifData.join("\n");
}

function buildHeatMap(dataHashref) {
  var msg         = "";
  var mmcifData   = [];
  var mmcifDef    = {};
  var infoKeys    = {};
  var defaults    = {};
  var general     = {};
  var subset      = {};
  var subsetKey   = "";
  var subsetName  = "";
  var maxLineSize = 2048;
  var subParts    = {};

  var heatMapDistanceX = 0.2;
  var heatMapDistanceY = 0.2;
  var heatMapDistanceZ = 0.1;
  var heatMapNodeCount = 141;
  var heatMapSampleCount = 5;

  subParts..atom = {"infoName": "nodeInfo", "numberToKeyName": "nodeNumberToNodeKey", "maxNumberName": "maxNodeNumber"};
  subParts..bond = {"infoName": "edgeInfo", "numberToKeyName": "edgeNumberToEdgeKey", "maxNumberName": "maxEdgeNumber"};

   subParts..atom..columns = ["atom_site.group_PDB", "atom_site.id", "atom_site.type_symbol", "atom_site.label_alt_id", "atom_site.pdbx_PDB_ins_code", "atom_site.Cartn_x", "atom_site.Cartn_y", "atom_site.Cartn_z", "atom_site.auth_seq_id", "atom_site.auth_comp_id", "atom_site.auth_asym_id", "atom_site.auth_atom_id", "atom_site.B_iso_or_equiv"];

  subParts..bond..columns = ["struct_conn.id", "struct_conn.conn_type_id", "struct_conn.ptnr1_auth_asym_id", "struct_conn.ptnr1_label_atom_id", "struct_conn.ptnr1_auth_comp_id", "struct_conn.ptnr1_auth_seq_id", "struct_conn.ptnr2_auth_asym_id", "struct_conn.ptnr2_label_atom_id", "struct_conn.ptnr2_auth_comp_id", "struct_conn.ptnr2_auth_seq_id"];

  # Check required parameters
  if (dataHashref.type != "hash") {
    msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED in call of method 'buildMmcif'\n";
  } else {
    if (dataHashref..subsets.type != "hash") {
      msg = msg + "ERROR: subhash 'dataHashref..subsets' NOT PROVIDED in call of method 'determineRawSubnetworks'\n";
    } else {
      if (dataHashref..currentSubsetName == "") {
        dataHashref..currentSubsetName = "NONAME";
      }
      if (dataHashref..currentSubsetKey == "") {
        dataHashref..currentSubsetKey = "full";
      }
      subsetKey = dataHashref..currentSubsetKey;
      if (dataHashref..subsets.[subsetKey].type != "hash") {
        msg = msg + "ERROR: no subset subhash found for subset '" + subsetKey + "' in call of method 'determineRawSubnetworks'\n";
      } else {
        subset = dataHashref..subsets.[subsetKey];
        if (subset..nodeInfo.type != "hash") {
          msg = msg + "ERROR: subhash subset..nodeInfo' NOT PROVIDED in call of method 'buildMmcif'\n";
        }
        if (subset..edgeInfo.type != "hash") {
          msg = msg + "ERROR: subhash subset..edgeInfo' NOT PROVIDED in call of method 'buildMmcif'\n";
        }
        if (dataHashref..ioDefinitions.type != "hash") {
          msg = msg + "ERROR: subhash 'dataHashref..ioDefinitions' NOT PROVIDED in call of method 'buildMmcif'\n";
        } else {
          if (dataHashref..ioDefinitions..formats.type != "hash") {
            msg = msg + "ERROR: subhash 'dataHashref..ioDefinitions..formats' NOT PROVIDED in call of method 'buildMmcif'\n";
          } else {
            if (dataHashref..ioDefinitions..formats..mmcif.type != "hash") {
              msg = msg + "ERROR: subhash 'dataHashref..ioDefinitions..formats..mmcif' NOT PROVIDED in call of method 'buildMmcif'\n";
            } else {
              mmcifDef = dataHashref..ioDefinitions..formats..mmcif;   # shortcut for simpler access (by pointer)
              if (mmcifDef..general.type != "hash") {
                logMsg([level: "warn", msg: "WARNING: subhash 'mmcifDef..general' NOT PROVIDED in call of method 'buildMmcif'\n"]);
              } else {
                general = mmcifDef..general;
                if (general..maxLineSize != "") {
                  maxLineSize = general..maxLineSize;
                }
              }
              if (mmcifDef..translations.type != "hash") {
                msg = msg + "ERROR: subhash 'mmcifDef..translations' NOT PROVIDED in call of method 'buildMmcif'\n";
              } else {
                if (mmcifDef..translations..infoKeys.type != "hash") {
                  msg = msg + "ERROR: subhash 'mmcifDef..translations..infoKeys' NOT PROVIDED in call of method 'buildMmcif'\n";
                } else {
                  infoKeys = mmcifDef..translations..infoKeys;   # shortcut for simpler access (by pointer)
                }
              }
              if (mmcifDef..defaults.type != "hash") {
                logMsg([level: "warn", msg: "subhash 'mmcifDef..defaults' NOT PROVIDED in call of method 'buildMmcif'\n"]);
              } else {
                defaults = mmcifDef..defaults;
              }
            }
          }
        }
      }
    }
    if (dataHashref..heatMapDistanceX !="") {
      heatMapDistanceX = dataHashref..heatMapDistanceX;
    }
    if (dataHashref..heatMapDistanceY !="") {
      heatMapDistanceY = dataHashref..heatMapDistanceY;
    }
    if (dataHashref..heatMapDistanceZ !="") {
      heatMapDistanceZ = dataHashref..heatMapDistanceZ;
    }
    if (dataHashref..heatMapNodeCount !="") {
      heatMapNodeCount = dataHashref..heatMapNodeCount;
    }
    if (dataHashref..heatMapSampleCount !="") {
      heatMapSampleCount = dataHashref..heatMapSampleCount;
    }
  }
  if (msg != "") {
    logMsg([level: "error", msg: msg]);
    return;
  }

  # #### GENERATE FAKE DATA FOR TEST ####
  subset = [nodeNumberToNodeKey: {}, edgeNumberToEdgeKey: {}, nodeInfo: {}, edgeInfo: {}];
  var initRandom = random(0,1,1234567890);
  var maxK = heatMapSampleCount * heatMapDistanceZ;
  var maxJ = heatMapNodeCount * heatMapDistanceX;
  var maxI = heatMapNodeCount * heatMapDistanceY;
  var nodeNumber   = 0;
  var sampleNumber = 0;
  for (var k=0; k<maxK; k+=heatMapDistanceZ) {
    sampleNumber++;
    var sampleId = "sample_" + sampleNumber;
    var geneNumber = 0;
    for (var i=0; i<maxI; i+=heatMapDistanceY) {
      for (var j=0; j<maxJ; j+=heatMapDistanceX) {
        nodeNumber++;
        geneNumber++;
        var nodeId = "node_" + nodeNumber;
        var geneId   = "gene_" + geneNumber;
        var nodeKey = geneId + "||" + sampleId;
        var x = j;
        var y = i;
        var z = k;
        var value = random(-1, 1);
        subset..nodeNumberToNodeKey[nodeNumber] = nodeKey;
        subset..nodeInfo.[nodeKey] = {};
        subset..nodeInfo.[nodeKey].nodeKey = nodeKey;
        subset..nodeInfo.[nodeKey].nodeId  = nodeId;
        subset..nodeInfo.[nodeKey].ageingFactorType = "gene";
        subset..nodeInfo.[nodeKey].ageingFactorName = geneId;
        subset..nodeInfo.[nodeKey].nodeSubType = "gene";
        subset..nodeInfo.[nodeKey].nodeSubTypeId = "AF_GEN";
        subset..nodeInfo.[nodeKey].nodeType = "ageingFactor";
        subset..nodeInfo.[nodeKey].nodeTypeId = "F";
        subset..nodeInfo.[nodeKey].species = "Saccharomyces cerevisiae" ;
        subset..nodeInfo.[nodeKey].geneId = geneId;
        subset..nodeInfo.[nodeKey].sampleId = sampleId;
        subset..nodeInfo.[nodeKey].subnetworkNumber = geneNumber;
        subset..nodeInfo.[nodeKey].labelShort = "" + geneId + "," + sampleId;
        subset..nodeInfo.[nodeKey].labelLong = "" + geneId + "," + sampleId + " (#" + nodeNumber + ", " + format("%.1f", value) + ")";
        subset..nodeInfo.[nodeKey].labelHover = labelLong;
        subset..nodeInfo.[nodeKey].temperatureInfoKey = "heatMapValue";
        subset..nodeInfo.[nodeKey].heatMapValue = value;
        subset..nodeInfo.[nodeKey].x = x;
        subset..nodeInfo.[nodeKey].y = y;
        subset..nodeInfo.[nodeKey].z = z;
      }
    }
  }
  subset..maxNodeNumber = nodeNumber;
  subset..maxEdgeNumber = 0;

  # Build header part
  if (general..header != "") {
    mmcifData.push(general..header);
  }
  mmcifData.push("data_" + subsetName);
  mmcifData.push("");
  mmcifData.push("_database_PDB_rev.num 1");
  mmcifData.push("");

  # Build subparts
  for (var subPart in ["atom", "bond"]) {
    var columns       = subparts.[subPart]..columns;
    var infoName = subparts.[subPart]..infoName;
    var numberToKeyName = subparts.[subPart]..numberToKeyName;
    var maxNumberName   = subparts.[subPart]..maxNumberName;
    var info = subset.[infoName];
    mmcifData.push("loop_");
    for (var column in columns) {
      mmcifData.push("_" + column);
    }
    for (var entryNumber from [1 subset.[maxNumberName]]) {
      var entryKey = subset.[numberToKeyName].[entryNumber];
      var lineData = [];
      var lineSize = 0;
      var temperature = 0.0;
      var temperatureInfoKey = "";
      var entryInfo = info.[entryKey];

      if (entryInfo..temperatureInfoKey != "") {
        var temperatureInfoKey = entryInfo..temperatureInfoKey;
        if (entryInfo.[temperatureInfoKey] != "" || entryInfo.[temperatureInfoKey].type == "decimal" || entryInfo.[temperatureInfoKey].type == "integer") {
          temperature = entryInfo.[temperatureInfoKey];
        }
      }
      entryInfo..temperature = temperature;

      for (var column in columns) {
        var cData   = "?";
        var infoKey = "";
        if (infoKeys.[column] != "") {
          infoKey = infoKeys.[column];
        }
        if (entryInfo.[infoKey].type != "string") {
          cData = entryInfo.[infoKey];
        } elseif (entryInfo.[infoKey] != "") {
          cData = entryInfo.[infoKey];
        } elseif (defaults.[infoKey].type != "string") {
          cData = defaults.[infoKey];
        } elseif (defaults.[infoKey] != "") {
          cData = defaults.[infoKey];
        }
        if ((lineSize + cData.size) >= maxLineSize) {   # '>=' because of separating blank
          cData = cData + "\n";
          lineSize = cData.size + 1;
        } else {
          lineSize += cData.size + 1;
        }
        lineData.push(cData);
      }
      mmcifData.push(lineData.join(" "));
    }
  }

  subset..mmcifData = mmcifData.join("\n");

  networkData..subsets..heatMap = subset;
  return subset..mmcifData;
}

function buildHeatMap2(dataHashref) {
  var msg         = "";
  var mmcifData   = [];
  var mmcifDef    = {};
  var infoKeys    = {};
  var defaults    = {};
  var general     = {};
  var subset      = {};
  var subsetKey   = "";
  var subsetName  = "";
  var maxLineSize = 2048;
  var subParts    = {};
  var tsvData     = [];

  var heatMapDistanceX = 0.2;
  var heatMapDistanceY = 0.2;
  var heatMapDistanceZ = 0.1;
  var heatMapNodeCount = 141;
  var heatMapSampleCount = 5;
  var heatMapNodeCountX = 13;
  var heatMapNodeCountY = 13;

  subParts..atom = {"infoName": "nodeInfo", "numberToKeyName": "nodeNumberToNodeKey", "maxNumberName": "maxNodeNumber"};
  subParts..bond = {"infoName": "edgeInfo", "numberToKeyName": "edgeNumberToEdgeKey", "maxNumberName": "maxEdgeNumber"};

   subParts..atom..columns = ["atom_site.group_PDB", "atom_site.id", "atom_site.type_symbol", "atom_site.label_alt_id", "atom_site.pdbx_PDB_ins_code", "atom_site.Cartn_x", "atom_site.Cartn_y", "atom_site.Cartn_z", "atom_site.auth_seq_id", "atom_site.auth_comp_id", "atom_site.auth_asym_id", "atom_site.auth_atom_id", "atom_site.B_iso_or_equiv"];

  subParts..bond..columns = ["struct_conn.id", "struct_conn.conn_type_id", "struct_conn.ptnr1_auth_asym_id", "struct_conn.ptnr1_label_atom_id", "struct_conn.ptnr1_auth_comp_id", "struct_conn.ptnr1_auth_seq_id", "struct_conn.ptnr2_auth_asym_id", "struct_conn.ptnr2_label_atom_id", "struct_conn.ptnr2_auth_comp_id", "struct_conn.ptnr2_auth_seq_id"];

  # Check required parameters
  if (dataHashref.type != "hash") {
    msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED in call of method 'buildHeatMap2'\n";
  } else {
    if (dataHashref..subsets.type != "hash") {
      msg = msg + "ERROR: subhash 'dataHashref..subsets' NOT PROVIDED in call of method 'determineRawSubnetworks'\n";
    } else {
      if (dataHashref..currentSubsetName == "") {
        dataHashref..currentSubsetName = "NONAME";
      }
      if (dataHashref..currentSubsetKey == "") {
        dataHashref..currentSubsetKey = "full";
      }
      subsetKey = dataHashref..currentSubsetKey;
      if (dataHashref..subsets.[subsetKey].type != "hash") {
        msg = msg + "ERROR: no subset subhash found for subset '" + subsetKey + "' in call of method 'buildHeatMap2'\n";
      } else {
        subset = dataHashref..subsets.[subsetKey];
        if (subset..nodeInfo.type != "hash") {
          msg = msg + "ERROR: subhash subset..nodeInfo' NOT PROVIDED in call of method 'buildHeatMap2'\n";
        }
        if (subset..edgeInfo.type != "hash") {
          msg = msg + "ERROR: subhash subset..edgeInfo' NOT PROVIDED in call of method 'buildHeatMap2'\n";
        }
        if (dataHashref..ioDefinitions.type != "hash") {
          msg = msg + "ERROR: subhash 'dataHashref..ioDefinitions' NOT PROVIDED in call of method 'buildHeatMap2'\n";
        } else {
          if (dataHashref..ioDefinitions..formats.type != "hash") {
            msg = msg + "ERROR: subhash 'dataHashref..ioDefinitions..formats' NOT PROVIDED in call of method 'buildHeatMap2'\n";
          } else {
            if (dataHashref..ioDefinitions..formats..mmcif.type != "hash") {
              msg = msg + "ERROR: subhash 'dataHashref..ioDefinitions..formats..mmcif' NOT PROVIDED in call of method 'buildHeatMap2'\n";
            } else {
              mmcifDef = dataHashref..ioDefinitions..formats..mmcif;   # shortcut for simpler access (by pointer)
              if (mmcifDef..general.type != "hash") {
                logMsg([level: "warn", msg: "subhash 'mmcifDef..general' NOT PROVIDED in call of method 'buildHeatMap2'\n"]);
              } else {
                general = mmcifDef..general;
                if (general..maxLineSize != "") {
                  maxLineSize = general..maxLineSize;
                }
              }
              if (mmcifDef..translations.type != "hash") {
                msg = msg + "ERROR: subhash 'mmcifDef..translations' NOT PROVIDED in call of method 'buildHeatMap2'\n";
              } else {
                if (mmcifDef..translations..infoKeys.type != "hash") {
                  msg = msg + "ERROR: subhash 'mmcifDef..translations..infoKeys' NOT PROVIDED in call of method 'buildHeatMap2'\n";
                } else {
                  infoKeys = mmcifDef..translations..infoKeys;   # shortcut for simpler access (by pointer)
                }
              }
              if (mmcifDef..defaults.type != "hash") {
                logMsg([level: "warn", msg: "subhash 'mmcifDef..defaults' NOT PROVIDED in call of method 'buildHeatMap2'\n"]);
              } else {
                defaults = mmcifDef..defaults;
              }
            }
          }
        }
      }
    }
    if (dataHashref..heatMapDistanceX !="") {
      heatMapDistanceX = dataHashref..heatMapDistanceX;
    }
    if (dataHashref..heatMapDistanceY !="") {
      heatMapDistanceY = dataHashref..heatMapDistanceY;
    }
    if (dataHashref..heatMapDistanceZ !="") {
      heatMapDistanceZ = dataHashref..heatMapDistanceZ;
    }
    if (dataHashref..heatMapNodeCount !="") {
      heatMapNodeCount = dataHashref..heatMapNodeCount;
    }
    if (dataHashref..heatMapSampleCount !="") {
      heatMapSampleCount = dataHashref..heatMapSampleCount;
    }
    if (dataHashref..heatMapTsvData.type == "array") {
      tsvData = dataHashref..heatMapTsvData;
    }
  }
  if (msg != "") {
    logMsg([level: "warn", msg: msg]);
    print msg;
    return;
  }

  # #### GENERATE FAKE DATA FOR TEST ####
  subset = [nodeNumberToNodeKey: {}, edgeNumberToEdgeKey: {}, nodeInfo: {}, edgeInfo: {}];

  if (tsvData.size == 0) {
    var initRandom = random(0,1,1234567890);
    var maxK = heatMapSampleCount * heatMapDistanceZ;
    var maxJ = heatMapNodeCount * heatMapDistanceX;
    var maxI = heatMapNodeCount * heatMapDistanceY;
    var nodeNumber   = 0;
    var sampleNumber = 0;
    for (var k=0; k<maxK; k+=heatMapDistanceZ) {
      sampleNumber++;
      var sampleId = "sample_" + sampleNumber;
      var geneNumber = 0;
      for (var i=0; i<maxI; i+=heatMapDistanceY) {
        for (var j=0; j<maxJ; j+=heatMapDistanceX) {
          nodeNumber++;
          geneNumber++;
          var nodeId = "node_" + nodeNumber;
          var geneId   = "gene_" + geneNumber;
          var nodeKey = geneId + "||" + sampleId;
          var x = j;
          var y = i;
          var z = k;
          var value = random(-1, 1);
          subset..nodeNumberToNodeKey[nodeNumber] = nodeKey;
          subset..nodeInfo.[nodeKey] = {};
          subset..nodeInfo.[nodeKey].nodeKey = nodeKey;
          subset..nodeInfo.[nodeKey].nodeId  = nodeId;
          subset..nodeInfo.[nodeKey].ageingFactorType = "gene";
          subset..nodeInfo.[nodeKey].ageingFactorName = geneId;
          subset..nodeInfo.[nodeKey].nodeSubType = "gene";
          subset..nodeInfo.[nodeKey].nodeSubTypeId = "AF_GEN";
          subset..nodeInfo.[nodeKey].nodeType = "ageingFactor";
          subset..nodeInfo.[nodeKey].nodeTypeId = "F";
          subset..nodeInfo.[nodeKey].species = "Saccharomyces cerevisiae" ;
          subset..nodeInfo.[nodeKey].geneId = geneId;
          subset..nodeInfo.[nodeKey].sampleId = sampleId;
          subset..nodeInfo.[nodeKey].subnetworkNumber = geneNumber;
          subset..nodeInfo.[nodeKey].labelShort = "" + geneId + "," + sampleId;
          subset..nodeInfo.[nodeKey].labelLong = "" + geneId + "," + sampleId + " (#" + nodeNumber + ", " + format("%.1f", value) + ")";
          subset..nodeInfo.[nodeKey].labelHover = labelLong;
          subset..nodeInfo.[nodeKey].temperatureInfoKey = "heatMapValue";
          subset..nodeInfo.[nodeKey].heatMapValue = value;
          subset..nodeInfo.[nodeKey].x = x;
          subset..nodeInfo.[nodeKey].y = y;
          subset..nodeInfo.[nodeKey].z = z;
        }
      }
    }
    subset..maxNodeNumber = nodeNumber;
    subset..maxEdgeNumber = 0;
  } else {
    # ### from TSV DATA #####
    var prefix = "V";
    var nodeNumber = 0;
    var geneNumber = 0;
    var maxX = heatMapNodeCountX - 1;
    #var maxY = heatMapNodeCountY;
    var counterX = 0;
    var counterY = 0;
    var offsetX = 0;
    var offsetY = 0;

    for (var rowData IN tsvData) {
      geneNumber++;
      var geneId   = "gene_" + geneNumber;
      var counterZ = 0;
      #var offsetZ = 0;

      if (counterX > maxX) {
        counterY++;
        counterX = 1;
      } else {
        counterX++;
      }

      for (var sampleNumber=1; sampleNumber<=heatMapSampleCount; sampleNumber++) {
        var sampleName = "" + prefix + sampleNumber;
        var sampleId = "sample_" + sampleNumber;
        var value      = "";
        if (rowData.[sampleName] != "") {
          value = rowData.[sampleName];
        }
        nodeNumber++;
        var nodeId = "node_" + nodeNumber;
        var nodeKey = geneId + "||" + sampleId;

        counterZ++;
        var offsetX = counterX * heatMapDistanceX;
        var offsetY = counterY * heatMapDistanceY;
        var offsetZ = counterZ * heatMapDistanceZ;
        var x = offsetX;
        var y = offsetY;
        var z = offsetZ;

        #log "row='" + geneNumber + "'  cX='" + counterX + "'  cY='" + counterY + "'  cZ='" + counterZ + "' x='" + x + "'  y='" + y + "'  z='" + z + "'  nodeKey='" + nodeKey + "'";

        subset..nodeNumberToNodeKey[nodeNumber] = nodeKey;
        subset..nodeInfo.[nodeKey] = {};
        subset..nodeInfo.[nodeKey].nodeKey = nodeKey;
        subset..nodeInfo.[nodeKey].nodeId  = nodeId;
        subset..nodeInfo.[nodeKey].ageingFactorType = "gene";
        subset..nodeInfo.[nodeKey].ageingFactorName = geneId;
        subset..nodeInfo.[nodeKey].nodeSubType = "gene";
        subset..nodeInfo.[nodeKey].nodeSubTypeId = "AF_GEN";
        subset..nodeInfo.[nodeKey].nodeType = "ageingFactor";
        subset..nodeInfo.[nodeKey].nodeTypeId = "F";
        subset..nodeInfo.[nodeKey].species = "Homo sapiens" ;
        subset..nodeInfo.[nodeKey].geneId = geneId;
        subset..nodeInfo.[nodeKey].sampleId = sampleId;
        subset..nodeInfo.[nodeKey].subnetworkNumber = geneNumber;
        subset..nodeInfo.[nodeKey].labelShort = "" + geneId + "," + sampleId;
        subset..nodeInfo.[nodeKey].labelLong = "" + geneId + "," + sampleId + " (#" + nodeNumber + ", " + format("%.1f", value) + ")";
        subset..nodeInfo.[nodeKey].labelHover = labelLong;
        subset..nodeInfo.[nodeKey].temperatureInfoKey = "heatMapValue";
        subset..nodeInfo.[nodeKey].heatMapValue = value;
        subset..nodeInfo.[nodeKey].x = x;
        subset..nodeInfo.[nodeKey].y = y;
        subset..nodeInfo.[nodeKey].z = z;
      }
    }

    subset..maxNodeNumber = nodeNumber;
    subset..maxEdgeNumber = 0;
  }

  #log subset;

  # Build header part
  if (general..header != "") {
    mmcifData.push(general..header);
  }
  mmcifData.push("data_" + subsetName);
  mmcifData.push("");
  mmcifData.push("_database_PDB_rev.num 1");
  mmcifData.push("");

  # Build subparts
  for (var subPart in ["atom", "bond"]) {
    var columns       = subparts.[subPart]..columns;
    var infoName = subparts.[subPart]..infoName;
    var numberToKeyName = subparts.[subPart]..numberToKeyName;
    var maxNumberName   = subparts.[subPart]..maxNumberName;
    var info = subset.[infoName];
    mmcifData.push("loop_");
    for (var column in columns) {
      mmcifData.push("_" + column);
    }
    for (var entryNumber from [1 subset.[maxNumberName]]) {
      var entryKey = subset.[numberToKeyName].[entryNumber];
      var lineData = [];
      var lineSize = 0;
      var temperature = 0.0;
      var temperatureInfoKey = "";
      var entryInfo = info.[entryKey];

      if (entryInfo..temperatureInfoKey != "") {
        var temperatureInfoKey = entryInfo..temperatureInfoKey;
        if (entryInfo.[temperatureInfoKey] != "" || entryInfo.[temperatureInfoKey].type == "decimal" || entryInfo.[temperatureInfoKey].type == "integer") {
          temperature = entryInfo.[temperatureInfoKey];
        }
      }
      entryInfo..temperature = temperature;

      for (var column in columns) {
        var cData   = "?";
        var infoKey = "";
        if (infoKeys.[column] != "") {
          infoKey = infoKeys.[column];
        }
        if (entryInfo.[infoKey].type != "string") {
          cData = entryInfo.[infoKey];
        } elseif (entryInfo.[infoKey] != "") {
          cData = entryInfo.[infoKey];
        } elseif (defaults.[infoKey].type != "string") {
          cData = defaults.[infoKey];
        } elseif (defaults.[infoKey] != "") {
          cData = defaults.[infoKey];
        }
        if ((lineSize + cData.size) >= maxLineSize) {   # '>=' because of separating blank
          cData = cData + "\n";
          lineSize = cData.size + 1;
        } else {
          lineSize += cData.size + 1;
        }
        lineData.push(cData);
      }
      mmcifData.push(lineData.join(" "));
    }
  }

  subset..mmcifData = mmcifData.join("\n");

  networkData..subsets..heatMap = subset;
  return subset..mmcifData;
}

function determineSubnetworks(nodeSet, options) {    # works with 'molecular' network data
  var subnetworkInfo = [];

  if (options.type != "hash") {
    if (layoutOptions.type == "hash") {
      options = layoutOptions;
    }
  }
  var subnetworkData = nodeSet.molecule.all.count();
  var subnetworkCount = subnetworkData.size;
  var nodeCount = nodeSet.size;
  var fullFrameSizeX = options.fr.fullFrameSizeX;
  var fullFrameSizeY = options.fr.fullFrameSizeY;
  var fullFrameSizeZ = options.fr.fullFrameSizeZ;

  if (subnetworkCount > 0) {
    var sizeFactorX = 1.0 * fullFrameSizeX / nodeCount;
    var sizeFactorY = 1.0 * fullFrameSizeY / nodeCount;
    var sizeFactorZ = 1.0 * fullFrameSizeZ / nodeCount;
    var maxFrameSizeX = 0.0;
    var maxFrameSizeY = 0.0;
    var maxFrameSizeZ = 0.0;

    #log "nodeCount=" + nodeCount + "  fullFrameSizeX=" + fullFrameSizeX + "  sizeFactorX=" + sizeFactorX;
    for (var i=subnetworkCount; i>=1; i--) {
      subnetworkInfo[i] = {};
      var info = subnetworkInfo[i];
      var subnetworkNumber    = (subnetworkData[i])[1];
      var subnetworkNodeCount = (subnetworkData[i])[2];
      var subnetworkNodeCountReduced = format("%d", [1 (1.0 * subnetworkNodeCount / 2)].max);
      var frameSizeX = 1.0 * sizeFactorX * subnetworkNodeCount;
      var frameSizeY = 1.0 * sizeFactorY * subnetworkNodeCount;
      var frameSizeZ = 1.0 * sizeFactorZ * subnetworkNodeCount;
      maxFrameSizeX = [frameSizeX maxFrameSizeX].max;
      maxFrameSizeY = [frameSizeY maxFrameSizeY].max;
      maxFrameSizeZ = [frameSizeZ maxFrameSizeZ].max;
      #log "i=" + i + "  mN=" + subnetworkNumber + "  mNC=" + subnetworkNodeCount;
      info["subnetworkNumber"] = subnetworkNumber;
      info["nodeCount"] = subnetworkNodeCount;
      info["subFrameSizeX"] = frameSizeX;
      info["subFrameSizeY"] = frameSizeY;
      info["subFrameSizeZ"] = frameSizeZ;

      info["maxSubFrameSizeX"] = maxFrameSizeX;
      info["maxSubFrameSizeY"] = maxFrameSizeY;
      info["maxSubFrameSizeZ"] = maxFrameSizeZ;
    }
  }

  #print subnetworkInfo;
  return subnetworkInfo;
}

function animateSubnetworks(maxNum, delayTime) {
  if (maxNum >= 1) {
    boundbox on;
    for (var i=1; i<=maxNum; i++) {
      logMsg([level: "info", msg: "displaying molecule " + i + " of " + maxNum + "..."]);
      display molecule=@i;
      boundbox(displayed);
      delay 1;
      if ({displayed}.size == 0) {
        break;
      }
    }
    display molecule<=@maxNum;
  }
}

function labelSubnetworksOld(maxNum) {
  if (maxNum >= 1) {
    var currentSelection = {selected};
    for (var i=1; i<=maxNum; i++) {
      minNodeNumber = {molecule=@i}.atomno.min;
      select atomno=@minNodeNumber;
      label "%N";
    }
    select @currentSelection;
  }
}

function labelSubnetwork(action, nodeSet) {    # alternative call: labelSubnetwork([action: "on", nodeSet: {displayed}])
  var options = [action: "on", nodeSet: {all}, minSize: 1, maxSize: 100000000000.0];

  if (action.type == "hash") {
    copyHashKeys(action, options);
  } elseif (action.type == "string") {
    options..action = action;
  }
  if (nodeSet.type == "bitset") {
    options..nodeSet = nodeSet;
  }

  # Show/hide subnetwork labels
  var subnetworkNumbers = options..nodeSet.molecule.all.count();
  var subnetworkCount = subnetworkNumbers.size;

  if (subnetworkCount > 0) {
    for (var i FROM [1 subnetworkCount]) {
      var subnetworkNumber = subnetworkNumbers[i].[1];
      var subnetworkLabelId = "sn" + subnetworkNumber;
      var subnetworkLabelText = subnetworkNumber;

      if (action == "on" || action == "displayed") {
        set echo @{subnetworkLabelId} displayed;
      } else {
        set echo @{subnetworkLabelId} hidden;
      }
    } 
  }
}

function tileSubnetworks(nodeSet, options, info) {
  var msg = "";
  var labelInfo = {};
  var labelSubnetworks = true;
  if (options == "") {
    options = layoutOptions;
  }
  if (options.type != "hash") {
    msg = msg + "ERROR: parameter 'options' (layoutOptions) MUST BE a hash in call of method 'tileSubnetworks'";
  } else {
    if (options..tileFactor == "") {
      options..tileFactor = 1.05;
    }
    if (options..labelSubnetworks.type != "boolean") {
      options..labelSubnetworks = false;
    }
    labelSubnetworks = options..labelSubnetworks;
  }
  if (info == "") {
    info = networkData;
  }
  if (info.type != "hash") {
    msg = msg + "ERROR: parameter 'info' (networkData) MUST BE a hash in call of method 'tileSubnetworks'";
  }

  if (nodeSet == "") {
    nodeSet = {displayed};
  }
  if (msg != "") {
    logMsg([level: "mixed", msg: msg]);
    return;
  }

  # Hide all subnetwork labels
  var allSubnetworkNumbers = {all}.molecule.all.count();
  #log allSubnetworkNumbers;
  var allSubnetworkCount = allSubnetworkNumbers.size;
  for (var i FROM [1 allSubnetworkCount]) {
    var subnetworkNumber = allSubnetworkNumbers[i].[1];
    var subnetworkLabelId = "sn" + subnetworkNumber;
    set echo @{subnetworkLabelId} hidden;
  }
  if (allSubnetworkCount <=1) {
    labelSubnetworks = false;
  }

  var subnetworkNumbers = {nodeSet}.molecule.all.count();
  var subnetworkCount = subnetworkNumbers.size;
  if (subnetworkCount >= 1) {
    #var currentSelection = selected;
    display nodeSet;
    # Determine maximum tile size
    var subFrameInfos = {};
    var maxWidth  = 0;
    var maxHeight = 0;
    #var columnCount = format("%d", sqrt(maxNum));
    var columnCount = point(sqrt(subnetworkCount)) + 1;
    for (var i FROM [1 subnetworkCount]) {
      var subnetworkNumber = (subnetworkNumbers[i])[1];
      #log "DEBUG: i=" + i + "  sN=" + subnetworkNumber;
      subFrameInfos[subnetworkNumber] = ({molecule=@subnetworkNumber}.boundbox);
      var subFrameInfo  = subFrameInfos[subnetworkNumber];
      var currentWidth  = 2.0 * subFrameInfo[2].x;
      var currentHeight = 2.0 * subframeInfo[2].y;
      #print "i=" + i + "  x=" + subFrameInfo[2].x;
      maxWidth  = [currentWidth maxWidth].max;
      maxHeight = [currentHeight maxHeight].max;      
    }
    #log "DEBUG: tileSubnetworks: subnetworkCount=" + subnetworkCount + "  maxWidth=" + maxWidth + "  maxHeight=" + maxHeight + "  columnCount=" + columnCount;
    #log subnetworkNumbers
    #log subFrameInfos;

    # Move subnetworks (using subFrame centers)
    var columnNumber = 0;
    var rowNumber    = 1;
    var columnOffset = 1.0 * options.tileFactor * maxWidth;
    var rowOffset    = 1.0 * options.tileFactor * maxHeight;
    var offsetX = 0.0 - (columnOffset / 2);
    var offsetY = 0.0 + (rowOffset / 2);
    var labelOffsetX = 0.0 - columnOffset;
    var labelOffsetY = 0.0;
    for (var i FROM [1 subnetworkCount]) {
      columnNumber++;
      offsetX = 0.0 + offsetX + columnOffset;
      labelOffsetX = 0.0 + labelOffsetX + columnOffset;
      if (columnNumber > columnCount) {
        columnNumber = 1;
        offsetX = 0.0 + (columnOffset / 2);
        labelOffsetX = 0.0;
        rowNumber++;
        offsetY = 0.0 + offsetY + rowOffset;
        labelOffsetY = 0.0 + labelOffsetY + rowOffset;
      }
      var subnetworkNumber = subnetworkNumbers[i].[1];
      var subFrameInfo = subFrameInfos[subnetworkNumber];
      #var offsetZ = (subFrameInfo[1]).z;
      var offsetPoint = point(offsetX offsetY 0) ;

      #log "DEBUG: tileSubnetworks: i=" + i + "  sn=" + subnetworkNumber + "  col=" + columnNumber + "  row=" + rowNumber + "  offsetPoint=" + offsetPoint + "  center=" + subFrameInfo[1];
      #log subFrameInfo;
      var currentNodes = {molecule=@subnetworkNumber};
      #log "DEBUG:  ==== before =========\n" + {currentNodes}.xyz.all;
      var subFrameCenter = subframeInfo[1];
      var subframeCenterX = subframeCenter.x;
      var subframeCenterY = subframeCenter.Y;
      var subframeCenterZ = subframeCenter.Z;
      translate {@{-subframeCenterX} @{-subframeCenterY} @{-subframeCenterZ}} currentNodes;
      translate {@{offsetX} @{offsetY} 0} currentNodes;
      var currentBoundbox = ({currentNodes}.boundbox);
      var currentBoundboxCornerX = currentBoundbox[3].x;
      var currentBoundboxCornerY = currentBoundbox[3].y;
      var currentBoundboxCornerZ = currentBoundbox[3].z;
      #print "i=" + i +  "  x=" + currentBoundboxCornerX +  "  y=" + currentBoundboxCornerY +  "  z=" + currentBoundboxCornerZ;
      var subnetworkLabelId = "sn" + subnetworkNumber;
      var subnetworkLabelText = subnetworkNumber;
      labelInfo[subnetworkNumber] = [subnetworkNumber: subnetworkNumber,
                                     labelId:          subnetworkLabelId,
                                     defaultLabelText: subnetworkLabelText,
                                     labelText:        subnetworkLabelText,
                                     x:                labelOffsetX,
                                     y:                labelOffsetY,
                                     z:                0
                                    ];
      set echo ID @{subnetworkLabelId} {@labelOffsetX @labelOffsetY 0};
      if (labelSubnetworks) {
        set echo @{subnetworkLabelId} displayed;
        
      } else {
        set echo @{subnetworkLabelId} hidden;
      }
      set echo @{subnetworkLabelId} @{"" + subnetworkLabelText};

      #log "DEBUG:  ==== after =========\n" + {currentNodes}.xyz.all;
      #for (var currentNode in currentNodes) {
      #  currentNode.x += (offsetPoint.x + subFrameInfo[1].x);
      #  currentNode.y += (offsetPoint.y + subFrameInfo[1].y);
      #  currentNode.z -= (offsetPoint.z + subFrameInfo[1].z);
      #}
    }
    if (subnetworkCount > 1) {
      reset;
    }
    zoomto 0 {displayed} 0;
    #select @currentSelection;
  }
  info..subsets.[info..currentSubsetKey].[labelInfo] = labelInfo;
}

function tileSubnetworksSorted(options, nodeSet, info) {
  var msg = "";
  var labelInfo = {};
  var labelSubnetworks = true;
  if (options == "") {
    options = layoutOptions;
  }
  if (options.type != "hash") {
    msg = msg + "ERROR: parameter 'options' (layoutOptions) MUST BE a hash in call of method 'tileSubnetworks'";
  } else {
    if (options..tileFactor == "") {
      options..tileFactor = 1.2;
    }
    if (options..tileFactorX == "") {
      options..tileFactorX = options..tileFactor;
    }
    if (options..tileFactorY == "") {
      options..tileFactorY = options..tileFactor;
    }
    if (options..labelSubnetworks.type != "boolean") {
      options..labelSubnetworks = false;
    }
    labelSubnetworks = options..labelSubnetworks;
  }
  if (info == "") {
    info = networkData;
  }
  if (info.type != "hash") {
    msg = msg + "ERROR: parameter 'info' (networkData) MUST BE a hash in call of method 'tileSubnetworks'";
  }

  if (nodeSet == "") {
    nodeSet = {displayed};
  }
  if (msg != "") {
    logMsg([level: "mixed", msg: msg]);
    return;
  }

  # Hide all subnetwork labels
  var allSubnetworkNumbers = {all}.molecule.all.count();
  #log allSubnetworkNumbers;
  var allSubnetworkCount = allSubnetworkNumbers.size;
  for (var i FROM [1 allSubnetworkCount]) {
    var subnetworkNumber = allSubnetworkNumbers[i].[1];
    var subnetworkLabelId = "sn" + subnetworkNumber;
    set echo @{subnetworkLabelId} hidden;
  }
  if (allSubnetworkCount <=1) {
    labelSubnetworks = false;
  }

  var subnetworkNumbers = {nodeSet}.molecule.all.count();
  var subnetworkCount = subnetworkNumbers.size;
  if (subnetworkCount >= 1) {
    #var currentSelection = selected;
    display nodeSet;
    # Determine width, height, and total width
    var sizeInfos          = []; 
    var subFrameInfos      = {};
    var maxSubFrameWidth   = 0.0;
    var maxSubFrameHeight  = 0.0;
    var minSubFrameWidth   = 100000.0;
    var minSubFrameHeight  = 100000.0;
    var totalSubFrameWidth = 0.0;
    var columnCount        = point(sqrt(subnetworkCount)) + 1;
    for (var i FROM [1 subnetworkCount]) {
      var subnetworkNumber = (subnetworkNumbers[i])[1];
      #log "DEBUG: i=" + i + "  sN=" + subnetworkNumber;
      subFrameInfos[subnetworkNumber] = ({molecule=@subnetworkNumber}.boundbox);
      var subFrameInfo  = subFrameInfos[subnetworkNumber];
      var currentWidth  = 2.0 * subFrameInfo[2].x;
      var currentHeight = 2.0 * subframeInfo[2].y;
      #var borderFactor = [currentWidth currentHeight].max * options.tileFactor;
      var borderFactorX = currentWidth * options.tileFactorX;
      var borderFactorY = currentHeight * options.tileFactorY;
      #currentHeight = currentHeight + borderFactorY;
      #currentWidth  = currentWidth  + borderFactorX;
      currentHeight = currentHeight + options.tileFactorY;
      currentWidth  = currentWidth  + options.tileFactorX;
      #print "i=" + i + "  width=" + currentWidth + "  height=" + currentHeight;
      maxSubFrameWidth  = [currentWidth maxSubFrameWidth].max;
      maxSubFrameHeight = [currentHeight maxSubFrameHeight].max;
      minSubFrameWidth  = [currentWidth minSubFrameWidth].min;
      minSubFrameHeight = [currentHeight minSubFrameHeight].min;
      totalSubFrameWidth = totalSubFrameWidth + currentWidth;
      sizeInfos.push([subnetworkNumber currentWidth currentHeight]);
    }
    var totalWidthSuggestion = totalSubFrameWidth / subnetworkCount * columnCount;
    var totalWidth = [maxSubFrameWidth totalWidthSuggestion].max;
    logMsg("tileSubnetworks: subnetworkCount=" + subnetworkCount + "  maxWidth=" + maxSubFrameWidth + "  maxHeight=" + maxSubFrameHeight + "  totalWidthSuggestion=" + totalWidthSuggestion + "  totalWidth=" + totalWidth + "  totalSubFrameWidth=" + totalSubFrameWidth);
    #log subnetworkNumbers
    #log subFrameInfos;
    #log sizeInfos;

    # Move subnetworks (using subFrame centers) and fit into lines from left (sorted by height)
    var columnNumber = 0;
    var rowNumber    = 1;
    var lineWidth    = 0.0;
    var offsetX = 0.0;
    var offsetY = 0.0;
    var labelOffsetX = 0.0;
    var labelOffsetY = 0.0;
    var previousWidth    = 0.0;
    var previousHeight   = 0.0;
    sizeInfos.sort(3).reverse;
    for (var i FROM [1 subnetworkCount]) {
      var sizeInfo         = sizeInfos[i];
      var subnetworkNumber = sizeInfo[1];
      var subFrameInfo     = subFrameInfos[subnetworkNumber];
      var currentWidth     = sizeInfo[2];
      var currentHeight    = sizeInfo[3];
      var nextWidth        = 0.0;
      if (i < subnetworkCount) {
        nextWidth = sizeInfos[i + 1]..[2];
      }
      columnNumber++;
      var columnOffset = previousWidth;
      var rowOffset    = 0.0;
      if (columnNumber == 1) {
        rowOffset    = previousHeight;
        #offsetX = 0.0 - (columnOffset / 2);
        #offsetY = 0.0 + (rowOffset / 2);
        offsetX = 0.0;
        offsetY = 0.0;
        labelOffsetX = 0.0;
        labelOffsetY = 0.0;
        logMsg("  col=1  previousWidth=" + previousWidth + "  previousHeight=" + previousHeight);
        previousHeight = currentHeight;
        previousWidth  = currentWidth;
        lineWidth = currentWidth;
      } else {
        if (lineWidth + currentWidth > totalWidth) {
          logMsg("  col=1+  previousWidth=" + previousWidth + "  previousHeight=" + previousHeight);
          columnNumber = 1;
          #offsetX = 0.0 - (columnOffset / 2);
          offsetX = 0.0;
          labelOffsetX = 0.0;
          rowNumber++;
          rowOffset    = previousHeight;
          offsetY = 0.0 + offsetY + rowOffset;
          labelOffsetY = 0.0 + labelOffsetY + rowOffset;
          lineWidth = currentWidth;
          previousHeight = currentHeight;
          previousWidth  = currentWidth;
        } else {
          logMsg("  col=" + columnNumber + "  previousWidth=" + previousWidth + "  previousHeight=" + previousHeight);
          lineWidth = lineWidth + currentWidth;
          columnOffset = previousWidth;
          previousWidth = currentWidth;
          offsetX = 0.0 + offsetX + columnOffset;
          labelOffsetX = 0.0 + labelOffsetX + columnOffset;
          #previousWidth  = currentWidth;
        }
      }
      #var offsetZ = (subFrameInfo[1]).z;
      var offsetPoint = point(offsetX offsetY 0) ;

      logMsg("tileSubnetworks: i=" + i + "  sn=" + subnetworkNumber + "  col=" + columnNumber + "  row=" + rowNumber + "  currentWidth=" + currentWidth + "  currentHeight=" + currentHeight + "  previousWidth=" + previousWidth + "  previousHeight=" + previousHeight + "  offsetPoint=" + offsetPoint + "  center=" + subFrameInfo[1]);
      #log subFrameInfo;
      var currentNodes = {molecule=@subnetworkNumber};
      #log "DEBUG:  ==== before =========\n" + {currentNodes}.xyz.all;
      var subFrameCenter = subframeInfo[1];
      var subframeCenterX = subframeCenter.x;
      var subframeCenterY = subframeCenter.Y;
      var subframeCenterZ = subframeCenter.Z;
      translate {@{-subframeCenterX} @{-subframeCenterY} @{-subframeCenterZ}} currentNodes;
      translate {@{offsetX} @{offsetY} 0} currentNodes;
      var currentBoundbox = ({currentNodes}.boundbox);
      var currentBoundboxCornerX = currentBoundbox[3].x;
      var currentBoundboxCornerY = currentBoundbox[3].y;
      var currentBoundboxCornerZ = currentBoundbox[3].z;
      #print "i=" + i +  "  x=" + currentBoundboxCornerX +  "  y=" + currentBoundboxCornerY +  "  z=" + currentBoundboxCornerZ;
      if (labelSubnetworks) {
      var subnetworkLabelId = "sn" + subnetworkNumber;
      var subnetworkLabelText = subnetworkNumber;
      labelInfo[subnetworkNumber] = [subnetworkNumber: subnetworkNumber,
                                     labelId:          subnetworkLabelId,
                                     defaultLabelText: subnetworkLabelText,
                                     labelText:        subnetworkLabelText,
                                     x:                labelOffsetX,
                                     y:                labelOffsetY,
                                     z:                0
                                    ];
      set echo ID @{subnetworkLabelId} {@labelOffsetX @labelOffsetY 0};
        set echo @{subnetworkLabelId} displayed;
        
      #} else {
      #  set echo @{subnetworkLabelId} hidden;
      #}
      set echo @{subnetworkLabelId} @{"" + subnetworkLabelText};
      }
      #log "DEBUG:  ==== after =========\n" + {currentNodes}.xyz.all;
      #for (var currentNode in currentNodes) {
      #  currentNode.x += (offsetPoint.x + subFrameInfo[1].x);
      #  currentNode.y += (offsetPoint.y + subFrameInfo[1].y);
      #  currentNode.z -= (offsetPoint.z + subFrameInfo[1].z);
      #}
    }
    if (subnetworkCount > 1) {
      reset;
    }
    zoomto 0 {displayed} 0;
    #select @currentSelection;
  }
  info..subsets.[info..currentSubsetKey].[labelInfo] = labelInfo;
}

function buildLayout(nodeSet, options) {
  var startTime = now();
  iterationNumber = 0;
  if (options.layoutType == "") { options.layoutType = "FruchtermanReingold"; };
  set echo ID "progressmessage" 0% 0%;
  set echo progressmessage hidden;
  set echo ID "progressmessage2" 100% 0%;
  set echo progressmessage2 hidden;

  display nodeSet;
  if (options.layoutType == "FruchtermanReingold") {
    if (options.tiled == true) {
      var currentSelection = {selected};
      currentSubnetworkNumber = 1;   # must be global for 'echo' actualization to work(!?)
      subnetworkInfo = determineSubnetworks(nodeSet, options);
      subnetworkCount = subnetworkInfo.size;
      set echo ID progressmessage "Please wait, processing subnetwork @{currentSubnetworkNumber} of @{subnetworkCount}...";
      #set echo ID progressmessage2 "Iteration @{iterationNumber} of @{options.fr.iterationCount}";
      if (subnetworkCount > 0) {
        var rowNumber    = 0;
        var columnNumber = 0;
        var offsetX    = 0.0;
        var offsetY    = 0.0;
        var maxOffsetY = 0.0;
        display none;
        for (currentSubnetworkNumber FROM [1 subnetworkCount]) {   # must be global for 'echo' actualization to work(!?)
          logData = [];
          var currentInfo = subnetworkInfo[currentSubnetworkNumber];
          #maxOffsetY = [maxOffsetY (subFrameBox.y)];
          options.fr.frameSizeX = currentInfo.maxSubFrameSizeX;
          options.fr.frameSizeY = currentInfo.maxSubFrameSizeY;
          options.fr.frameSizeZ = currentInfo.maxSubFrameSizeZ;
          #options.offsetX = offsetX;
          #options.offsetY = offsetY;
          #select molecule=@i;
          #boundbox(selected);
          var subnetworkNumber = currentInfo["subnetworkNumber"];
          var currentSubnetwork = {molecule=@subnetworkNumber and nodeSet};
          #var subFrameBox = getProperty("boundboxInfo", "vector");
          if (options.fr.displayIntermediates == true) {
            display molecule=@subnetworkNumber and nodeSet;
          }
          set echo progressmessage displayed;
          #set echo progressmessage2 displayed;
          logMsg([level: "info", msg: "subnetwork " + currentSubnetworkNumber + " of " + subnetworkCount + "..."]);
          buildFRLayout(currentSubnetwork, options);
#          rotateBest(currentSubnetwork);
          select displayed;
          rotate best;
          
        }
        initDisplay(options);
        tileSubnetworksSorted(options, nodeSet)
        var pMsg = "FINISHED: subnetworks=" + subnetworkCount + "  pair counter=" + counter + " (grid pairs=" + counter2 + ")  tiled layout calculation time=" + now(startTime) + " ms";
        logMsg([level: "info", msg: pMsg]);
      } else {
        logMsg([level: "info", msg: "no subnetworks found - NO LAYOUT GENERATED"]);
      }
      select @currentSelection;
    } else {
      logData = [];
      set echo ID progressmessage2 "Please wait, iteration @{iterationNumber} of @{options.fr.iterationCount}...";
      set echo progressmessage2 displayed;
      buildFRLayout(nodeSet, options);
    }
  }
  set echo progressMessage hidden;
  set echo progressMessage2 hidden;
  pMsg = "FINISHED: layout calculation time=" + now(startTime) + " ms";
  logData.push(pMsg);
  logMsg([level: info, msg: pMsg]);
}

function buildFRLayout(nodeSet, options) {
  var startTime = now();
  if (options.fr.layoutType     == "") { options.fr.layoutType = "fr"; };
  if (options.fr.iterationCount == "") { options.fr.iterationCount = 100; };
  if (options.fr.frameSizeX     == "") { options.fr.frameSizeX = 100; };
  if (options.fr.frameSizeY     == "") { options.fr.frameSizeY = 100; };
  if (options.fr.frameSizeZ     == "") { options.fr.frameSizeZ = 100; };
  if (options.fr.startTemperature  == "") { options.fr.startTemperature = 4; };
  if (options.fr.minimumTemperature  == "") { options.fr.minimumTemperature = 0.01; };
  if (options.fr.kValueModifier    == "") { options.fr.kValueModifier = 0.6; };
  if (options.fr.startCoordinateMode == "") { options.fr.startCoordinateMode = "random"; };
  if (options.fr.randomCoordinateFactor == "") { options.fr.randomCoordinateFactor = 0.8; };
  if (options.fr.burstIterationCount  == "") { options.fr.burstIterationCount = 20; };
  #if (options.fr. == "") { options.fr. =  };

  if (options["updateCoordinates"].type != "hash") { options["updateCoordinates"] = {} }
  options["updateCoordinates"]["final"] = false;

  var pMsg = "";

  logMsg([level: "info", msg: "Building Fruchterman-Reingold layout (" + options.fr.iterationCount + " iteratios)..."]);
  #log options;
  if (nodeSet) {
    if (nodeSet.size > 0) {
      var nodeCount = nodeSet.size;
      var foX      = 0;
      var foY      = 0;
      var foZ      = 0;
      var pairKeys    = {};
      var mf = [];
      xc         = [];
      yc         = [];
      zc         = [];
      edges    = {};
      cons     = {};
      var fsX = 1.0 * options.fr.randomCoordinateFactor * options.fr.frameSizeX;
      var fsY = 1.0 * options.fr.randomCoordinateFactor * options.fr.frameSizeX;
      var fsZ = 1.0 * options.fr.randomCoordinateFactor * options.fr.frameSizeX;
      var counter = 0;
      var counter1 = 0;
      var counter2 = 0;
      var conKeys = {};
      #var distances = {};

      # Initialize random number generator
      #print "DEBUG: init random with '" + options.fr.randomCoordinateSeed + "'";
      var initRandom = random(0,1,options.fr.randomCoordinateSeed);

      # Initialize parameters
      var kValue        = options.fr.kValueModifier * sqrt((fsX * fsY)) / 2;
      #var kValue        = options.fr.kValueModifier * sqrt((fsX * fsY * fsZ)) / 3;
      var kValueSquared = kValue * kValue;
      var kValueDoubled = kValue * 2;
      options.fr.currentTemperature = options.fr.startTemperature;

      # Copy coordinates and determine connections
      var nodeNoToIndex = {};
      for (var i FROM [nodeCount 1]) {
        if (options.fr.startCoordinateMode == "random") {
          xc[i] = random(0, fsX);
          yc[i] = random(0, fsY);
          if (options..planar) {
            zc[i] = 0;
          } else {
            zc[i] = random(0, fsZ);
          }
          #log "RANDOM: i="  + i + "  newX=" + xc[i] + "  newY=" + yc[i] + "  newY=" + zc[i];
        } else {
          xc[i] = nodeSet[i].x;
          yc[i] = nodeSet[i].y;
          zc[i] = nodeSet[i].z;
        }
        var nodeNo1 = nodeSet[i].atomno;
        nodeNoToIndex[nodeNo1] = i;
        if (nodeSet[i].bondCount > 0) {
          var con = connected(nodeSet[i]);
          if (con.size > 0) {
            var conNodes = [];
            for (var node in con) {
              var nodeNo2 = node.atomno;
              #var key = "" + nodeNo1 + "|" + nodeNo2;
              var rkey = "" + nodeNo2 + "|" + nodeNo1;
              if (conKeys[rkey].size == 0) {
                conKeys[rkey] = "1";
                conNodes.push(nodeNo2);
              }
            }
            if (conNodes.size > 0) {
              cons[nodeNo1] = conNodes;
            }
          }
        }

        #log "INIT: i=" + i + " x1=" + nodeSet[i].x + "  x2=" + nodeSet[i].x + "  x3=" + nodeSet[i].x + "  xc[i]=" + xc[i];
        #logData.push("INIT: i=" + i + "  X=" + xc[i] + "(" + nodeSet[i].x + ")  Y=" + yc[i] + " (" + nodeSet[i].y + ")  newZ=" + zc[i] + " (" + nodeSet[i].z + ")" + "  ns.xyz=" + nodeSet[i].xyz);
      }

      if (options.tiled != true || options.fr.displayIntermediates == true) {
        initDisplay(options);
      }
      if (options.fr.startCoordinateMode == "random") {
        logMsg([level: "info", msg: "  nodes placed on random positions"]);
        updateCoordinates(nodeSet, options);
      }
      #set echo progressMessage "Calculating layout...";
      #set echo progressMessage displayed;
      #logData.push("STARTED: iterations=" + options.fr.iterationCount + "  startCoordinateMode=" + options.fr.startCoordinateMode + "  kValue=" + kValue + "  kValueDoubled=" + kValueDoubled + "  kValueSquared=" + kValueSquared);

      for (iterationNumber FROM [1 options.fr.iterationCount]) {
        #pMsg  = "Iteration " + iterationNumber + " of " + options.fr.iterationCount + " (" + now(startTime) + " ms)...";
        #log pMsg;
        #set echo progressMessage @pMsg;

        # Initialize force arrays
        fX  = [];
        fY  = [];
        fZ  = [];
        pairKeys = {};
        
        for (var i FROM [nodeCount 1]) {
          fX[i] = 0;
          fY[i] = 0;
          fZ[i] = 0;
        }

        # Calculate repulsive forces
        var nodeNoList = nodeNoToIndex.keys;
        for (var index FROM [1 nodeCount]) {
          var nodeNo1 = nodeNoList[index];
          var kValueDoubledDoubled = kValueDoubled + 1;
          var subNodesAll = within(kValueDoubled, {atomno=@nodeNo1});
          var subNodeList = {(nodeSet and subNodesAll) and not atomno=@nodeNo1}.atomno.all;
          #subNodeList.push(nodeNo);
          var subNodeCount = subNodeList.size;
          #log "it=" + iterationNumber + "  c2=" + counter2 + "  nc=" + nodeCount + "  snc=" + subNodeCount + "  nodeNo=" + nodeNo1 + "  kValueDoubled=" + kValueDoubled + " subNodeList:";
          #log  subNodeList;
          if (subNodeCount > 0) {
            var i = nodeNoToIndex[nodeNo1];
            for (var si FROM [1 subNodeCount]) {
              var nodeNo2 = subNodeList[si];
              #var pairKey = "" + nodeNo1 + "|" + nodeNo2;
              #var reversePairKey = "" + nodeNo2 + "|" + nodeNo1;
              counter2++;
              #log "it=" + iterationNumber + "  si=" + si + "  c2=" + counter2 + "  snc=" + subNodeCount + "  pairKey=" + pairKey;
              #if (pairKeys[pairKey].type != "boolean") {
                #pairKeys[pairKey] = true;
                #pairKeys[reversePairKey] = true;
                #log "DEBUG:   pairKey=" + pairKey + "  type=" + pairKeys[pairKey].type;
                var j = nodeNoToIndex[nodeNo2];
                var dx = xc[i] - xc[j];
                var dy = yc[i] - yc[j];
                var dz = zc[i] - zc[j];
                #select @nodeSet[i],@nodeSet[j];
                # measure @{nodeSet[i]} @{nodeSet[j]};
                # log "  it=" + iterationNumber + "  c=" + counter;

                if (dx == 0) {
                  dx = 1;
                }
                if (dy == 0) {
                  dy = 1;
                }
                if (dz == 0) {
                  dz = 1;
                }

                var distSquared = [dx,dy,dz].sum2;
                if (options..planar) {
                  distSquared = [dx,dy].sum2;
                }
                var dist = sqrt(distSquared);

                if (dist < kValueDoubled ) {
                  counter++;
                  var kDist = kValueSquared / dist;
                  var foX = (dx / dist) * kDist;
                  var foY = (dy / dist) * kDist;
                  var foZ = (dz / dist) * kDist;

                  fX[i] += foX;
                  fY[i] += foY;
                  fZ[i] += foZ;
                  fX[j] -= foX;
                  fY[j] -= foY;
                  fZ[j] -= foZ;
                }
              #} else {
              #  counter1++;
              #}
            }
          }
        }



        # Calculate attractive forces
        for (var nodeNo1 in cons.keys) {
          var i = nodeNoToIndex[nodeNo1];
          for (var nodeNo2 in cons[nodeNo1]) {
            var j = nodeNoToIndex[nodeNo2];

            var dx = xc[i] - xc[j];
            var dy = yc[i] - yc[j];
            var dz = zc[i] - zc[j];

            if (dx == 0) {
              dx = 1;
            }
            if (dy == 0) {
              dy = 1;
            }
            if (dz == 0) {
              dz = 1;
            }

            var distSquared = [dx,dy,dz].sum2;
            var dist = sqrt(distSquared);

            var kDist = distSquared / kValue;
            var foX = (dx / dist) * kDist;
            var foY = (dy / dist) * kDist;
            var foZ = (dz / dist) * kDist;
            fX[i] -= foX;
            fY[i] -= foY;
            fZ[i] -= foZ;
            fX[j] += foX;
            fY[j] += foY;
            fZ[j] += foZ;

          }
        }

        # Apply forces
        applyForces(nodeSet, options);

        # Adjust temperature
        #if (iterationCount > options.fr.burstIterationCount) {
          options.fr.currentTemperature = options.fr.temperatureScalingFactor * options.fr.currentTemperature;
          if (options.fr.currentTemperature < options.fr.minimumTemperature) {
            options.fr.currentTemperature = options.fr.minimumTemperature;
          }
        #}

        #prompt("Iteration " + iterationNumber + "finished");

        if (iterationNumber == options.fr.iterationCount) {
          options["updateCoordinates"]["final"] = true;
        }
        # Display intermediate layout
        #if (options.fr.displayIntermediates) {
          updateCoordinates(nodeSet, options);
          #var imageFilename = "" + format("layout_iteration_%03d.png", iterationNumber);
          #write PNGJ 1000 1000 9 @imageFilename;
        #}
        #prompt("Iteration " + iterationNumber + "finished");
      }

      # Display final layout
      if (options.fr.displayIntermediates != true) {
        #updateCoordinates(nodeSet, options);
      }
    }
  }
  #log "FINISHED LAYOUT";
  pMsg = "FINISHED: iterations=" + options.fr.iterationCount + "  pair counter=" + counter + "  layout calculation time=" + now(startTime) + " ms";
  logData.push(pMsg);
  logMsg([level: "info", msg: pMsg]);
}

function applyForces(nodeSet, options) {
  var nodeCount = nodeSet.size;
  var sizeX  = options.fr.frameSizeX;
  var sizeY  = options.fr.frameSizeY;
  var sizeZ  = options.fr.frameSizeZ;
  var cTemp  = options.fr.currentTemperature;

  for (var i FROM [1 nodeCount]) {
    if ( fX[i] >= 0) {
      fX[i] = [fX[i], cTemp].min;
    } else {
      fX[i] = [fX[i], -cTemp].max;
    }
    if ( fY[i] >= 0) {
      fY[i] = [fY[i], cTemp].min;
    } else {
      fY[i] = [fY[i], -cTemp].max;
    }
    if ( fZ[i] >= 0) {
      fZ[i] = [fZ[i], cTemp].min;
    } else {
      fZ[i] = [fZ[i], -cTemp].max;
    }
  }

  xc = xc.add(fX);
  yc = yc.add(fY);
  zc = zc.add(fZ);

}

function updateCoordinates(nodeSet, options) {
  if (nodeSet.size > 0) {
    var nodeCount = nodeSet.size;
    if (options["updateDisplay"].type != "hash") { options["updateDisplay"] = {"center": true, "zoom": true} }
    if (options["updateCoordinates"].type != "hash") { options["updateCoordinates"] = {} }
    if (options.tiled == true && options["updateCoordinates"]["final"] == true) {
      var oX = 0;
      var oY = 0;
      var oZ = 0;
      if (options.offsetX != "") {
        oX = options.offsetX;
      }
      if (options.offsetY != "") {
        oY = options.offsetY;
      }
      if (options.offsetZ != "") {
        oZ = options.offsetZ;
      }
      #log "oX=" + oX;
      for (var i FROM [1 nodeCount]) {
        #logData.push("UPDATE: i="  + i + "  oldX=" + nodeSet[i].x + "  newX=" + xc[i] + "  oldY=" + nodeSet[i].y + "  newY=" + yc[i] + "  oldZ=" + nodeSet[i].z + "  newZ=" + zc[i]);

        if (nodeSet[i].property_fixedPosition != 1) {
        nodeSet[i].x = (xc[i]) + oX;    # brackets needed as workaround for bug in 14.2.x/14.3.x
        nodeSet[i].y = (yc[i]) + oY;    # brackets needed as workaround for bug in 14.2.x/14.3.x
        if (options..planar) {
          nodeSet[i].z = 0;
        } else {
          nodeSet[i].z = (zc[i]) + oZ;    # brackets needed as workaround for bug in 14.2.x/14.3.x
        }
        }
        #logData.push("UPDATE2: i="  + i + "  newX=" + nodeSet[i].x + "  newY=" + nodeSet[i].y + "  newZ=" + nodeSet[i].z);
      }
      options["updateDisplay"]["center"] = false;
    } else {
      for (var i FROM [1 nodeCount]) {
        #logData.push("UPDATE: i="  + i + "  oldX=" + nodeSet[i].x + "  newX=" + xc[i] + "  oldY=" + nodeSet[i].y + "  newY=" + yc[i] + "  oldZ=" + nodeSet[i].z + "  newZ=" + zc[i]);
        if (nodeSet[i].property_fixedPosition != 1) {
          nodeSet[i].x = (xc[i]);    # brackets needed as workaround for bug in 14.2.x/14.3.x
          nodeSet[i].y = (yc[i]);    # brackets needed as workaround for bug in 14.2.x/14.3.x
          if (options..planar) {
            nodeSet[i].z = 0;
          } else {
            nodeSet[i].z = (zc[i]);    # brackets needed as workaround for bug in 14.2.x/14.3.x
          }
        }
        #logData.push("UPDATE2: i="  + i + "  newX=" + nodeSet[i].x + "  newY=" + nodeSet[i].y + "  newZ=" + nodeSet[i].z);
      }
      #options["updateDisplay"]["center"] = true;
    }
    var updateDisplay = false;
    #if (options.tiled != true || options.fr.displayIntermediates == true) {
    #  updateDisplay(options);
    #}
    #if (options.tiled == true || options.fr.displayIntermediates == true) {
    #  updateDisplay(options);
    #}
    if (options.fr.displayIntermediates == true) {
      updateDisplay(options);
    }
  } else {
    logData.push("UPDATE: empty nodeSet");
  }
}

function buildCubicLayoutV2(dataHashref) {  # WORKS ON RAW DATA and MOLECULAR DATA
  var startTime = now();
  var msg = "";
  var buildMode = "X-Y-Z";
  var subsetKey = "full";
  var nodeTypeX = "";
  var nodeTypeY = "";
  var nodeTypeZ = "";
  var nodeTypeData = "";
  var sortKeyData  = "nodeNumber";
  var distanceX = 0.2;
  var distanceY = 0.2;
  var distanceZ = 0.2;
  var neighbours = {};
  var nodeSet    = {};
  var options    = {};
  var positions  = {};
  var positionKey = "";

  if (dataHashref.type == "hash") {
    if (dataHashref..layoutOptions.type == "hash") {
      options = dataHashref..layoutOptions;
    }
    if (dataHashref..currentSubsetKey != "") {
      subsetKey = dataHashref..currentSubsetKey;
    }
    if (dataHashref..subsets.type == "hash") {
      if (dataHashref..subsets.[subsetKey].type == "hash") {
        if (dataHashref..subsets.[subsetKey]..nodeInfo.type == "hash") {
          nodeSet = dataHashref..subsets.[subsetKey]..nodeInfo;
        }
        if (dataHashref..subsets.[subsetKey]..neighbours.type == "hash") {
          neighbours = dataHashref..subsets.[subsetKey]..neighbours;
        }
      }
    }
  } else {
    logMsg([level: "error", msg: "parameter 'dataHashref' must be a hash reference in call of method 'buildCubicLayout' - ABORTED METHOD"]);
    return false;
  }

  if (options..cubic..layoutType     == "") { options..cubic..layoutType = "cubic"; }
  if (options..cubic..frameSizeX     == "") { options..cubic..frameSizeX = 100; }
  if (options..cubic..frameSizeY     == "") { options..cubic..frameSizeY = 100; }
  if (options..cubic..frameSizeZ     == "") { options..cubic..frameSizeZ = 100; }
  if (options..cubic..distanceX     != "") { distanceX = options..cubic..distanceX; }
  if (options..cubic..distanceY     != "") { distanceY = options..cubic..distanceY; }
  if (options..cubic..distanceZ     != "") { distanceZ = options..cubic..distanceZ; }
  if (options..cubic..startCoordinateMode == "") { options..cubic..startCoordinateMode = "random"; }    # COORDINATES MUST BE SET TO ZERO IF 'random'
  #if (options..cubic. == "") { options..cubic. =  };

  if (options..cubic..nodeTypeX == "") {
    msg = msg + "ERROR: parameter 'options.cubic.nodeTypeX";
  } else {
    nodeTypeX = options..cubic..nodeTypeX;
    if (options..cubic..nodeTypeY == "") {
      nodeTypeY = nodeTypeX;
      buildMode = "XY-Z";
    } else {
      nodeTypeY = options..cubic..nodeTypeY;
    }
    if (options..cubic..nodeTypeZ == "") {
      nodeTypeZ = nodeTypeX;
      buildMode = "XYZ";
    } else {
      nodeTypeZ = options..cubic..nodeTypeZ;
    }
    if (options..cubic..nodeTypeData == "") {
      nodeTypedata = nodeTypeX;
    } else {
      nodeTypeData = options..cubic..nodeTypeData;
    }
    if (options..cubic..sortKeyData != "") {
      sortKeyData = options..cubic..sortKeyData;
    }
  }

  if (options["updateCoordinates"].type != "hash") { options["updateCoordinates"] = {} }
  options["updateCoordinates"]["final"] = false;

  var pMsg = "";

  logMsg([level: "info", msg: "running buildCubicLayout (buildMode=" + buildMode + ")..."]);
  logMsg(options);
  if (nodeSet) {
    var nodeCount = nodeSet.size;
    if (nodeCount > 0) {
      var filter = "* WHEREIN nodeType='" + nodeTypeData + "'";
      var nodeSetData = nodeSet.select(filter);
      var nodeCountData = nodeSetData.size;
 
      if (nodeCountData > 0) {
        filter = "* WHEREIN nodeType='" + nodeTypeX + "'";
        var nodeSetX = nodeSet.select(filter);

        if (buildMode == "XYZ") {
        } elseif (buildMode == "XY-Z") {
          filter = "* WHEREIN nodeType='" + nodeTypeZ + "'";
          var nodeSetZ = nodeSet.select(filter);
        } elseif (buildMode == "X-Y-Z") {
          filter = "* WHEREIN nodeType='" + nodeTypeY + "'";
          var nodeSetY = nodeSet.select(filter);
          filter = "* WHEREIN nodeType='" + nodeTypeZ + "'";
          var nodeSetZ = nodeSet.select(filter);

          
          # X-axis
          #   determine and sort neighbour data nodes and distribute axis nodes
          logMsg("  determining x-axis neighbours (nodeCountData=" + nodeCountdata + ")...");
          var neighboursX = [];
          var neighbourCountX = 0;
          var nodeCountX = nodeSetX.size;
          var nodeNumberX = 0;
          for (var nodeKey in nodeSetX.keys.sort) {
            if (neighbours.[nodeKey].type == "hash") {
              logMsg("    totalNeighbours=" + neighbours.[nodeKey].size);
              var subNeighboursX = [];
              var nodeNumber = nodeSetX.[nodeKey]..nodeNumber;
              var x = nodeNumberX * distanceX;
              var y = -2.0 * distanceY;
              var z = -2.0 * distanceZ;
              nodeSetX.[nodeKey]..x = x;
              nodeSetX.[nodeKey]..y = y;
              nodeSetX.[nodeKey]..z = z;
              {atomno=@nodeNumber}.x = x;
              {atomno=@nodeNumber}.y = y;
              {atomno=@nodeNumber}.z = z;
              for (var neighbourNodeKey in neighbours.[nodeKey]) {
                if (nodeSetData.[neighbourNodeKey].type == "hash") {
                  if (nodeSetData.[neighbourNodeKey]..nodeType == nodeTypeData) {
                    var neighbourNodeNumber = nodeSetData.[neighbourNodeKey]..nodeNumber;
                    nodeSetData.[neighbourNodeKey]..x = x;
                    {atomno=@neighbourNodeNumber}.x = x;
                  }
                }
              }
              #neighboursX += subNeighboursX.sort(sortKeyData);
              #neighbourCountX += subNeighboursX.size;
              #logMsg("    dataNeighbours=" + subNeighboursX.size);
            }
            nodeNumberX++;
          }

          # Y-axis
          #   determine and sort neighbour data nodes and distribute axis nodes
          logMsg("  determining y-axis neighbours (nodeCountData=" + nodeCountdata + ")...");
          var neighboursY = [];
          var neighbourCountY = 0;
          var nodeCountY = nodeSetY.size;
          var nodeNumberY = 0;
          for (var nodeKey in nodeSetY.keys.sort) {
            if (neighbours.[nodeKey].type == "hash") {
              logMsg("    totalNeighbours=" + neighbours.[nodeKey].size);
              var subNeighboursY = [];
              var nodeNumber = nodeSetY.[nodeKey]..nodeNumber;
              var y = nodeNumberY * distanceY;
              var x = -2.0 * distanceX;
              var z = -2.0 * distanceZ;
              nodeSetY.[nodeKey]..x = x;
              nodeSetY.[nodeKey]..y = y;
              nodeSetY.[nodeKey]..z = z;
              {atomno=@nodeNumber}.x = x;
              {atomno=@nodeNumber}.y = y;
              {atomno=@nodeNumber}.z = z;
              for (var neighbourNodeKey in neighbours.[nodeKey]) {
                if (nodeSetData.[neighbourNodeKey].type == "hash") {
                  if (nodeSetData.[neighbourNodeKey]..nodeType == nodeTypeData) {
                    var neighbourNodeNumber = nodeSetData.[neighbourNodeKey]..nodeNumber;
                    nodeSetData.[neighbourNodeKey]..y = y;
                    {atomno=@neighbourNodeNumber}.y = y;
                  }
                }
              }
              #neighboursY += subNeighboursY.sort(sortKeyData);
              #neighbourCountY += subNeighboursY.size;
              #logMsg("    dataNeighbours=" + subNeighboursY.size);
            }
            nodeNumberY++;
          }

          # Z-axis
          #   determine and sort neighbour data nodes and distribute axis nodes
          logMsg("  determining z-axis neighbours (nodeCountData=" + nodeCountdata + ")...");
          var neighboursZ = [];
          var neighbourCountZ = 0;
          var nodeCountZ = nodeSetZ.size;
          var nodeNumberZ = 0;
          for (var nodeKey in nodeSetZ.keys.sort) {
            if (neighbours.[nodeKey].type == "hash") {
              logMsg("    totalNeighbours=" + neighbours.[nodeKey].size);
              var subNeighboursZ = [];
              var nodeNumber = nodeSetZ.[nodeKey]..nodeNumber;
              var z = nodeNumberZ * distanceZ;
              var y = -2.0 * distanceY;
              var x =  -2.0 * distanceX;
              nodeSetZ.[nodeKey]..z = z;
              nodeSetZ.[nodeKey]..y = y;
              nodeSetZ.[nodeKey]..x = x;
              {atomno=@nodeNumber}.x = x;
              {atomno=@nodeNumber}.y = y;
              {atomno=@nodeNumber}.z = z;
              for (var neighbourNodeKey in neighbours.[nodeKey]) {
                if (nodeSetData.[neighbourNodeKey].type == "hash") {
                  if (nodeSetData.[neighbourNodeKey]..nodeType == nodeTypeData) {
                    var neighbourNodeNumber = nodeSetData.[neighbourNodeKey]..nodeNumber;
                    nodeSetData.[neighbourNodeKey]..z = z;
                    {atomno=@neighbourNodeNumber}.z = z;
                  }
                }
              }
              #neighboursZ += subNeighboursZ.sort(sortKeyData);
              #neighbourCountZ += subNeighboursZ.size;
              #logMsg("    dataNeighbours=" + subNeighboursZ.size);
            }
            nodeNumberZ++;
          }

        }
      }
    }
  }

  #log "FINISHED LAYOUT";
  pMsg = "finished layout - calculation time=" + now(startTime) + " ms";
  logMsg([level: "info", msg: pMsg]);

}

function buildCubicLayout(dataHashref) {  # WORKS ON RAW DATA and MOLECULAR DATA
  var startTime = now();
  var msg = "";
  var buildMode = "X-Y-Z";
  var subsetKey = "full";
  var nodeTypeX = "";
  var nodeTypeY = "";
  var nodeTypeZ = "";
  var nodeTypeData = "";
  var sortKeyData  = "nodeNumber";
  var distanceX = 0.2;
  var distanceY = 0.2;
  var distanceZ = 0.2;
  var neighbours = {};
  var nodeSet    = {};
  var options    = {};
  var positions  = {};
  var positionKey = "";

  if (dataHashref.type == "hash") {
    if (dataHashref..layoutOptions.type == "hash") {
      options = dataHashref..layoutOptions;
    }
    if (dataHashref..currentSubsetKey != "") {
      subsetKey = dataHashref..currentSubsetKey;
    }
    if (dataHashref..subsets.type == "hash") {
      if (dataHashref..subsets.[subsetKey].type == "hash") {
        if (dataHashref..subsets.[subsetKey]..nodeInfo.type == "hash") {
          nodeSet = dataHashref..subsets.[subsetKey]..nodeInfo;
        }
        if (dataHashref..subsets.[subsetKey]..neighbours.type == "hash") {
          neighbours = dataHashref..subsets.[subsetKey]..neighbours;
        }
      }
    }
  } else {
    logMsg([level: "error", msg: "parameter 'dataHashref' must be a hash reference in call of method 'buildCubicLayout' - ABORTED METHOD"]);
    return false;
  }

  if (options..cubic..layoutType     == "") { options..cubic..layoutType = "cubic"; }
  if (options..cubic..frameSizeX     == "") { options..cubic..frameSizeX = 100; }
  if (options..cubic..frameSizeY     == "") { options..cubic..frameSizeY = 100; }
  if (options..cubic..frameSizeZ     == "") { options..cubic..frameSizeZ = 100; }
  if (options..cubic..distanceX     != "") { distanceX = options..cubic..distanceX; }
  if (options..cubic..distanceY     != "") { distanceY = options..cubic..distanceY; }
  if (options..cubic..distanceZ     != "") { distanceZ = options..cubic..distanceZ; }
  if (options..cubic..startCoordinateMode == "") { options..cubic..startCoordinateMode = "random"; }    # COORDINATES MUST BE SET TO ZERO IF 'random'
  #if (options..cubic. == "") { options..cubic. =  };

  if (options..cubic..nodeTypeX == "") {
    msg = msg + "ERROR: parameter 'options.cubic.nodeTypeX";
  } else {
    nodeTypeX = options..cubic..nodeTypeX;
    if (options..cubic..nodeTypeY == "") {
      nodeTypeY = nodeTypeX;
      buildMode = "XY-Z";
    } else {
      nodeTypeY = options..cubic..nodeTypeY;
    }
    if (options..cubic..nodeTypeZ == "") {
      nodeTypeZ = nodeTypeX;
      buildMode = "XYZ";
    } else {
      nodeTypeZ = options..cubic..nodeTypeZ;
    }
    if (options..cubic..nodeTypeData == "") {
      nodeTypedata = nodeTypeX;
    } else {
      nodeTypeData = options..cubic..nodeTypeData;
    }
    if (options..cubic..sortKeyData != "") {
      sortKeyData = options..cubic..sortKeyData;
    }
  }

  if (options["updateCoordinates"].type != "hash") { options["updateCoordinates"] = {} }
  options["updateCoordinates"]["final"] = false;

  var pMsg = "";

  logMsg([level: "info", msg: "running buildCubicLayout (buildMode=" + buildMode + ")..."]);
  logMsg(options);
  if (nodeSet) {
    var nodeCount = nodeSet.size;
    if (nodeCount > 0) {
      var filter = "* WHEREIN nodeType='" + nodeTypeData + "'";
      var nodeSetData = nodeSet.select(filter);
      var nodeCountData = nodeSetData.size;
 
      if (nodeCountData > 0) {
        filter = "* WHEREIN nodeType='" + nodeTypeX + "'";
        var nodeSetX = nodeSet.select(filter);

        if (buildMode == "XYZ") {
        } elseif (buildMode == "XY-Z") {
          filter = "* WHEREIN nodeType='" + nodeTypeZ + "'";
          var nodeSetZ = nodeSet.select(filter);
        } elseif (buildMode == "X-Y-Z") {
          filter = "* WHEREIN nodeType='" + nodeTypeY + "'";
          var nodeSetY = nodeSet.select(filter);
          filter = "* WHEREIN nodeType='" + nodeTypeZ + "'";
          var nodeSetZ = nodeSet.select(filter);

          
          # X-axis
          #   determine and sort neighbour data nodes and distribute axis nodes
          logMsg("  determining x-axis neighbours (nodeCountData=" + nodeCountdata + ")...");
          var neighboursX = [];
          var neighbourCountX = 0;
          var nodeCountX = nodeSetX.size;
          var nodeNumberX = 0;
          for (var nodeKey in nodeSetX.keys.sort) {
            if (neighbours.[nodeKey].type == "hash") {
              logMsg("    totalNeighbours=" + neighbours.[nodeKey].size);
              var subNeighboursX = [];
              var nodeNumber = nodeSetX.[nodeKey]..nodeNumber;
              var x = nodeNumberX * distanceX;
              var y = -1.5 * distanceY;
              var z = -1.5 * distanceZ;
              nodeSetX.[nodeKey]..x = x;
              nodeSetX.[nodeKey]..y = y;
              nodeSetX.[nodeKey]..z = z;
              {atomno=@nodeNumber}.x = x;
              {atomno=@nodeNumber}.y = y;
              {atomno=@nodeNumber}.z = z;
              for (var neighbourNodeKey in neighbours.[nodeKey]) {
                if (nodeSetData.[neighbourNodeKey].type == "hash") {
                  if (nodeSetData.[neighbourNodeKey]..nodeType == nodeTypeData) {
                    var neighbourNodeNumber = nodeSetData.[neighbourNodeKey]..nodeNumber;
                    nodeSetData.[neighbourNodeKey]..x = x;
                    {atomno=@neighbourNodeNumber}.x = x;
                  }
                }
              }
              #neighboursX += subNeighboursX.sort(sortKeyData);
              #neighbourCountX += subNeighboursX.size;
              #logMsg("    dataNeighbours=" + subNeighboursX.size);
            }
            nodeNumberX++;
          }

          # Y-axis
          #   determine and sort neighbour data nodes and distribute axis nodes
          logMsg("  determining y-axis neighbours (nodeCountData=" + nodeCountdata + ")...");
          var neighboursY = [];
          var neighbourCountY = 0;
          var nodeCountY = nodeSetY.size;
          var nodeNumberY = 0;
          for (var nodeKey in nodeSetY.keys.sort) {
            if (neighbours.[nodeKey].type == "hash") {
              logMsg("    totalNeighbours=" + neighbours.[nodeKey].size);
              var subNeighboursY = [];
              var nodeNumber = nodeSetY.[nodeKey]..nodeNumber;
              var y = nodeNumberY * distanceY;
              var x = -1.5 * distanceX;
              var z = -1.5 * distanceZ;
              nodeSetY.[nodeKey]..x = x;
              nodeSetY.[nodeKey]..y = y;
              nodeSetY.[nodeKey]..z = z;
              {atomno=@nodeNumber}.x = x;
              {atomno=@nodeNumber}.y = y;
              {atomno=@nodeNumber}.z = z;
              for (var neighbourNodeKey in neighbours.[nodeKey]) {
                if (nodeSetData.[neighbourNodeKey].type == "hash") {
                  if (nodeSetData.[neighbourNodeKey]..nodeType == nodeTypeData) {
                    var neighbourNodeNumber = nodeSetData.[neighbourNodeKey]..nodeNumber;
                    nodeSetData.[neighbourNodeKey]..y = y;
                    {atomno=@neighbourNodeNumber}.y = y;
                  }
                }
              }
              #neighboursY += subNeighboursY.sort(sortKeyData);
              #neighbourCountY += subNeighboursY.size;
              #logMsg("    dataNeighbours=" + subNeighboursY.size);
            }
            nodeNumberY++;
          }

          # Z-axis
          #   determine and sort neighbour data nodes and distribute axis nodes
          logMsg("  determining z-axis neighbours (nodeCountData=" + nodeCountdata + ")...");
          var neighboursZ = [];
          var neighbourCountZ = 0;
          var nodeCountZ = nodeSetZ.size;
          var nodeNumberZ = 0;
          for (var nodeKey in nodeSetZ.keys.sort) {
            if (neighbours.[nodeKey].type == "hash") {
              logMsg("    totalNeighbours=" + neighbours.[nodeKey].size);
              var subNeighboursZ = [];
              var nodeNumber = nodeSetZ.[nodeKey]..nodeNumber;
              var z = nodeNumberZ * distanceZ;
              var y = -1.5 * distanceY;
              var x =  -1.5 * distanceX;
              nodeSetZ.[nodeKey]..z = z;
              nodeSetZ.[nodeKey]..y = y;
              nodeSetZ.[nodeKey]..x = x;
              {atomno=@nodeNumber}.x = x;
              {atomno=@nodeNumber}.y = y;
              {atomno=@nodeNumber}.z = z;
              for (var neighbourNodeKey in neighbours.[nodeKey]) {
                if (nodeSetData.[neighbourNodeKey].type == "hash") {
                  if (nodeSetData.[neighbourNodeKey]..nodeType == nodeTypeData) {
                    var neighbourNodeNumber = nodeSetData.[neighbourNodeKey]..nodeNumber;
                    nodeSetData.[neighbourNodeKey]..z = z;
                    {atomno=@neighbourNodeNumber}.z = z;
                  }
                }
              }
              #neighboursZ += subNeighboursZ.sort(sortKeyData);
              #neighbourCountZ += subNeighboursZ.size;
              #logMsg("    dataNeighbours=" + subNeighboursZ.size);
            }
            nodeNumberZ++;
          }

        }
      }
    }
  }

  #log "FINISHED LAYOUT";
  pMsg = "finished layout - calculation time=" + now(startTime) + " ms";
  logMsg([level: "info", msg: pMsg]);

}

function buildCubicLayoutV1(dataHashref) {  # WORKS ON RAW DATA
  var startTime = now();
  var msg = "";
  var buildMode = "X-Y-Z";
  var subsetKey = "full";
  var nodeTypeX = "";
  var nodeTypeY = "";
  var nodeTypeZ = "";
  var nodeTypeData = "";
  var sortKeyData  = "nodeNumber";
  var distanceX = 0.05;
  var distanceY = 0.05;
  var distanceZ = 0.05;
  var neighbours = {};
  var nodeSet    = {};
  var options    = {};

  if (dataHashref.type == "hash") {
    if (dataHashref..layoutOptions.type == "hash") {
      options = dataHashref..layoutOptions;
    }
    if (dataHashref..currentSubsetKey != "") {
      subsetKey = dataHashref..currentSubsetKey;
    }
    if (dataHashref..subsets.type == "hash") {
      if (dataHashref..subsets.[subsetKey].type == "hash") {
        if (dataHashref..subsets.[subsetKey]..nodeInfo.type == "hash") {
          nodeSet = dataHashref..subsets.[subsetKey]..nodeInfo;
        }
        if (dataHashref..subsets.[subsetKey]..neighbours.type == "hash") {
          neighbours = dataHashref..subsets.[subsetKey]..neighbours;
        }
      }
    }
  } else {
    logMsg([level: "error", msg: "parameter 'dataHashref' must be a hash reference in call of method 'buildCubicLayout' - ABORTED METHOD"]);
    return false;
  }

  if (options..cubic..layoutType     == "") { options..cubic..layoutType = "cubic"; }
  if (options..cubic..frameSizeX     == "") { options..cubic..frameSizeX = 100; }
  if (options..cubic..frameSizeY     == "") { options..cubic..frameSizeY = 100; }
  if (options..cubic..frameSizeZ     == "") { options..cubic..frameSizeZ = 100; }
  if (options..cubic..distanceX     != "") { distanceX = options..cubic..distanceX; }
  if (options..cubic..distanceY     != "") { distanceY = options..cubic..distanceY; }
  if (options..cubic..distanceZ     != "") { distanceZ = options..cubic..distanceZ; }
  if (options..cubic..startCoordinateMode == "") { options..cubic..startCoordinateMode = "random"; }    # COORDINATES MUST BE SET TO ZERO IF 'random'
  #if (options..cubic. == "") { options..cubic. =  };

  if (options..cubic..nodeTypeX == "") {
    msg = msg + "ERROR: parameter 'options.cubic.nodeTypeX";
  } else {
    nodeTypeX = options..cubic..nodeTypeX;
    if (options..cubic..nodeTypeY == "") {
      nodeTypeY = nodeTypeX;
      buildMode = "XY-Z";
    } else {
      nodeTypeY = options..cubic..nodeTypeY;
    }
    if (options..cubic..nodeTypeZ == "") {
      nodeTypeZ = nodeTypeX;
      buildMode = "XYZ";
    } else {
      nodeTypeZ = options..cubic..nodeTypeZ;
    }
    if (options..cubic..nodeTypeData == "") {
      nodeTypedata = nodeTypeX;
    } else {
      nodeTypeData = options..cubic..nodeTypeData;
    }
    if (options..cubic..sortKeyData != "") {
      sortKeyData = options..cubic..sortKeyData;
    }
  }

  if (options["updateCoordinates"].type != "hash") { options["updateCoordinates"] = {} }
  options["updateCoordinates"]["final"] = false;

  var pMsg = "";

  logMsg([level: "info", msg: "running buildCubicLayout (buildMode=" + buildMode + ")..."]);
  logMsg(options);
  if (nodeSet) {
    var nodeCount = nodeSet.size;
    if (nodeCount > 0) {
      var filter = "* WHEREIN nodeType='" + nodeTypeData + "'";
      var nodeSetData = nodeSet.select(filter);
      var nodeCountData = nodeSetData.size;
 
      if (nodeCountData > 0) {
        filter = "* WHEREIN nodeType='" + nodeTypeX + "'";
        var nodeSetX = nodeSet.select(filter);

        if (buildMode == "XYZ") {
        } elseif (buildMode == "XY-Z") {
          filter = "* WHEREIN nodeType='" + nodeTypeZ + "'";
          var nodeSetZ = nodeSet.select(filter);
        } elseif (buildMode == "X-Y-Z") {
          filter = "* WHEREIN nodeType='" + nodeTypeY + "'";
          var nodeSetY = nodeSet.select(filter);
          filter = "* WHEREIN nodeType='" + nodeTypeZ + "'";
          var nodeSetZ = nodeSet.select(filter);

          
          # X-axis
          #   determine and sort neighbour data nodes and distribute axis nodes
          logMsg("  determining x-axis neighbours (nodeCountData=" + nodeCountdata + ")...");
          var neighboursX = [];
          var neighbourCountX = 0;
          for (var nodeKey in nodeSetX.keys.sort) {
            if (neighbours.[nodeKey].type == "hash") {
              logMsg("    totalNeighbours=" + neighbours.[nodeKey].size);
              var subNeighboursX = [];
              nodeSetX.[nodeKey]..x = neighbourCountX * distanceX;
              nodeSetX.[nodeKey]..y = -3.0 * distanceY;
              nodeSetX.[nodeKey]..z = -3.0 * distanceZ;
              for (var neighbourNodeKey in neighbours.[nodeKey]) {
                if (nodeSetData.[neighbourNodeKey].type == "hash") {
                  if (nodeSetData.[neighbourNodeKey]..nodeType == nodeTypeData) {
                    subNeighboursX.push(nodeSetData.[neighbourNodeKey]);
                  }
                }
              }
              neighboursX += subNeighboursX.sort(sortKeyData);
              neighbourCountX += subNeighboursX.size;
              logMsg("    dataNeighbours=" + subNeighboursX.size);
            }
          }

          #   distribute data nodes
          var x = 0.0;
          for (var neighbourNodeInfo in neighboursX) {
            neighbourNodeInfo..x = x;
            #logMsg("    nodeKey=" + neighbourNodeInfo..nodeKey + "  x=" + x + "  type=" + neighbourNodeInfo.type);
            logMsg(neighbourNodeInfo);
            x += distanceX;
          }

          # Y-axis
          #   determine and sort neighbour data nodes and distribute axis nodes
          logMsg("  determining y-axis neighbours...");
          var neighboursY = [];
          var neighbourCountY = 0;
          for (var nodeKey in nodeSetY.keys.sort) {
            if (neighbours.[nodeKey].type == "hash") {
              logMsg("    totalNeighbours=" + neighbours.[nodeKey].size);
              var subNeighboursY = [];
              nodeSetY.[nodeKey]..x = -3.0 * distanceX;
              nodeSetY.[nodeKey]..y = neighbourCountY * distanceY;
              nodeSetY.[nodeKey]..z = -3.0 * distanceZ;
              for (var neighbourNodeKey in neighbours.[nodeKey]) {
                if (nodeSetData.[neighbourNodeKey].type == "hash") {
                  if (nodeSetData.[neighbourNodeKey]..nodeType == nodeTypeData) {
                    subNeighboursY.push(nodeSetData.[neighbourNodeKey]);
                  }
                }
              }
              neighboursY += subNeighboursY.sort(sortKeyData);
              neighbourCountY += subNeighboursY.size;
              logMsg("    dataNeighbours=" + subNeighboursY.size);
            }
          }

          #   distribute data nodes
          var y = 0.0;
          for (var neighbourNodeInfo in neighboursY) {
            neighbourNodeInfo..y = y;
            logMsg("    nodeKey=" + neighbourNodeInfo..nodeKey + "  y=" + y);
            y += distanceY;
          }

          # Z-axis
          #   determine and sort neighbour data nodes and distribute axis nodes
          logMsg("  determining z-axis neighbours...");
          var neighboursZ = [];
          var neighbourCountZ = 0;
          for (var nodeKey in nodeSetZ.keys.sort) {
            if (neighbours.[nodeKey].type == "hash") {
              logMsg("    totalNeighbours=" + neighbours.[nodeKey].size);
              var subNeighboursZ = [];
              nodeSetY.[nodeKey]..x = -3.0 * distanceX;
              nodeSetZ.[nodeKey]..y = -3.0 * distanceY;
              nodeSetZ.[nodeKey]..z = neighbourCountZ * distanceZ;
              for (var neighbourNodeKey in neighbours.[nodeKey]) {
                if (nodeSetData.[neighbourNodeKey].type == "hash") {
                  if (nodeSetData.[neighbourNodeKey]..nodeType == nodeTypeData) {
                    subNeighboursZ.push(nodeSetData.[neighbourNodeKey]);
                  }
                }
              }
              neighboursZ += subNeighboursZ.sort(sortKeyData);
              neighbourCountZ += subNeighboursZ.size;
              logMsg("    dataNeighbours=" + subNeighboursZ.size);
            }
          }

          #   distribute data nodes
          var z = 0.0;
          for (var neighbourNodeInfo in neighboursZ) {
            neighbourNodeInfo..z = z;
            logMsg("    nodeKey=" + neighbourNodeInfo..nodeKey + "  z=" + z);
            z += distanceZ;
          }
        }
      }
    }
  }

  #log "FINISHED LAYOUT";
  pMsg = "finished layout - calculation time=" + now(startTime) + " ms";
  logMsg([level: "info", msg: pMsg]);

}

function applyNodeScalingFactor(options, data) {   # works on molecular level
  var currentSelection  = {selected};
  var scaleSelectedNodesOnly = false;
  var scaleRenderingType = "spacefill";
  var nodeScalingFactor = script("show vdw User").split("\n",true).[2].split("\t").[2];   # Determine current default van der waals radius for first element, all radii must be identical!

  if (options.type != "hash") {
    options = layoutOptions;
  }
  if (data.type != "hash") {
    data = networkData;
  }

  options.fr.nodeScalingFactor = nodeScalingFactor;

  if ("" + options.scaleSelectedNodesOnly != "") {
    scaleSelectedNodesOnly = options.scaleSelectedNodesOnly;
  }

  if ("" + options.scaleRenderingType != "") {
    scaleRenderingType = options.scaleRenderingType;
  }

  var renderingDef = {};
  if (data..networkDefinition..renderings.type == "hash") {
    renderingDef = data..networkDefinition..renderings;
  }

  var nodeTypeInfo = {};
  if (data..subsets..full.type == "hash") {
    if (data..subsets..full..nodeTypeInfo.type == "hash") {
      nodeTypeInfo = data..subsets..full..nodeTypeInfo;
    }
  }

  var defaultNodeSize = 15;
  if (renderingDef..default.type == "hash") {
    if (renderingDef..default..size != "") {
      defaultNodeSize = renderingDef..default..size;
    }
  }

  # Set properties for all nodes (including default size and color)
  set vdw User;
  if ("" + scaleSelectedNodesOnly == "true") {
    {selected}.vanderwaals = nodeScalingFactor;
  } else {
    {all}.vanderwaals = nodeScalingFactor;
    select all;
  }
  if (scaleRenderingType == "dots") {
    dots @{defaultNodeSize}%;
  } elseif (scaleRenderingType == "spacefill") {
    spacefill @{defaultNodeSize}%;
  } else {
    spacefill @{defaultNodeSize}%;
  }

  # Define rendering order
  var nodeTypesSorted = nodeTypeInfo.keys.sort;

  # Set individual node properties
  var renderingData = [];
  #logMsg("Applying node scaling factor...\n");
  #log renderingDef;
  for (var nodeType in nodeTypesSorted) {
    var selectionExpression = "";
    var nodeSize            = "";

    #logMsg("  initializing nodeType '" + nodeType + "'...\n");
    if (renderingDef.[nodeType].type == "hash") {
      selectionExpression = nodeTypeInfo..[nodeType]..selectionExpression;
      nodeSize            = renderingDef.[nodeType]..size;
      renderingData.push([selectionExpression: selectionExpression, nodeSize: nodeSize]);
      if (nodeTypeInfo..[nodeType]..subTypes.type == "hash") {
        for (var nodeSubType in nodeTypeInfo..[nodeType]..subTypes) {
          if (renderingDef.[nodeType]..subTypeSpecific.type == "hash") {
            if (renderingDef.[nodeType]..subTypeSpecific.[nodeSubType].type == "hash") {
              selectionExpression = nodeTypeInfo..[nodeType]..subTypes.[nodeSubType]..selectionExpression;
              nodeSize            = renderingDef.[nodeType]..subTypeSpecific.[nodeSubType]..size;
              renderingData.push([selectionExpression: selectionExpression, nodeSize: nodeSize]);
            }
          }
        }
      }
    } elseif (renderingDef..default.type == "hash") {
       selectionExpression = "all";
       nodeSize            = renderingDef..default..size;
       renderingData.push([selectionExpression: selectionExpression, nodeSize: nodeSize]);
    }
  }
  for (var entry in renderingData) {
    if (entry.type == "hash") {
      var selectionExpression = entry..selectionExpression;
      var nodeSize            = entry..nodeSize;
      if (selectionExpression != "") {
	if ("" + scaleSelectedNodesOnly == "true") {
	  select @currentSelection AND @selectionExpression;
	} else {
	  select @selectionExpression;
	}
        if (nodeSize != "") {
	  if (scaleRenderingType == "dots") {
	    #logMsg("    setting dot size: selExpr='" + selectionExpression + "'  col='" + color + "'  size='" + nodeSize + "'");
	    dots @{nodeSize}%;
	  } elseif (scaleRenderingType == "spacefill") {
	    spacefill @{nodeSize}%;
	  } else {
	    spacefill @{nodeSize}%;
	  }
        }
      }
    }
  }

  # Restore selection
  select @currentSelection;

}

function setNodeProperty(property, mode, data) {  # works on molecular level
  var currentSelection  = {selected};
  var currentBondModeOR = bondModeOR;
  var propertyName      = "";

  if (property.type == "hash") {
    propertyName = property..propertyName;
    mode         = property..mode;
    data         = property..data;
  } else {
    propertyName = property;
  }

  if (data.type != "hash") {
    data = networkData;
  }

  var renderingDef = {};
  if (data..networkDefinition..renderingDefinitions.type == "hash") {
    renderingDef = data..networkDefinition..renderingDefinitions;
  }

  var nodeTypeInfo = {};
  if (data..subsets..full.type == "hash") {
    if (data..subsets..full..nodeTypeInfo.type == "hash") {
      nodeTypeInfo = data..subsets..full..nodeTypeInfo;
    }
  }

  var defaultColor    = "black";
  var defaultNodeSize = 15;
  if (renderingDef..default.type == "hash") {
    if (renderingDef..default..size != "") {
      defaultNodeSize = renderingDef..default..size;
    }
    if (renderingDef..default..color != "") {
      defaultColor = renderingDef..default..color;
    }
  }

  # Set JSmol options
  set bondModeOR true;

  # Define rendering order
  var nodeTypesSorted = nodeTypeInfo.keys.sort;
  var nodeTypesFound  = {};
  if (networkData..networkDefinition..nodeTypeSortList.type == "array") {
    var nodeTypesSorted1 = [];
    var nodeTypesSorted2 = [];
    for (var nodeType in networkData..networkDefinition..nodeTypeSortList) {
      nodeTypesSorted2.push(nodeType);
      nodeTypesFound[nodeType]++;
    }
    for (var nodeType in nodeTypeInfo.keys.sort) {
      if (nodeTypesFound[nodeType] == "") {
        nodeTypesSorted1.push(nodeType);
      }
    }
    nodeTypesSorted = nodeTypesSorted1 + nodeTypesSorted2;   # nodes missing in 'networkDefinition..nodeTypeSortList' must be rendered first
  }

  # Set individual node property
  if (propertyName == "color" && mode == "nodeType") {
    var renderingData = [];
    for (var nodeType in nodeTypesSorted) {
      var selectionExpression = "";
      var color               = defaultColor;

      if (renderingDef.[nodeType].type == "hash") {
        selectionExpression = nodeTypeInfo..[nodeType]..selectionExpression;
        if ("" + renderingDef.[nodeType]..default..color != "") {
          color = renderingDef.[nodeType]..default..color;
        }
        renderingData.push([selectionExpression: selectionExpression, color: color]);
        if (nodeTypeInfo..[nodeType]..subTypes.type == "hash") {
          for (var nodeSubType in nodeTypeInfo..[nodeType]..subTypes) {
            var color_2 = color;
            if (renderingDef.[nodeType]..subTypeSpecific.type == "hash") {
              if (renderingDef.[nodeType]..subTypeSpecific.[nodeSubType].type == "hash") {
                selectionExpression = nodeTypeInfo.[nodeType]..subTypes.[nodeSubType]..selectionExpression;
                if ("" + renderingDef.[nodeType]..subTypeSpecific.[nodeSubType]..color != "") {
                  color_2 = renderingDef.[nodeType]..subTypeSpecific.[nodeSubType]..color;
                }
                renderingData.push([selectionExpression: selectionExpression, color: color_2]);
              }
            }
          }
        }
      } else {
        selectionExpression = "all";
        renderingData.push([selectionExpression: selectionExpression, color: color]);
      }
    }
    for (var entry in renderingData) {
      if (entry.type == "hash") {
        var selectionExpression = entry..selectionExpression;
        var color               = entry..color;
        if (selectionExpression != "") {
          select @currentSelection and @selectionExpression;
          if (color != "") {
            color @color;
            #color bonds @color;
          }
        }
      }
    }
  }

  if (propertyName == "color" && mode == "lifespanChangeQualitative") {
    selectByInfoKey("observationType", "phenotype_2", "and");
    setNodeProperty("color", "nodeType");
    var selectionExpression = "[AF_*]";
    select @currentSelection and @selectionExpression;
    setTemperatureByNeighbours([action: "setValueAndColorAndTemperature", nodeBitset:{selected}])
  }

  if (propertyName == "color" && mode == "edgeCount") {
    colorByDegree({selected});
  }

  # Set individual node property
  if (propertyName == "rendering" && mode == "nodeType") {
  }

  # Restore selection and bondmode
  select @currentSelection;
  set bondModeOR @currentBondmodeOR;

}

function setNodeScalingFactor(scalingFactor) {
  var elementData   = [];
  var elementCount = 109;

  if (scalingFactor != "") {
    if (scalingFactor > 0) {
      for (var i FROM [1 elementCount]) {
        elementData.push("" + i + "  " + scalingFactor);
      }
      var dataCommand = 'data "element_vdw" ' + elementData.join("; ") + ' END "element_vdw"';
      var dummy = script(dataCommand);
      set vdw User;
    }
  }
}

function initDisplay(options, data) {
  var currentSelection = {selected};

  if (options.type != "hash") {
    options = layoutOptions;
  }
  if (data.type != "hash") {
    data = networkData;
  }

  if (options.fr.nodeScalingFactor <= 0) {
    options.fr.nodeScalingFactor = 1.7;
  }
  if (options.fr.edgeScalingFactor <= 0) {
    options.fr.edgeScalingFactor = 0.05;
  }

  var renderingDef = {};
  if (data..networkDefinition..renderingDefinitions.type == "hash") {
    renderingDef = data..networkDefinition..renderingDefinitions;
  }

  var nodeTypeInfo = {};
  if (data..subsets..full.type == "hash") {
    if (data..subsets..full..nodeTypeInfo.type == "hash") {
      nodeTypeInfo = data..subsets..full..nodeTypeInfo;
    }
  }

  var defaultColor    = "lightgrey";
  var defaultNodeSize = 15;
  var defaultLabelSize = 12;
  var defaultLabelColor = "none";
  var defaultLabelBackground = "[250, 250, 250]";
  var defaultLabelOffsetX = 3;
  var defaultLabelOffsetY = 3;
  if (renderingDef..default.type == "hash") {
    if (renderingDef..default..size != "") {
      defaultNodeSize = renderingDef..default..size;
    }
    if (renderingDef..default..labelSize != "") {
      defaultLabelSize = renderingDef..default..labelSize;
    }
    if (renderingDef..default..labelColor != "") {
      defaultLabelColor = renderingDef..default..labelColor;
    }
    if (renderingDef..default..labelBackground != "") {
      defaultLabelBackground = renderingDef..default..labelBackground;
    }
    if (renderingDef..default..labelOffsetX != "") {
      defaultLabelOffsetX = renderingDef..default..labelOffsetX;
    }
    if (renderingDef..default..labelOffsetY != "") {
      defaultLabelOffsetY = renderingDef..default..labelOffsetY;
    }
  }

  var edgeSize = options.fr.edgeScalingFactor * options.fr.nodeScalingFactor;  
  edgeSize = [edgeSize 3.0].min;

  # Set JSmol options
  set bondmode or;

  # Set properties for all nodes (including default size and color)
  #setNodeScalingFactor(options, data);   # DONE LATER NOW in 'update_display'
  #applyNodeScalingFactor(options, data); # DONE LATER NOW in 'update_display'
  select all;
  backbone off;
  wireframe @{edgeSize};
  if (defaultColor != "") {
    color @defaultColor;
  } else {
    color cpk;
  }
  if (defaultLabelSize !="") {
    set fontSize @defaultLabelSize;
  }
  if (defaultLabelBackground !="") {
    background label @defaultLabelBackground;
  }
  if ("" + defaultLabelOffsetX !="") {
    if ("" + defaultLabelOffsetY !="") {
      set labelOffset @defaultLabelOffsetX @defaultLabelOffsetY;
    }
  }

  # Define rendering order
  var nodeTypesSorted = nodeTypeInfo.keys.sort;
  var nodeTypesFound  = {};
  if (networkData..networkDefinition..nodeTypeSortList.type == "array") {
    var nodeTypesSorted1 = [];
    var nodeTypesSorted2 = [];
    for (var nodeType in networkData..networkDefinition..nodeTypeSortList) {
      nodeTypesSorted2.push(nodeType);
      nodeTypesFound[nodeType]++;
    }
    for (var nodeType in nodeTypeInfo.keys.sort) {
      if (nodeTypesFound[nodeType] == "") {
        nodeTypesSorted1.push(nodeType);
      }
    }
    nodeTypesSorted = nodeTypesSorted1 + nodeTypesSorted2;   # nodes missing in 'networkDefinition..nodeTypeSortList' must be rendered first
  }

  # Set individual node properties
  var renderingData = [];
  #logMsg("Initializing node rendering...\n");
  #log renderingDef;
  renderingData.push([selectionExpression: "all", color: defaultColor, labelSize: defaultLabelSize, labelColor: defaultLabelColor, labelBackground: defaultLabelBackground, labelOffsetX: defaultLabelOffsetX, labelOffsetY: defaultLabelOffsetY]);
  for (var nodeType in nodeTypesSorted) {
    var selectionExpression = "";
    var color               = defaultColor;
    var labelSize           = defaultLabelSize;
    var labelColor          = defaultLabelColor;
    var labelBackground     = defaultLabelBackground;
    var labelOffsetX        = defaultLabelOffsetX;
    var labelOffsetY        = defaultLabelOffsetY;

    if (renderingDef.[nodeType].type == "hash") {
      selectionExpression = nodeTypeInfo..[nodeType]..selectionExpression;
      if (renderingDef.[nodeType]..default.type == "hash") {
        if ("" + renderingDef.[nodeType]..default..color != "") {
          color = renderingDef.[nodeType]..default..color;
        }
        if ("" + renderingDef.[nodeType]..default..labelSize != "") {
          labelSize = renderingDef.[nodeType]..default..labelSize;
        }
        if ("" + renderingDef.[nodeType]..default..labelColor != "") {
          labelColor = renderingDef.[nodeType]..default..labelColor;
        }
        if ("" + renderingDef.[nodeType]..default..labelBackground != "") {
          labelBackground = renderingDef.[nodeType]..default..labelBackground;
        }
        if ("" + renderingDef.[nodeType]..default..labelOffsetX != "") {
          labelOffsetX = renderingDef.[nodeType]..default..labelOffsetX;
        }
        if ("" + renderingDef.[nodeType]..default..labelOffsetY != "") {
          labelOffsetY = renderingDef.[nodeType]..default..labelOffsetY;
        }
      }
      renderingData.push([selectionExpression: selectionExpression, color: color, labelSize: labelSize, labelColor: labelColor, labelBackground: labelBackground, labelOffsetX: labelOffsetX, labelOffsetY: labelOffsetY]);

      if (nodeTypeInfo..[nodeType]..subTypes.type == "hash") {
        var color_2               = color;
        var labelSize_2           = labelSize;
        var labelColor_2          = labelColor;
        var labelBackground_2     = labelBackground;
        var labelOffsetX_2        = labelOffsetX;
        var labelOffsetY_2        = labelOffsetY;
        for (var nodeSubType in nodeTypeInfo..[nodeType]..subTypes) {
          #logMsg("    initializing subType '" + nodeSubType + "' of nodeType '" + nodeType + "'...\n");
          if (renderingDef.[nodeType]..subTypeSpecific.type == "hash") {
            #logMsg("      found hash for subType '" + nodeSubType + "' of nodeType '" + nodeType + "'...\n");
            if (renderingDef.[nodeType]..subTypeSpecific.[nodeSubType].type == "hash") {
              selectionExpression = nodeTypeInfo..[nodeType]..subTypes.[nodeSubType]..selectionExpression;
              if ("" + renderingDef.[nodeType]..subTypeSpecific.[nodeSubType]..color != "") {
                color_2 = renderingDef.[nodeType]..subTypeSpecific.[nodeSubType]..color;
              }
              if ("" + renderingDef.[nodeType]..subTypeSpecific.[nodeSubType]..labelSize != "") {
                labelSize_2 = renderingDef.[nodeType]..subTypeSpecific.[nodeSubType]..labelSize;
              }
              if ("" + renderingDef.[nodeType]..subTypeSpecific.[nodeSubType]..labelColor != "") {
                labelColor_2 = renderingDef.[nodeType]..subTypeSpecific.[nodeSubType]..labelColor;
              }
              if ("" + renderingDef.[nodeType]..subTypeSpecific.[nodeSubType]..labelBackground != "") {
                labelBackground_2 = renderingDef.[nodeType]..subTypeSpecific.[nodeSubType]..labelBackground;
              }
              if ("" + renderingDef.[nodeType]..subTypeSpecific.[nodeSubType]..labelOffsetX != "") {
                labelOffsetX_2 = renderingDef.[nodeType]..subTypeSpecific.[nodeSubType]..labelOffsetX;
              }
              if ("" + renderingDef.[nodeType]..subTypeSpecific.[nodeSubType]..labelOffsetY != "") {
                labelOffsetY_2 = renderingDef.[nodeType]..subTypeSpecific.[nodeSubType]..labelOffsetY;
              }
              renderingData.push([selectionExpression: selectionExpression, color: color_2, labelSize: labelSize_2, labelColor: labelColor_2, labelBackground: labelBackground_2, labelOffsetX: labelOffsetX_2, labelOffsetY: labelOffsetY_2]);
            }
          }
        }
      }
    }
  }
  for (var entry in renderingData) {
    if (entry.type == "hash") {
      var selectionExpression = entry..selectionExpression;
      var color               = entry..color;
      var labelSize           = entry..labelSize;
      var labelColor          = entry..labelColor;
      var labelBackground     = entry..labelBackground;
      var labelOffsetX        = entry..labelOffsetX;
      var labelOffsetY        = entry..labelOffsetY;
      #logMsg("  selExpr='" + selectionExpression + "'  col='" + color + "'\n");
      if (selectionExpression != "") {
        select @selectionExpression;
        if ("" + color != "") {
          color @color;
          color bonds @color;
        }
        if ("" + labelSize != "") {
          set fontSize @labelSize;
        }
        if ("" + labelColor != "") {
          color label @labelColor;
        }
        if ("" + labelBackground != "") {
          background label @labelBackground;
        }
        if ("" + labelOffsetX != "") {
          if ("" + labelOffsetY != "") {
            set labelOffset @labelOffsetX @labelOffsetY;
          }
        }
      }
    }
  }


  # Make edges translucent
  select all;
  color bonds translucent 4;

  # Restore selection
  select @currentSelection;

  # Update display
  if (options["updateDisplay"].type != "hash") { options["updateDisplay"] = {} }
  #options["updateDisplay"]["center"] = true;
  #options["updateDisplay"]["zoom"] = true;
  updateDisplay(options);

  #print renderingData;
}

function updateDisplay(options) {
  var currentSelection = {selected};
  if (options.fr.nodeScalingFactor <= 0) {
    options.fr.nodeScalingFactor = 1.7;
  }
  if (options.fr.edgeScalingFactor <= 0) {
    options.fr.edgeScalingFactor = 0.05;
  }
  #if ({all}.vanderwaals != options.fr.nodeScalingFactor) {
    setNodeScalingFactor(options.fr.nodeScalingFactor);
    options.scaleSelectedNodesOnly = false; 
    options.scaleRenderingType     = "spacefill";
    applyNodeScalingFactor(options);
    #initDisplay(options);   # ??? DEACTIVATED BECAUSE OF ENDLESS LOOP ????
  #}

  select all;
  edgeSize = options.fr.edgeScalingFactor * options.fr.nodeScalingFactor;
  edgeSize = [edgeSize 3.0].min;
  wireframe @{edgeSize}

  if (options["updateDisplay"].type != "hash") { options["updateDisplay"] = {"center": true, "zoom": true} }
  if (options["updateDisplay"]["center"] == true) {
    center displayed;
  }
  if (options["updateDisplay"]["zoom"] == true) {
    zoom 0;
  }
  select @currentSelection;
  delay 0;
}

function setScale(scaleInfo, options) {
  var changedScale = false;
   var autoZoom    = false;
  logMsg(scaleInfo);
  if (scaleInfo.type == "hash") {
    if (options.type != "hash") {
      options = layoutOptions;
    }

    var keyList = scaleInfo.keys;
    #log keyList;
    for (var currentKey in keyList) {
      var currentValue = scaleInfo.[currentKey];
      #log "DEBUG: currentKey=" + currentKey + " currentValue=" + currentValue;
      if (currentKey == "node") {
        if (currentValue > 0) {
          options.fr.nodeScalingFactor = currentValue;
          changedScale = true;
        }
      } elseif (currentKey == "edge") {
        if (currentValue > 0) {
          options.fr.edgeScalingFactor = currentValue;
          changedScale = true;
        }
      } elseif (currentKey == "frameSize") {
        if (currentValue > 0) {
          options.fr.fullFrameSizeX = currentValue;
          options.fr.fullFrameSizeY = currentValue;
          options.fr.fullFrameSizeZ = currentValue;
          options.fr.frameSizeX     = currentValue;
          options.fr.frameSizeY     = currentValue;
          options.fr.frameSizeZ     = currentValue;
        }
      } elseif (currentKey == "autoZoom") {
        if (currentValue.type == "boolean") {
          autoZoom = currentValue;
        }
      }
    }

    if (changedScale == true) {
      options..updateDisplay..zoom = autoZoom;
      updateDisplay(options);
    }
  }
}

function rotateBest(nodeSet) {
  if (nodeSet.type != "bitset") {
    nodeSet = {displayed};
  }

  # ### Determine boundbox vector ###
  boundbox (@nodeSet);
  bound_box = getProperty("boundboxInfo", "vector");
  vector_x  = bound_box.x;
  vector_y  = bound_box.y;
  vector_z  = bound_box.z;
  max_boundbox_vector = vector_x;
  if (vector_y > max_boundbox_vector) {
    max_boundbox_vector = vector_y;
  }
  if (vector_z > max_boundbox_vector) {
    max_boundbox_vector = vector_z;
  }
  logMsg("searching orientation...");
  checkCase = 1
  if ((vector_x > vector_z) AND (vector_z > vector_y)) {
    move 90 0 0 0 0 0 0 0 0;
    move 0 0 90 0 0 0 0 0 0;
    logMsg("  found checkCase " + checkCase);
  }
  checkCase = 2
  if ((vector_x > vector_y) AND (vector_y > vector_z)) {
    move 0 0 90 0 0 0 0 0 0;
    logMsg("  found checkCase " + checkCase);
  }
  checkCase = 3
  if ((vector_y > vector_x) AND (vector_x > vector_z)) {
    # do not do anything
    logMsg("  found checkCase " + checkCase);
  }
  checkCase = 4
  if ((vector_y > vector_z) AND (vector_z > vector_x)) {
    move 0 90 0 0 0 0 0 0 0;
    logMsg("  found checkCase " + checkCase);
  }
  checkCase = 5
  if ((vector_z > vector_y) AND (vector_y > vector_x)) {
    move 90 0 0 0 0 0 0 0 0;
    move 0 90 0 0 0 0 0 0 0;
    logMsg("  found checkCase " + checkCase);
  }
  checkCase = 6
  if ((vector_z > vector_x) AND (vector_x > vector_y)) {
    move 90 0 0 0 0 0 0 0 0;
    logMsg("  found checkCase " + checkCase);
  }
  checkCase = 7
  if ((vector_x = vector_y) AND (vector_y > vector_z)) {
    # do not do anything
    logMsg("  found checkCase " + checkCase);
  }
  checkCase = 8
  if ((vector_z > vector_x) AND (vector_x = vector_y)) {
    move 90 0 0 0 0 0 0 0 0;
    logMsg("  found checkCase " + checkCase);
  }
  checkCase = 9
  if ((vector_x = vector_z) AND (vector_z > vector_y)) {
    move 90 0 0 0 0 0 0 0 0;
    logMsg("  found checkCase " + checkCase);
  }
  checkCase = 10
  if ((vector_y > vector_x) AND (vector_x = vector_z)) {
    # do not do anything
    logMsg("  found checkCase " + checkCase);
  }
  checkCase = 11
  if ((vector_x > vector_y) AND (vector_y = vector_z)) {
    move 0 0 90 0 0 0 0 0 0;
    logMsg("  found checkCase " + checkCase);
  }
  #
  checkCase = 12
  if ((vector_x < vector_y) AND (vector_y = vector_z)) {
    move 90 0 0 0 0 0 0 0 0;
    logMsg("  found checkCase " + checkCase);
  }
  checkCase = 13
  if ((vector_x = vector_z) AND (vector_z < vector_y)) {
    # do not do anything
    logMsg("  found checkCase " + checkCase);
  }
  checkCase = 14
  if ((vector_x = vector_y) AND (vector_y < vector_z)) {
    move 90 0 0 0 0 0 0 0 0;
    logMsg("  found checkCase " + checkCase);
  }
  checkCase = 15
  if ((vector_x = vector_y) AND (vector_y = vector_z)) {
    # do not do anything
    logMsg("  found checkCase " + checkCase);
  }


}

function adjustEdgeLength(dataHashref, nodeSet) {
  var edgeScalingFactor = 0.5;
  var singleEdgeNodes   = {selected and bondcount=1};
  if (dataHashref.type != "hash") {
    edgeScalingFactor = dataHashref;
    if (nodeSet.type == "bitset") {
      singleEdgeNodes = nodeSet;
    }
  } else {
    if (dataHashref..edgeScalingFactor != "") {
      edgeScalingFactor = dataHashref..edgeScalingFactor;
    }
    if (dataHashref..nodeSet.type == "bitset") {
      singleEdgeNodes = dataHashref..nodeSet;
    }
  }

  if (singleEdgeNodes.size > 0) {
    for (var singleEdgeNode IN singleEdgeNodes) {
      var multiEdgeNode   = {connected(singleEdgeNode) and bondcount>1};
      if (multiEdgeNode.type == "bitset" && multiEdgeNode.size == 1) {
        var p1              = multiEdgeNode.xyz;
        var p2              = singleEdgeNode.xyz;
        var currentDistance = distance(p1,p2);
        var newLength       = currentDistance * edgeScalingFactor;

        #print "average=" + averageEdgeLength + "  median=" +  medianEdgeLength + "  dist=" + currentDistance + "  new=" + newLength;
        var p2New           = (((p2 - p1) / currentDistance) * newLength) + p1;
        #show distanceListSorted;

        singleEdgeNode.xyz = p2New;
      }
    }
  }
}


function getSubsetIds(mode) {   # works on 'molecular' level ('subset'='frame')
  var modelInfo            = getProperty("modelInfo");
  var subsetCount          = modelInfo..modelCount;
  var activeSubsetCount    = modelInfo..modelCountSelected;
  var activeSubsetNumbers  = [];
  var subsetIds            = [];
  var changedActiveSubsets = false;

  if (mode == "") {
    mode = "all";
  }

  if (mode == "all") {
    if (subsetCount > 0) {
      if (activeSubsetCount < subsetCount) {
        # Store current active subset list ('file_model' property needed for restoring with 'frame' command)
        for (var subsetInfo IN modelInfo..models) {
          activeSubsetNumbers.push(subsetInfo..file_model);
        }
        changedActiveSubsets = true;
        frame all;
        modelInfo = getProperty("modelInfo");
      }
    }
  }

  
}

function selectNeighbours(mode, level) {   # works on 'molecular' level
  if (level > 0) {
    if (mode == "replace") {
      select connected(selected);
    } elseif (mode == "add") {
      select selected OR connected(selected);
    }
    if (level > 1) {
      selectNeighbours(mode, level - 1);
    }
  }
}

function getNeighbours(nodeSet, level, mode) {   # works on 'molecular' level
  var neighbourNodeSet = {none};

  # Set defaults
  if (mode == "") {
    mode = "add";
  }
  if ("" + level == "") {
    level = 1;
  }
  if (nodeSet.type != "bitset") {
    nodeSet = {selected};
  }

  if (level > 0) {
    if (mode == "replace-degree_1") {   # Reduce to nodes with degree 1
      neighbourNodeSet = {connected(@nodeSet) AND bondcount=1};
    } else {
      neighbourNodeSet = {connected(@nodeSet)};
    }
    if (level > 1) {
      if (mode == "hoverReplace") {
        neighbourNodeSet = getNeighbours(neighbourNodeSet, level - 1, "replace");
      } elseif (mode == "replace-degree_1") {   # Reduce to nodes with degree 1
        # nothing to do, neighbour nodes with degree 1 cannot have any furthe connected nodes
      } else {
        neighbourNodeSet = getNeighbours(neighbourNodeSet, level - 1, mode);
      }
    }
  }

  if (mode == "replace") {
    neighbourNodeSet = neighbourNodeSet AND NOT nodeSet;
  } elseif (mode == "hoverReplace") {
    neighbourNodeSet = neighbourNodeSet OR nodeSet;
  } elseif (mode == "add") {
    neighbourNodeSet = neighbourNodeSet OR nodeSet;
  } elseif (mode == "replace-degree_1") {   # Reduce to nodes with degree 1
    #neighbourNodeSet = (neighbourNodeSet AND {bondcount=1}) AND NOT nodeSet;
    neighbourNodeSet = neighbourNodeSet  AND NOT nodeSet;
  }

  return neighbourNodeSet;
}

function setTemperatureByNeighbours(dataHashref) {   # works on 'molecular' level using 'raw data'
  var msg                = "";
  var subsetKey          = "";
  var nodeInfo           = {};
  var neighbours         = {};
  var currentNetworkData = {};
  var subset             = {};
  var knownActions = {"setColorOnly": true, "setColorAndTemperatureOnly": true, "setValueAndTemperatureOnly": true, "setValueOnly": true, "setValueAndColorAndTemperature": true};
  var action                            = "setValueAndColorAndTemperature";
  var nodeType                          = "ageingFactor";
  var colorInfoKey                      = "lifespanColor";
  var neighbourTemperatureInfoKey       = "neighbourTemperature";
  var neighbourNodeType                 = "observation";
  var neighbourNodeSubtypeProperty      = "observationType";
  var neighbourNodeSubtypePropertyValue = "phenotype_2";
  var colors = [neutral: "grey", positive: "yellowgreen", negative: "red", mixed: "darkorange", undefined: "black"];
  var colorClassBoundary = 80;

  # Check required parameters
  if (dataHashref.type != "hash") {
    if (dataHashref.type == "bitset") {
      if (networkData.type == "hash") {
        currentNetworkData = networkData;
      }
      if (currentNetworkData..currentSubsetKey == "") {
        subsetKey = "full";
      } else {
        subsetKey = currentNetworkData..currentSubsetKey;
      }
      if (currentNetworkData..subsets.[subsetKey].type != "hash") {
        msg = msg + "ERROR: no subset subhash found for subset '" + subsetKey + "' in call of method 'setTemperatureByNeighbours'\n";
      } else {
        subset = currentNetworkData..subsets.[subsetKey];
      }
    } else {
      msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED as hashref or bitset in call of method 'setTemperatureByNeighbours'\n";
    }
  } else {
    if (dataHashref..neighbourTemperatureInfoKey != "") {
      neighbourTemperatureInfoKey = dataHashref..neighbourTemperatureInfoKey;
    }
    if (dataHashref..neighbourNodeType != "") {
      neighbourNodeType = dataHashref..neighbourNodeType;
    }
    if (dataHashref..neighbourNodeSubtypeProperty != "") {
      neighbourNodeSubtypeProperty = dataHashref..neighbourNodeSubtypeProperty;
    }
    if (dataHashref..neighbourNodeSubtypePropertyValue != "") {
      neighbourNodeSubtypePropertyValue = dataHashref..neighbourNodeSubtypePropertyValue;
    }
    if (dataHashref..colorInfoKey != "") {
      colorInfoKey = dataHashref..colorInfoKey;
    }
    if (dataHashref..action != "") {
      action = dataHashref..action;
    }

    if (dataHashref..networkData.type == "hash") {
      currentNetworkData = dataHashref..networkData;
    } else {
      if (networkData.type == "hash") {
        currentNetworkData = networkData;
      }
    }
    if (dataHashref..currentSubsetKey == "") {
      if (currentNetworkData..currentSubsetKey == "") {
        subsetKey = "full";
      } else {
        subsetKey = currentNetworkData..currentSubsetKey;
      }
    } else {
      subsetKey = dataHashref..currentSubsetKey;
    }
    if (currentNetworkData..subsets.[subsetKey].type != "hash") {
      msg = msg + "ERROR: no subset subhash found for subset '" + subsetKey + "' in call of method 'setTemperatureByNeighbours'\n";
    } else {
      subset = currentNetworkData..subsets.[subsetKey];
    }


  }

  if (subset..neighbours.type == "hash") {
    neighbours = subset..neighbours;
  } else {
    msg = msg + "ERROR: no neighbour subhash found for subset '" + subsetKey + "' in call of method 'setTemperatureByNeighbours'\n";
  }

  if (knownActions[action] == "") {
    msg = msg + "ERROR: unknown action '" + action + "' PROVIDED in call of method 'setTemperatureByNeighbours'\n";
  }


  #log "============ dataHashref (setTemperatureByNeighbours) ==============";
  #log dataHashref;

  if (msg != "") {
    print msg;
    logMsg([level: "error", msg:  msg]);
    return;
  }

  nodeInfo = getNodeInfo(dataHashref);
  var subsetNodeInfo = subset..nodeInfo;

  #   set neighbourTemperature
  if (nodeInfo.size > 0) {

    for (var nodeKey IN nodeInfo) {
      var currentNodeInfo   = nodeInfo[nodeKey];
      if (currentNodeInfo.type == "hash") {
        var currentNodeNumber  = currentNodeInfo..nodeNumber;
        var currentNodeType    = currentNodeInfo..nodeType;
        var caseCode           = 0;
        var neighbourTemperatureCounts = [positive: 0, neutral: 0, negative: 0, any: 0];
        var maxIncreased       = 0;
        var maxDecreased       = 0;

        if (currentNodeType == nodeType || nodeType == "") {
          if (action == "setColorOnly") {
            var currentColor = currentNodeInfo.[colorInfoKey];
            if (currentColor != "") {
              var dummy = script("color {atomno=@currentNodeNumber}" +  currentColor);
            }
          } elseif (action == "setColorAndTemperatureOnly") {
            var currentColor = currentNodeInfo.[colorInfoKey];
            if (currentColor != "") {
              var dummy = script("color {atomno=@currentNodeNumber}" +  currentColor);
              var currentTemperature = currentNodeInfo.[neighbourTemperatureInfoKey];
              currentNodeInfo..temperature = currentTemperature;
              var dummy = script("{atomno=@currentNodeNumber}.temperature = " +  currentTemperature);
            }
          } elseif (action == "setValueAndColorAndTemperature" || action == "setValueAndTemperatureOnly" || action == "setValueOnly") {
            if (neighbours[nodeKey].type == "hash") {
              if (neighbours[nodeKey].size > 0) {
                for (var neighbourNodeKey IN neighbours[nodeKey]) {
                  var currentNeighbour = subsetNodeInfo[neighbourNodeKey];
                  if (currentNeighbour.type == "hash") {
                    if (currentNeighbour..nodeType == neighbourNodeType) {
                      if (currentNeighbour[neighbourNodeSubtypeProperty] == neighbourNodeSubtypePropertyValue) {
                        var currentTemperature = currentNeighbour..temperature;
                        neighbourTemperatureCounts..any++;
                        switch(currentNeighbour..lifespanEffectSignificant) {
                          case "increased":
                            if (neighbourTemperatureCounts..positive == 0) {
                              caseCode = caseCode + 4;
                            }
                            neighbourTemperatureCounts..positive++;
                            maxIncreased = [maxIncreased, currentTemperature].max;
                            break;
                          case "decreased":
                            if (neighbourTemperatureCounts..negative == 0) {
                              caseCode = caseCode + 8;
                            }
                            neighbourTemperatureCounts..negative++;
                            maxDecreased = [maxDecreased, currentTemperature].min;
                            break;
                          case "none":
                            if (neighbourTemperatureCounts..neutral == 0) {
                              caseCode = caseCode + 1;
                            }
                            neighbourTemperatureCounts..neutral++;
                            break;
                        }
                      }
                    }
                  } else {
                    logMsg([level: "warn", msg: "  'currentNeighbour' of '" + nodeKey + " ' with nodeKey '" + neighbourNodeKey+ "' is not a hash in method 'setTemperatureByNeighbours'"]);
                  }
                  #logMsg("  nodeKey='" + nodeKey + "'  neighbourNodeKey='" + neighbourNodeKey+ "'  nt='" + currentNeighbour..nodeType + "'  nnsp='" + currentNeighbour[neighbourNodeSubtypeProperty] + "'  temp='" + currentNeighbour..temperature + "'  caseCode='" + caseCode + "'\n");
                }

                #logMsg("nodeKey='" + nodeKey + "'  caseCode='" + caseCode + "'\n");
                #log neighbourTemperatureCounts;

                if (caseCode == 0 ) {   # 'undefined'
                  currentNodeInfo.[colorInfoKey] = colors..undefined;
                  currentNodeInfo.[neighbourTemperatureInfoKey] = -100.0;
                  if (action == "setValueAndColorAndTemperature") {
                    currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    {atomno=@currentNodeNumber}.color = colors..undefined;
                  }
                  if (action == "setValueAndTemperatureOnly") {
                    currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                  }
                } elseif (caseCode == 1 ) {   # only 'neutral'
                  currentNodeInfo.[colorInfoKey] = colors..neutral;
                  currentNodeInfo.[neighbourTemperatureInfoKey] = 0.0;
                  if (action == "setValueAndColorAndTemperature") {
                    currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    {atomno=@currentNodeNumber}.color = colors..neutral;
                  }
                  if (action == "setValueAndTemperatureOnly") {
                    currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
		  }
                } elseif (caseCode == 4) {   # only 'positive'
                  currentNodeInfo.[colorInfoKey] = colors..positive;
                  currentNodeInfo.[neighbourTemperatureInfoKey] = maxIncreased;
                  if (action == "setValueAndColorAndTemperature") {
                    currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    {atomno=@currentNodeNumber}.color = colors..positive;
                  }
                  if (action == "setValueAndTemperatureOnly") {
                    currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                  }
                } elseif (caseCode == 8) {   # only 'negative'
                  currentNodeInfo.[colorInfoKey] = colors..negative;
                  currentNodeInfo.[neighbourTemperatureInfoKey] = maxDecreased;
                  if (action == "setValueAndColorAndTemperature") {
                    currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    {atomno=@currentNodeNumber}.color = colors..negative;
                  }
                  if (action == "setValueAndTemperatureOnly") {
                    currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                  }
                } elseif (caseCode == 12) {   # 'negative' and 'positive'
                  var percentPositive = 100.0 * neighbourTemperatureCounts..positive / neighbourTemperatureCounts..any;
                  var percentNegative = 100.0 * neighbourTemperatureCounts..negative / neighbourTemperatureCounts..any;
                  #logMsg("   nno='" + currentNodeNumber + "'  positive='" + percentPositive + "' (" + neighbourTemperatureCounts..positive+ ") negative='" + percentNegative + " (" + neighbourTemperatureCounts..negative + ") any=" + percentNegative + " (" + neighbourTemperatureCounts..any + ")");
                  if (percentPositive >= colorClassBoundary) {
                    var currentColor = "" + colors..positive + " translucent 4";
                    currentNodeInfo.[colorInfoKey] = currentColor;
                    currentNodeInfo.[neighbourTemperatureInfoKey] = maxIncreased;
                    if (action == "setValueAndColorAndTemperature") {
                      currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                      {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                      var dummy = script("color {atomno=@currentNodeNumber}" +  currentColor);
                    }
                    if (action == "setValueAndTemperatureOnly") {
                      currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                      {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    }
                  } elseif (percentNegative >= colorClassBoundary) {
                    var currentColor = "" + colors..negative + " translucent 4";
                    currentNodeInfo.[colorInfoKey] = currentColor;
                    currentNodeInfo.[neighbourTemperatureInfoKey] = maxDecreased;
                    if (action == "setValueAndColorAndTemperature") {
                      currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                      {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                      var dummy = script("color {atomno=@currentNodeNumber}" +  currentColor);
                    }
                    if (action == "setValueAndTemperatureOnly") {
                      currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                      {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    }
                } else {
                    currentNodeInfo.[colorInfoKey] = colors..mixed;
                    if (maxIncreased >= abs(maxDecreased)) {
                      currentNodeInfo.[neighbourTemperatureInfoKey] = maxIncreased;
                    } else {
                      currentNodeInfo.[neighbourTemperatureInfoKey] = maxDecreased;
                    }
                    if (action == "setValueAndColorAndTemperature") {
                      currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                      {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                      {atomno=@currentNodeNumber}.color = colors..mixed;
                    }
                    if (action == "setValueAndTemperatureOnly") {
                      currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                      {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    }
                  }
                } else {   # mixed value classes
                  currentNodeInfo.[colorInfoKey] = colors..mixed;
                  if (maxIncreased >= abs(maxDecreased)) {
                    currentNodeInfo.[neighbourTemperatureInfoKey] = maxIncreased;
                  } else {
                    currentNodeInfo.[neighbourTemperatureInfoKey] = maxDecreased;
                  }
                  if (action == "setValueAndColorAndTemperature") {
                    currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    {atomno=@currentNodeNumber}.color = colors..mixed;
                  }
                  if (action == "setValueAndTemperatureOnly") {
                    currentNodeInfo..temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                    {atomno=@currentNodeNumber}.temperature = currentNodeInfo.[neighbourTemperatureInfoKey];
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

function colorByBondCount(type) {  # types: atom, bond
  var currentSelection = {selected};
  var currentBondMode  = bondModeOr;
  set bondModeOr true;

  if (type == "atom") {
    select @currentSelection AND bondcount=1; color lightcoral;
    select @currentSelection AND bondcount=2; color deepskyblue;
    select @currentSelection AND bondcount=3; color chartreuse;
    select @currentSelection AND bondcount=4; color orangered;
    select @currentSelection AND bondcount>4 and bondcount<=10; color tan;
    select @currentSelection AND bondcount>10; color magenta;
  } elseif (type == "bond") {
    select @currentSelection AND bondcount=1; color bond lightcoral translucent 5;
    select @currentSelection AND bondcount=2; color bond deepskyblue translucent 5;
    select @currentSelection AND bondcount=3; color bond chartreuse translucent 5;
    select @currentSelection AND bondcount=4; color bond orangered translucent 5;
    select @currentSelection AND  bondcount>4 and bondcount<=10; color bond tan translucent 5;
    select @currentSelection AND  bondcount>10; color bond magenta translucent 5;
  }

  set echo bondCountLegend displayed;

  select @currentSelection;
  set bondModeOr currentBondMode;
}

function colorByChange(type) {  # types: atom, bond
  var currentSelection = {selected};
  var currentBondMode  = bondModeOr;
  set bondModeOr true;

  if (type == "atom") {
    select @currentSelection AND [OB_INC]; color red;
    select @currentSelection AND [OB_NON]; color grey;
    select @currentSelection AND [OB_DEC]; color yellowgreen;
  } elseif (type == "bond") {
    select @currentSelection AND [OB_INC]; color bond red translucent 5;
    select @currentSelection AND [OB_NON]; color bond grey translucent 5;
    select @currentSelection AND [OB_DEC]; color bond yellowgreen translucent 5;
  }

  select @currentSelection;
  set bondModeOr currentBondMode;
}

function colorByDegree(nodeBitset, mode, colorList) {   # available modes: absolute, relative
  var current_selection = {selected};
  var currentEdgeMode   = bondModeOr;
  var indexList         = [];

  set bondModeOr true;

  if (colorList.type != "array") {
    colorList = ["lightgrey","khaki","gold","orange","chocolate","tan","darkgoldenrod","saddlebrown","aqua","deepskyblue","dodgerblue","royalblue","blue","chartreuse","yellowgreen","limegreen","green","pink","lightcoral","orangered","crimson","violet","magenta"];
  }

  if (mode == "") {
    mode = "absolute"
  }

  var minColorIndex = 1;
  var maxColorIndex = colorList.size;

  var nodeList = @current_selection;
  if (nodeBitset.type == "bitset") {
    nodeList = nodeBitset;
  }
  #logMsg("maxColorIndex=" + maxColorIndex + "  nodeCount=" + currentSelection.size);

  # Determine degree range (absolute values)
  var minDegree  = 0.0;
  var maxDegree  = 0.0 + {nodeList}.bondcount.max;

  if (mode == "relative") {
    minDegree = 0.0 + {nodeList}.bondcount.min;
  }

  for (var i = 1; i<=maxDegree+1; i++) {
    indexList[i] = i-1;   # needed for building integer range values identical to color indexes
  }

  var legend = '<h5 class="janetColorLegend">Legend - Coloring by Degree [subset: ' + networkData..subsets.[networkData..currentSubsetKey]..subsetName + ']</h5><ul class="janetColorLegend">';

  if (maxDegree < maxColorIndex) {
    for (var degree=0; degree<=maxDegree; degree++) {
      var colorIndex   = 1 + degree;
      var currentColor = colorList[colorIndex];
      legend = legend + '  <li style="background-color: ' + currentColor + '">' + degree + '</li>';
    }
    for (var currentNode in @nodeList) {
      var degree       = {currentNode}.bondcount;
      var colorIndex   = 1 + degree;
      var currentColor = colorList[colorIndex];
      select @currentNode;
      color @currentColor;
    }
  } else {

    if (maxDegree == 0) {
      maxDegree = 0.00001;
    }

    var degreeRange = (maxDegree + 1) / maxColorIndex;
    var rangeStart  = minDegree + 1;
    for (var colorIndex = minColorIndex; colorIndex<=maxColorIndex; colorIndex++) {
      
      var currentColor = colorList[colorIndex];
      var rangeEnd     = rangeStart + degreeRange - 1;
      legend           = legend + '  <li style="background-color: ' + currentColor + '">' + indexList[rangeStart] + " - " + indexList[rangeEnd] + '</li>';
      rangeStart       = 1 + rangeEnd;
    }

    for (var currentNode in @nodeList) {
      var degree = {currentNode}.bondcount;
      var normalizedDegree = degree / maxDegree;

      var colorIndex = [minColorIndex + (normalizedDegree * maxColorIndex), maxColorIndex].min;   # '0' at the beginning needed to make sure 'nodeSize' is an integer value (DOES IT REALLY WORK WITH INTEGER?)
      #print "nn=" + {currentNode}.atomno + "  deg=" + degree + "  maxDeg=" + maxDegree + "  normDeg=" + normalizedDegree + "  colIndex=" + colorIndex + "  col=" + colorList[colorIndex];
      var currentColor = colorList[colorIndex];
      select @currentNode;
      color @currentColor;
    }
  }

  select @current_selection;
  set bondModeOr currentEdgeMode;

  legend = legend + '</ul>';
  var domId = "color_legend";
  var javascriptCommand = '$("#'+ domId + '").html(\'' + legend + '\'); $("#'+ domId + '").css("display","block")';
  javascript @javascriptCommand;

}

function setSizeByChange(type, scalingFactor, nodeBitset) {  # types: node, edge
  var current_selection = {selected};
  var currentEdgeMode  = bondModeOr;
  set bondModeOr true;

  var minNodeSize = 0.4;
  var maxNodeSize = 20.0;
  var minEdgeSize = 1;
  var maxEdgeSize = 749;

  if (scalingFactor > 0.0) {
    if (scalingFactor <= 1.0) {
      maxNodeSize = maxNodeSize * scalingFactor;
    }
  }
  if (maxNodeSize > minNodeSize) {
    maxNodeSize = maxNodeSize - minNodeSize;
  }
  if (scalingFactor > 0.0) {
    if (scalingFactor <= 1.0) {
      maxEdgeSize = maxEdgeSize * scalingFactor;
    }
  }
  if (maxEdgeSize > minEdgeSize) {
    maxEdgeSize = maxEdgeSize - minEdgeSize;
  }

  var nodeList = @current_selection;
  if (nodeBitset.type == "bitset") {
    nodeList = nodeBitset;
  }
  logMsg("type=" + type + "  nodeCount=" + currentSelection.size);

  # Determine change value range (absolute values)
  var minChangeValue1 = {nodeList and temperature < 0.0}.temperature.max;
  var minChangeValue2 = {nodeList and temperature >= 0.0}.temperature.min;
  var maxChangeValue1 = abs({nodeList and temperature < 0.0}.temperature.min);
  var maxChangeValue2 = {nodeList and temperature >= 0.0}.temperature.max;
  var minChangeValue  = 0.0;
  var maxChangeValue  = [maxChangeValue1, maxChangeValue2].max;

  if (maxChangeValue == 0) {
    maxChangeValue = 0.00001;
  }

  for (var current_node in @nodeList) {
    var changeValue = abs({current_node}.temperature);
    var normalizedChangeValue = changeValue / maxChangeValue;

    #logMsg([channel: "info", msg: "change=" + changeValue + "  spacefill " + @{10 + 0.02 * changeValue} + "%"]);

    if (type == "node") {
      var nodeSize = 0.0 + minNodeSize + (normalizedChangeValue * maxNodeSize);   # '0.0' at the beginning needed to make sure 'nodeSize' is a decimal value
      #print "nn=" + {current_node}.atomno + "  ntype=" + {current_node}.group + "  cv=" + changeValue + "  mcv=" + maxChangeValue + "  ncv=" + normalizedChangeValue + "  ns=" + nodeSize;
      select @current_node;
      spacefill @nodeSize;
    } elseif (type == "edge") {
      var edgeWidth = 0 + format("%d", minEdgeSize + abs(normalizedChangeValue * maxEdgeSize));   # '0' at the beginning needed to convert 'format' string output to number
      logMsg("  edgeWidth=" + edgeWidth);
      select @current_node;
      wireframe @{edgeWidth};
    }
  }

  select @current_selection;
  set bondModeOr currentEdgeMode;
}

function setSizeByChangeV1(type, nodeBitset) {  # types: node, edge
  var current_selection = {selected};
  var currentEdgeMode  = bondModeOr;
  set bondModeOr true;

  var nodeList = @current_selection;
  if (nodeBitset.type == "bitset") {
    nodeList = nodeBitset;
  }
  logMsg("type=" + type + "  nodeCount=" + currentSelection.size);
  for (var current_node in @current_selection) {
    var changeValue = {current_node}.temperature;
    logMsg("change=" + changeValue + "  spacefill " + @{10 + 0.02 * changeValue} + "%");
    if (type == "node") {
      var nodeSize = 10 + 0.25 * abs(changeValue);
      select @current_node;
      spacefill @nodeSize%;
    } elseif (type == "edge") {
      #var edgeWidth = 0 + format("%d", 1 + 0.5 * abs(changeValue));   # '0' at the beginning needed to convert 'format' string output to number
      var edgeWidth = 0 + format("%d", 1 + 2.5 * abs(changeValue));   # '0' at the beginning needed to convert 'format' string output to number
      logMsg("  edgeWidth=" + edgeWidth);
      #var edgeWidth = 0 + format("%d", 2 + 0.1 * abs(changeValue));   # '0' at the beginning needed to convert 'format' string output to number
      select @current_node;
      wireframe @{edgeWidth};
    }
  }

  select @current_selection;
  set bondModeOr currentEdgeMode;
}

function setSizeByDegree(type, scalingFactor, nodeBitset) {  # types: node, edge
  var current_selection = {selected};
  var currentEdgeMode  = bondModeOr;
  set bondModeOr true;

  var minNodeSize = 0.4;
  var maxNodeSize = 20.0;
  var minEdgeSize = 1;
  var maxEdgeSize = 749;

  if (scalingFactor > 0.0) {
    if (scalingFactor <= 1.0) {
      maxNodeSize = maxNodeSize * scalingFactor;
    }
  }
  if (maxNodeSize > minNodeSize) {
    maxNodeSize = maxNodeSize - minNodeSize;
  }
  if (scalingFactor > 0.0) {
    if (scalingFactor <= 1.0) {
      maxEdgeSize = maxEdgeSize * scalingFactor;
    }
  }
  if (maxEdgeSize > minEdgeSize) {
    maxEdgeSize = maxEdgeSize - minEdgeSize;
  }

  var nodeList = @current_selection;
  if (nodeBitset.type == "bitset") {
    nodeList = nodeBitset;
  }
  if (type == "") {
    type = "node";
  }
  logMsg("type=" + type + "  mode=" + mode + "  nodeCount=" + currentSelection.size);

  # Determine degree range (absolute values)
  var minDegree  = 0.0;
  var maxDegree  = 0.0 + {nodeList}.bondcount.max;

  if (maxDegree == 0) {
    maxDegree = 0.00001;
  }

  for (var current_node in @nodeList) {
    var degree = {current_node}.bondcount;
    var normalizedDegree = degree / maxDegree;

    #logMsg([channel: "info", msg: "change=" + degree + "  spacefill " + @{10 + 0.02 * degree} + "%"]);

    if (type == "node") {
      var nodeSize = 0.0 + minNodeSize + (normalizedDegree * maxNodeSize);   # '0.0' at the beginning needed to make sure 'nodeSize' is a decimal value
      #print "nn=" + {current_node}.atomno + "  ntype=" + {current_node}.group + "  cv=" + degree + "  mcv=" + maxDegree + "  ncv=" + normalizedDegree + "  ns=" + nodeSize;
      select @current_node;
      spacefill @nodeSize;
    } elseif (type == "edge") {
      var edgeWidth = 0 + format("%d", minEdgeSize + abs(normalizedDegree * maxNodeSize));   # '0' at the beginning needed to convert 'format' string output to number
      logMsg("  edgeWidth=" + edgeWidth);
      select @current_node;
      wireframe @{edgeWidth};
    }
  }

  select @current_selection;
  set bondModeOr currentEdgeMode;
}


function manageGenesOfInterest(dataHashref) {
  var msg                         = "";
  var startTime                   = now();
  var currentNetworkData          = {};
  var subsetKey                   = "";
  var subset                      = {};
  var nodeInfo                    = {};
  var nodeNumberToNodeKey         = {};
  var action                      = "";
  var geneKeys                    = [];
  var ncbiGeneIds                 = [];
  var speciesList                 = [];
  #var parsed                      = "";
  var subsetFilter                = false;
  var matchOnly                   = true;
  var fullSubsetKey               = "full";
  var fullSubset                  = {};
  var fullNodeInfo                = {};
  var resultNodeInfo              = {};
  var geneKeyToNodeKey            = {};
  var ncbiGeneIdToNodeKey         = {};
  var fullGeneKeyToNodeKey        = {};
  var fullNcbiGeneIdToNodeKey     = {};
  var matchedNodeKeys             = {};
  var matchedGoiNodeKeys          = {};
  var matchedHomologyBaseNodeKeys = {};
  var matchedExperimentalNodeKeys = {};
  var totalGeneCount              = 0;
  var knownActions                = [activate: true, deactivate: true, overview: true, filterOn: true, filterOff: true];

  # Check required parameters
  if (dataHashref.type != "hash") {
    if (dataHashref == "overview" || dataHashref == "filterOn" || dataHashref == "filterOff") {
      action = dataHashref;
      if (networkData.type == "hash") {
        currentNetworkData = networkData;
      }
      subsetKey = currentNetworkData..currentSubsetKey;
    } else {
      msg = msg + "ERROR: parameter 'dataHashref' NOT PROVIDED in call of method 'manageGenesOfInterest'\n";
    }
  } else {
    if (dataHashref..action == "") {
      msg = msg + "ERROR: parameter 'action' NOT DEFINED in call of method 'manageGenesOfInterest'\n";
    } else {
      action = dataHashref..action;
      if (knownActions[action] == "" ) {
	msg = msg + "ERROR: action '" + action + "' not defined for parameter 'action' in call of method 'manageGenesOfInterest'\n";
      }
    }
    if (dataHashref..parsed != "true") {
      if (dataHashref..geneKeys.type == "string") {
	geneKeys = dataHashref..geneKeys.split("##");
      }
      if (dataHashref..ncbiGeneIds.type == "string") {
	ncbiGeneIds = dataHashref..ncbiGeneIds.split("##");
      }
      if (dataHashref..speciesList.type == "string") {
	speciesList = dataHashref..speciesList.split("##");
      }
      dataHashref..parsed = "true";
    } else {
      geneKeys = dataHashref..geneKeys;
      ncbiGeneIds = dataHashref..ncbiGeneIds;
      speciesList = dataHashref..speciesList;
    }

    if (dataHashref..networkData.type == "hash") {
      currentNetworkData = dataHashref..networkData;
    } else {
      if (networkData.type == "hash") {
        currentNetworkData = networkData;
      }
    }
    if (dataHashref..outputFormat != "") {
      outputFormat = dataHashref..outputFormat;
    }
    if ("" + dataHashref..subsetFilter != "") {
      subsetFilter = dataHashref..subsetFilter;
    }
    if ("" + dataHashref..matchOnly != "") {
      matchOnly = dataHashref..matchOnly;
    }
    if (dataHashref..currentSubsetKey == "") {
      if (currentNetworkData..currentSubsetKey == "") {
        subsetKey = "full";
      } else {
        subsetKey = currentNetworkData..currentSubsetKey;
      }
    } else {
      subsetKey = dataHashref..currentSubsetKey;
    }
    if (currentNetworkData..subsets.[subsetKey].type != "hash") {
      msg = msg + "ERROR: no subset subhash found for subset '" + subsetKey + "' in call of method 'getNodeInfo'\n";
    } else {
      subset = currentNetworkData..subsets.[subsetKey];
    }
    if (subset..nodeNumberToNodeKey.type == "hash") {
      nodeNumberToNodeKey = subset..nodeNumberToNodeKey;
    }

    if (subset..nodeInfo.type != "hash") {
      msg = msg + "WARNING: no 'nodeInfo' subhash provided for subset '" + subsetKey + "' in call of method 'getNodeInfo'\n";
    } else {
      nodeInfo = subset..nodeInfo;
    }

  }

  if (msg != "") {
    logMsg([level: "mixed", msg: msg]);
    if (msg.find("ERROR:")) {
      return;
    }
  }

  if (subsetKey == fullSubsetKey) {
    fullSubset   = subset;
    fullNodeInfo = nodeInfo;
  } else {
    fullSubset = currentNetworkData..subsets.[fullSubsetKey];
    fullNodeInfo = fullSubset..nodeInfo;
  }

  if (action == "filterOn" || action == "filterOff") {

    if (action == "filterOn") {
      subsetFilter = true;
      msg = "Subset menu filter for genes of interest is switched on";
    } else {
      subsetFilter = false;
      msg = "Subset menu filter for genes of interest is switched off";
    }
    logMsg([level: "info", msg: msg]);

    if (fullSubset..genesOfInterest.type == "hash") {
      fullSubset..genesOfInterest..subsetFilter = subsetFilter;

      if (currentNetworkData..standardSubsetManagement.type != "hash") {
        currentNetworkData..standardSubsetManagement = {};
      }
      if (currentNetworkData..standardSubsetManagement..menuNodeFilter == "") {
        currentNetworkData..standardSubsetManagement..menuNodeFilter = "* WHEREIN nodeType='ageingFactor'";
      }
      updateStandardSubsetManagementMenu(currentNetworkData);
    }

    return;
  }


  if (action == "overview") {
    var startTime = now();
    networkData..currentSubsetKey = "full";
    frame @{networkData..currentSubsetKey};
    logMsg("  building genes of interest overview subset...");

    hide [alt_alt],[sp_sp],[cit_cit],[bs_pw],[gen_gen],[go_*];
    selectByInfoKey("nodeKey",networkData..subsets..full..genesOfInterest..matchedNodeKeys.keys);
    setValue(getNodeInfo({selected}), "nodeGroup", "GOI");
    logMsg([level: "info", msg: "added " +  {selected}.size + " nodes to genes of interest group"]);
    display selected, (connected(selected) and displayed);
    select displayed and ([OB_INC],[OB_DEC],[OB_NON]);
    hide hidden,[alt_alt],[sp_sp],[cit_cit],[bs_pw],[gen_gen],[go_*];

    # Filter network data ()
    var currentSubsetKey    = "goi_overview";
    var currentSubsetName   = "Genes of Interest - Overview";
    var subsetNameExtension = "";
    if (subsetKeys[currentSubsetKey] == "") {
      subsetKeys[currentSubsetKey] = 1;
      subsetNameExtension   = "";
    } else {
      subsetKeys[currentSubsetKey]++;
      var number = subsetKeys[currentSubsetKey];
      currentSubsetKey = currentSubsetKey + "-" + number;
      subsetNameExtension = " - " + number;
    }
    currentSubsetName = currentSubsetName + subsetNameExtension;

    networkData..baseSubsetKey = "full";
    networkData..currentSubsetKey = currentSubsetKey;
    networkData..nodeFilter = {displayed};
    networkData..edgeFilter = [maxPathLength: 0,
                               filterExpression: "",
                               stopConditions: [{"infoKey": "nodeType", "value": "species"}, {"infoKey": "nodeType", "value": "observation"}]];
    buildSubset(networkData);
    subsetFileNumber++;

    buildMmcifData(networkData);
    mmcifData = networkData..subsets.[networkData..currentSubsetKey]..mmcifData;
    load APPEND "@mmcifdata" FILTER "addBonds";
    initDisplay(layoutOptions);
    frame ID @{networkData..currentSubsetKey};
    setScale({"node": 0.12, "edge": 0.04, "frameSize": 5});
    initHover;
    refresh;


    layoutOptions.fr.fullFrameSizeX           = 2;
    layoutOptions.fr.fullFrameSizeY           = 2;
    layoutOptions.fr.fullFrameSizeZ           = 2;
    layoutOptions.fr.frameSizeX               = layoutOptions.fr.fullFrameSizeX;
    layoutOptions.fr.frameSizeY               = layoutOptions.fr.fullFrameSizeY;
    layoutOptions.fr.frameSizeZ               = layoutOptions.fr.fullFrameSizeZ;
    layoutOptions.fr.displayIntermediates     = false;
    layoutOptions.tiled                       = true;
    layoutOptions.tileFactorX                 = 0.3;
    layoutOptions.tileFactorY                 = 0.3;
    layoutOptions.fr.temperatureScalingFactor = 0.95;
    layoutOptions.fr.kValueModifier           = 0.6;
    layoutOptions.labelSubnetworks            = false;

    buildLayout({displayed}, layoutOptions);

    set fontscaling off;
    setLabel([nodeInfo: networkData..subsets.[networkData..currentSubsetKey]..nodeInfo, action: "hide"]);

    selectByInfoKey('nodeKey',networkData..subsets..full..genesOfInterest..matchedExperimentalNodeKeys.keys);
    define set1 selected;
    selectByInfoKey('nodeKey',networkData..subsets..full..genesOfInterest..matchedHomologyBaseNodeKeys.keys);
    define set2 selected;
    selectByInfoKey('nodeId',networkData..subsets..full..genesOfInterest..nodeIds);
    define set3 selected
    select set1,set2;

    set label display;
    set fontSize 8;  # sometimes 4
    #background label [250,250,250];

    select set3;
    halo on;
    color halo gold;
    color cyan;
    color labels dodgerblue;

    center displayed;
    rotate best;
    zoom 0;
    if (networkData..subsets.[networkData..currentSubsetKey].type == "hash") {
      networkData..subsets.[networkData..currentSubsetKey]..storedOrientation = script("show orientation").split("#").[1];    
      networkData..subsets.[networkData..currentSubsetKey]..storedSelection = {all};    
    }

    javascriptCommand = "last_model=" + subsetFileNumber + "; document.getElementById('subset_count').innerHTML = '" + subsetFileNumber + "'; subset_names.push('" + networkData..currentSubsetKey + "');";
    javascript @javascriptCommand;

    # Extend displaysubset menu
    networkData..subsets.[networkData..currentSubsetKey]..subsetType = "goi_overview";
    networkData..subsets.[networkData..currentSubsetKey]..subsetName = currentSubsetName;
    optionHtml = '<option value="' + currentSubsetKey + '">' + currentSubsetName + '</option>';
    if (subsetFileNumber == 1) {
      var x = javascript("document.getElementById('displaysubset_menu').innerHTML = '" + optionHtml + "';");
    } else {
      var x = javascript("document.getElementById('displaysubset_menu').innerHTML = document.getElementById('displaysubset_menu').innerHTML + '" + optionHtml + "';");
    }
    javascriptCommand = "idbSetSelected(document.getElementById('displaysubset_menu'), '" + networkData..currentSubsetKey + "'); $('#page_name').text('" + subsetName + "');";
    javascript @javascriptCommand;
    var timeMessage = " (time=" + format("%.1f", now(startTime) / 1000) + " sec)";

    logMsg([level: "info", msg: "finished building genes of interest overview subset '" + networkData..currentSubsetKey + "'" + timeMessage]);

  } else {
  if (fullSubset..geneKeyToNodeKey.type == "hash") {
    fullGeneKeyToNodeKey = fullSubset..geneKeyToNodeKey;
  }
  if (fullSubset..ncbiGeneIdToNodeKey.type == "hash") {
    fullNcbiGeneIdToNodeKey = fullSubset..ncbiGeneIdToNodeKey;
  }
  var fullGeneKeys    = fullGeneKeyToNodeKey.keys;
  var fullNcbiGeneIds = fullNcbiGeneIdToNodeKey.keys;

  totalGeneCount = geneKeys.size + ncbiGeneIds.size;

  logMsg("  managing genes of interest (NCBI gene IDs=" + fullNcbiGeneIds.size + ", symbol + species=" + fullGeneKeys.size + ")...");
  var resultNodeInfo = {};

  if (action == "activate") {
    var geneNodeInfos = fullNodeInfo.select("** WHERE ageingFactorType='gene'");
    # Search node keys for genes of interest
    #   search by NCBI Gene ID
    var ncbiGeneIdRegExp = ncbiGeneIds.join("|");
    var matchedNcbiGeneIds = fullNcbiGeneIds.find(ncbiGeneIdRegExp, "");
    logMsg("    by ID: regExpSize=" + ncbiGeneIdRegExp.size + "  matched=" + matchedNcbiGeneIds.size);
    for (var currentNcbiGeneId in matchedNcbiGeneIds) {
      #print "DEBUG:   ncbiGeneId='" + currentNcbiGeneId + "'";
      ncbiGeneIdToNodeKey.[currentNcbiGeneId] = {};
      var currentNodeKey = fullNcbiGeneIdToNodeKey[currentNcbiGeneId];
      if (fullNodeInfo.[currentNodeKey].type == "hash") {
	resultNodeInfo[currentNodeKey] = fullNodeInfo[currentNodeKey];
	ncbiGeneIdToNodeKey[currentNcbiGeneId].[currentNodeKey]++;
	matchedNodeKeys[currentNodeKey]++;
	matchedGoiNodeKeys[currentNodeKey]++;
      }
    }

    #   search by gene key (gene symbol + species, e.g.: vit-3||Caenorhabditis elegans)
    var geneKeyRegExp = geneKeys.replace("||","\\|\\|").join("|");
    #show geneKeyRegExp;
    var matchedGeneKeys = fullGeneKeys.find(geneKeyRegExp, "");
    logMsg("    by Symbol: regExpSize=" + geneKeyRegExp.size + "  matched=" + matchedGeneKeys.size);
    #write var geneKeyRegExp "jsnet3d/find-geneKeyRegExp.txt";
    #write var fullGeneKeys "jsnet3d/find-fullGeneKeys.txt";
show fullGeneKeys;

    for (var currentGeneKey in matchedGeneKeys) {
      #print "DEBUG:   geneKey='" + currentGeneKey + "'";
      geneKeyToNodeKey.[currentGeneKey] = {};
      var currentNodeKey = fullGeneKeyToNodeKey[currentGeneKey];
      if (fullNodeInfo.[currentNodeKey].type == "hash") {
	resultNodeInfo[currentNodeKey] = fullNodeInfo[currentNodeKey];
	geneKeyToNodeKey.[currentGeneKey].[currentNodeKey]++;
	matchedNodeKeys[currentNodeKey]++;
	matchedGoiNodeKeys[currentNodeKey]++;
      }
    }

    #print "===== resultNodeInfo =========";
    #print resultNodeInfo;
    #print "===== ncbiGeneIdToNodeKey ========";
    #print ncbiGeneIdToNodeKey;
    #print "===== geneKeyToNodeKey ========";
    #print geneKeyToNodeKey;

    # Build info table
    var tableHtml = '<table class="jmol" cellspacing="2" cellpadding="0"><tr><th class="jmol" bgcolor="#bbbbbb" colspan="4">Gene of Interest</th><th class="jmol"  bgcolor="#bbbbbb" colspan="5">AgeFactDB</th></tr>';
    var columns   = ["No.", "Gene Symbol", "Species", "NCBI Gene ID", "Stable ID", "Gene Symbol", "Species", "NCBI Gene ID", "Ageing Relevance Evidence"];
    tableHtml += '  <tr><th class="jmol" bgcolor="#dddddd">' + columns.join('</th><th class="jmol" bgcolor="#dddddd">') + '</th></tr>';
    var sep = '</td><td class="jmol">';
    var geneNumber = 0;

    for (var ncbiGeneId IN ncbiGeneIdToNodeKey) {
      var species         = "";
      var geneSymbol      = "";
      var matchType       = "no match";
      var matchId         = "";
      var matchGeneSymbol = "";
      var matchSpecies    = "";
      var matchNcbiGeneId = "";
      var nodeKeyCount    = ncbiGeneIdToNodeKey.[ncbiGeneId].keys.size;
      if (nodeKeyCount > 0) {
	var nodeKey = ncbiGeneIdToNodeKey.[ncbiGeneId].keys[1];
	matchSpecies = resultNodeInfo.[nodeKey]..species.keys[1];
	matchId         = resultNodeInfo.[nodeKey]..ageingFactorId;
	matchGeneSymbol = resultNodeInfo.[nodeKey]..ageingFactorName;
	matchNcbiGeneId = resultNodeInfo.[nodeKey]..ncbiGeneId;
	if (resultNodeInfo.[nodeKey]..homologyAnalysisStatus == "added") {
	  var baseEntryStableIds = resultNodeInfo.[nodeKey]..baseEntryStableIds;
	  matchType = "homology analysis";
	  if (baseEntryStableIds != "") {
	    var baseInfo = [];
	    var baseIds  = baseEntryStableIds.split("||");
	    for (var baseId IN baseIds) {
	      var baseNodeKey = "ageingFactorId||" + baseId;
              if (fullNodeInfo.[baseNodeKey].type == "hash") {
		var baseSymbol     = fullNodeInfo.[baseNodeKey]..ageingFactorName;
		var baseSpecies    = fullNodeInfo.[baseNodeKey]..species.keys[1];
		var baseNcbiGeneId = fullNodeInfo.[baseNodeKey]..ncbiGeneId;
		matchedNodeKeys[baseNodeKey]++;
		matchedHomologyBaseNodeKeys[baseNodeKey]++;
		if (baseNcbiGeneId > 0) {
		  baseNcbiGeneId = "NCBI Gene ID " + baseNcbiGeneId + ", ";
		} else {
		  baseNcbiGeneId = "";
		}
		baseInfo.push("gene " + baseSymbol + " " + baseSpecies + " (" + baseNcbiGeneId + baseId + ")");
	      }
	    }
	    if (baseInfo.size > 0) {
	      matchType += "; based on " + baseInfo.join(" and ");
	    }
	  }
	} elseif (resultNodeInfo.[nodeKey]..homologyAnalysisStatus == "not added") {
	  matchType = "experimental evidence";
	  matchedExperimentalNodeKeys[nodeKey]++;
	} else {
          matchType = "experimental evidence";    # not in homology analysis, currently all should have experiental evidence
	  matchedExperimentalNodeKeys[nodeKey]++;
	}
      } else {
      }
      #print "DEBUG:  nodeKey='" + nodeKey + "'  species='" + species + "'  matchType='" + matchType + "'";
      var skipGene = false;
      if (matchOnly) {
	if (matchType == "no match") {
	  skipGene = true;
	}
      }
      if (skipGene == false) {
	geneNumber++;
	tableHtml += '<tr><td class="jmol">' + geneNumber + sep + geneSymbol + sep + species + sep + ncbiGeneId + sep + matchId + sep + matchGeneSymbol + sep + matchSpecies + sep + matchNcbiGeneId + sep + matchType + '</td></tr>';
      }
    }

    for (var geneKey IN geneKeyToNodeKey) {
      var geneInfo        = geneKey.split("||");
      var species         = geneInfo[2];
      var geneSymbol      = geneInfo[1];
      var matchType       = "no match";
      var matchId         = "";
      var matchGeneSymbol = "";
      var matchSpecies    = "";
      var matchNcbiGeneId = "";
      var nodeKeyCount    = geneKeyToNodeKey.[geneKey].keys.size;
      if (nodeKeyCount > 0) {
	var nodeKey = geneKeyToNodeKey.[geneKey].keys[1];
	matchSpecies = resultNodeInfo.[nodeKey]..species.keys[1];
	matchId         = resultNodeInfo.[nodeKey]..ageingFactorId;
	matchGeneSymbol = resultNodeInfo.[nodeKey]..ageingFactorName;
	matchNcbiGeneId = resultNodeInfo.[nodeKey]..ncbiGeneId;
	if (resultNodeInfo.[nodeKey]..homologyAnalysisStatus == "added") {
	  var baseEntryStableIds = resultNodeInfo.[nodeKey]..baseEntryStableIds;
	  matchType = "homology analysis";
	  if (baseEntryStableIds != "") {
	    var baseInfo = [];
	    var baseIds  = baseEntryStableIds.split("||");
	    for (var baseId IN baseIds) {
	      var baseNodeKey = "ageingFactorId||" + baseId;
              if (fullNodeInfo.[baseNodeKey].type == "hash") {
		var baseSymbol     = fullNodeInfo.[baseNodeKey]..ageingFactorName;
		var baseSpecies    = fullNodeInfo.[baseNodeKey]..species.keys[1];
		var baseNcbiGeneId = fullNodeInfo.[baseNodeKey]..ncbiGeneId;
		matchedNodeKeys[baseNodeKey]++;
		matchedHomologyBaseNodeKeys[baseNodeKey]++;
		if (baseNcbiGeneId > 0) {
		  baseNcbiGeneId = "NCBI Gene ID " + baseNcbiGeneId + ", ";
		} else {
		  baseNcbiGeneId = "";
		}
		baseInfo.push("gene " + baseSymbol + " " + baseSpecies + " (" + baseNcbiGeneId + baseId + ")");
	      }
	    }
	    if (baseInfo.size > 0) {
	      matchType += "; based on " + baseInfo.join(" and ");
	    }
	  }
	} elseif (resultNodeInfo.[nodeKey]..homologyAnalysisStatus == "not added") {
	  matchType = "experimental evidence";
	  matchedExperimentalNodeKeys[nodeKey]++;
	} else {
          matchType = "experimental evidence";    # not in homology analysis, currently all should have experiental evidence
	  matchedExperimentalNodeKeys[nodeKey]++;
	}
      } else {
      }
      #print "DEBUG:  nodeKey='" + nodeKey + "'  species='" + species + "'  matchType='" + matchType + "'";
      var skipGene = false;
      if (matchOnly) {
	if (matchType == "no match") {
	  skipGene = true;
	}
      }
      if (skipGene == false) {
	geneNumber++;
	tableHtml += '<tr><td class="jmol">' + geneNumber + sep + geneSymbol + sep + species + sep + ncbiGeneId + sep + matchId + sep + matchGeneSymbol + sep + matchSpecies + sep + matchNcbiGeneId + sep + matchType + '</td></tr>';
      }
    }

    tableHtml += '</table>';
    var separator    = '<hr class="separatorSmall">';
    var matchComment = '<b>Match info: </b><span class="jmolComment">' + geneNumber + ' of ' + totalGeneCount + ' genes of interest match to AgeFactDB genes</span>';
    tableHtml = separator +matchComment + tableHtml + separator;
    var command = "$(\"#genesofinterest_info_content\").html('" + tableHtml + "')";
    #print command;
    var x = javascript("" + command);

    fullSubset..genesOfInterest                  = [subsetFilter: subsetFilter, matchOnly: matchOnly, activated: true, matchCount: geneNumber];
    fullSubset..genesOfInterest..nodeIds         = resultNodeInfo.array("id").select("(nodeId)");
    fullSubset..genesOfInterest..matchedNodeKeys = matchedNodeKeys;
    fullSubset..genesOfInterest..matchedGoiNodeKeys = matchedGoiNodeKeys;
    fullSubset..genesOfInterest..matchedExperimentalNodeKeys = matchedExperimentalNodeKeys;
    fullSubset..genesOfInterest..matchedHomologyBaseNodeKeys = matchedHomologyBaseNodeKeys;

    if (currentNetworkData..standardSubsetManagement.type != "hash") {
      currentNetworkData..standardSubsetManagement = {};
    }
    if (currentNetworkData..standardSubsetManagement..menuNodeFilter == "") {
      currentNetworkData..standardSubsetManagement..menuNodeFilter = "* WHEREIN nodeType='ageingFactor'";
    }
    updateStandardSubsetManagementMenu(currentNetworkData);

  } elseif (action == "deactivate") {
    
  }
  }
  if (action != "overview") {
    logMsg([level: "info", msg: "  finished managing genes of interest (time=" + now(startTime) / 1000 + " sec)"]);
  }
}


function hoverAction(action) {
  #print "action=" + action + "  hoverId=" + hoverTimeoutId;
  if (hoverTimeoutId != "") {
    timeout ID @hoverTimeoutId off;
    hoverTimeoutId = "";
  }

  # Set defaults (currently still global variables, SHOULD BE CHANGED)
  if (hoverMode == "") {
    hoverMode = "enhance";
  }
  if (hoverRange == "") {
    hoverRange = "neighbours";
  }
  if (hoverRangeNeighbourMode == "") {
    hoverRangeNeighbourMode = "add";
  }
  if ("" + hoverRangeNeighbourDistance == "") {
    hoverRangeNeighbourDistance = 1;
  }
  if ("" + hoverEdgeTranslucency == "") {
    hoverEdgeTranslucency = 4;
  }
  if ("" + hoverEdgeEnhanceTranslucency == "") {
    hoverEdgeEnhanceTranslucency = 2;
  }
  if (hoverIncludeHidden == "") {
    hoverIncludeHidden = "on";
  }

  var switchOff        = false;
  var currentSelection = {selected};
  var currentBondmode  = bondModeOr;
  set bondModeOr false;

  if (action == "end") {
    if (lastHoverUnfinished) {
      switchOff = true;
    }
  } elseif (action == "start") {
    if (lastHoverUnfinished) {
      if (lastAtomIndexHovered != _atomhovered) {
        switchOff = true;
      }
    }
  }

  #print "action=" + action + "  switchOff=" + switchOff + "  lastHoverUnfinished=" + lastHoverUnfinished + "  lastAtomIndexHovered=" + lastAtomIndexHovered + "  _atomhovered=" + _atomhovered + "  neighbourDistance=" + hoverRangeNeighbourDistance;
  if (switchOff) {
    if (lastAtomIndexHovered >= 0) {
      if (hoverRange == "neighbours") {
        var neighbourNodeSet = getNeighbours({atomindex=@lastAtomIndexHovered}, hoverRangeNeighbourDistance, hoverRangeNeighbourMode);
        #print neighbourNodeSet;
        select @neighbourNodeSet;
      } elseif (hoverRange == "network") {
        select within("molecule", atomindex=@lastAtomIndexHovered);
      } else {
        select atomindex=@lastAtomIndexHovered;
      }
      color halo yellow;
      halo off;
      if (hoverMode == "enhance") {
        color bonds translucent @hoverEdgeTranslucency;
      } elseif (hoverMode == "only") {
        display @displayedBeforeHover;
      } elseif (hoverMode == "edgesOn") {
        hide bonds;
      }
    }
    lastAtomIndexHovered = -1;
    lastHoverUnfinished  = false;
    hoverMessage = "";    # displayed as 'echo'
    set echo hovermessage hidden;
  }

  if (_atomhovered >= 0 && action == "start") {
    lastAtomIndexHovered = _atomhovered;
    var nodeInfo = getNodeInfo({atomindex=@lastAtomIndexHovered}.atomno);
    var sizeInfo = "";
    if (hoverRange == "neighbours") {
      var neighbourNodeSet = getNeighbours({atomindex=@lastAtomIndexHovered}, hoverRangeNeighbourDistance, hoverRangeNeighbourMode);
      #print neighbourNodeSet;
      select @neighbourNodeSet;
      #select atomindex=@lastAtomIndexHovered OR connected(atomindex=@lastAtomIndexHovered);
      var neighbourCount = {atomindex=@lastAtomIndexHovered OR connected(atomindex=@lastAtomIndexHovered)}.size - 1;
      sizeInfo = "|[Degree: " + neighbourCount + "]";
    } elseif (hoverRange == "network") {
      select within("molecule", atomindex=@lastAtomIndexHovered);
      sizeInfo = "|[Subnetwork size: " + {selected}.size + "]";
    } else {
      select atomindex=@lastAtomIndexHovered;
    }
    if (nodeInfo.type == "hash") {
      hoverMessage = "" + nodeInfo..labelLong + sizeInfo;
      set echo hovermessage displayed;
    }
    if (hoverMode == "enhance") {
      color halo cyan;
      halo on;
      select atomindex=@lastAtomIndexHovered OR connected(atomindex=@lastAtomIndexHovered);
      color bonds translucent @hoverEdgeEnhanceTranslucency;
    } elseif (hoverMode == "only") {
      if (lastHoverUnfinished != true) {
        displayedBeforeHover = {displayed};
      }
      set bondModeOr true;
      if (hoverIncludeHidden == "on") {
        display selected;
      } else {
        display selected and displayed;
      }
      select atomindex=@lastAtomIndexHovered;
      color halo cyan;
      halo on;
    } elseif (hoverMode == "edgesOn") {
      select atomindex=@lastAtomIndexHovered;
      color halo cyan;
      halo on;
      display @{{selected}.bonds};
    }
    lastHoverUnfinished  = true;
    hoverTimeoutId = "hoverEnd_" + now(); 
    timeout ID @hoverTimeoutId 1.0 "hoverAction('end')";
  }

  select @currentSelection;
  set bondModeOr @currentBondmode;
}

function initHover(fontSize) {
  hoverMessage = "";
  if (fontSize == "") {
    fontSize = 15;
  }

  set echo ID "hovermessage" 0% 100%;
  set echo ID hovermessage "@{hoverMessage}";
  #background echo [220,220,220] translucent 3;
  background echo [220,220,220];
  color echo black;
  font echo @fontSize sansSerif bold;
  #font echo 35 sansSerif bold;
  set hoverCallback "jmolscript: hoverAction('start');";
  hover off;
}

function addBonds(subset, edgeType, mode, width) {
  var msg        = "";
  var edgeInfo   = {};
  var dipoleInfo = {};

  if (edgeType == "") {
    edgeType == "undirected";
  }
  if (mode == "") {
    if (edgeType == "directed") {
      mode = "dipoles";
    } else {
      mode = "noDipoles";
    }
  }
  if (width == "") {
    width = 0.7;
  }
  if (subset.type == "hash") {
    if (subset..edgeInfo.type != "hash") {
      msg = msg +"ERROR: subparameter 'subset..edgeInfo' not provided or no hash in call of method 'addBonds' - NO BONDS ADDED\n";
    } else {
      edgeInfo = subset..edgeInfo;
    }

  } else {
    msg = msg + "ERROR: parameter 'subset' not provided or no hash in call of method 'addBonds' - NO BONDS ADDED\n";
  }


  if (msg != "") {
    return msg;
  }  

  if (edgeInfo.size > 0) {
    if (mode != "onlyDipoles") {
      for (var edgeKey in edgeInfo) {
        nodeNumber1 = edgeInfo[edgeKey]..nodeNumber1;
        nodeNumber2 = edgeInfo[edgeKey]..nodeNumber2;
        if (nodeNumber1 > 0 && nodeNumber2 > 0) {
          connect (atomno=nodeNumber1) (atomno=nodeNumber2);
        }
      }
    }

    if (edgeType == "directed" && mode != "noDipoles") {
      for (var edgeKey in edgeInfo) {
        nodeNumber1 = edgeInfo[edgeKey]..nodeNumber1;
        nodeNumber2 = edgeInfo[edgeKey]..nodeNumber2;
        if (nodeNumber1 > 0 && nodeNumber2 > 0) {
          var dipoleId    = "dip_" + edgeInfo[edgeKey]..edgeNumber;
          var dipoleScale = distance({atomno=nodeNumber1}, {atomno=nodeNumber2}) * 1.0;
          dipole ID @dipoleId (atomno=nodeNumber1) (atomno=nodeNumber2) offsetSide 0 width @width NOCROSS value @dipoleScale;
          if (dipoleInfo[nodeNumber1].type != "hash") {
            dipoleInfo[nodeNumber1] = {};
          }
          dipoleInfo[nodeNumber1].[nodeNumber2] = [dipoleId: dipoleId, edgeInfo: edgeInfo[edgeKey]];
        }
      }
      hide bonds;
      subset..dipoleInfo = dipoleInfo;
    }
  }

  return msg;
}

function hideDipoles(mode, expression, dipoleInfo) {
  var msg                = "";
  var nodeNumbers        = [];
  var nodeNumbers2       = {};
  var expressionProvided = false;
  
  if (mode == "") {
    mode = "dipolesOnly";
  }
  if (expression.type == "string") {
    if (expression == "") {
      expression = "selected";
    } else {
      expressionProvided = true;
    }
  } else {
    expression = "selected";
  }
  if (dipoleInfo.type != hash) {
    dipoleInfo = networkData..subsets.[networkData..currentSubsetKey]..dipoleInfo;
  }

  if (mode != "dipolesOnly") {
    hide @expression;
  }
  if (expressionProvided) {
    nodeNumbers = getNodeNumbers({@expression});
  } else {
    nodeNumbers = getNodeNumbers({displayed});
  }
  for (var i IN nodeNumbers) {
    nodeNumbers2[i] = true;
  }

  for (var nodeNumber1 IN nodeNumbers) {
    if (dipoleInfo.[nodeNumber1].type == "hash") {
      for (var nodeNumber2 IN dipoleInfo.[nodeNumber1]) {
        #print "  nn1=" + nodeNumber1 + "  nn2=" + nodeNumber2;
        if (not nodeNumbers2[nodeNumber2]) {
          var dipoleId = dipoleInfo.[nodeNumber1].[nodeNumber2]..dipoleId;
          #print "  dipoleId=" + dipoleId;
          if (dipoleId != "") {
            dipole ID @dipoleId OFF;
          }
        }
      }
    }
  }

}

function showDipoles(mode, expression, dipoleInfo) {
  var msg                  = "";
  var nodeNumbers          = [];
  var nodeNumbersDisplayed = {};
  var expressionProvided   = false;
  var currentSelection     = {selected};
  
  if (mode == "") {
    mode = "dipolesOnly";
  }
  if (expression.type == "string") {
    if (expression == "") {
      expression = "selected";
    } else {
      expressionProvided = true;
    }
  } else {
    expression = "selected";
  }
  if (dipoleInfo.type != hash) {
    dipoleInfo = networkData..subsets.[networkData..currentSubsetKey]..dipoleInfo;
  }

  if (mode != "dipolesOnly") {
    display @expression;
  }
  if (expressionProvided) {
    nodeNumbers = getNodeNumbers({@expression});
  } else {
    nodeNumbers = getNodeNumbers({displayed});
  }
  for (var i IN nodeNumbers) {
    nodeNumbersDisplayed[i] = true;
  }

  for (var nodeNumber1 IN nodeNumbers) {
    if (dipoleInfo.[nodeNumber1].type == "hash") {
      for (var nodeNumber2 IN dipoleInfo.[nodeNumber1]) {
        #print "  nn1=" + nodeNumber1 + "  nn2=" + nodeNumber2;
        if (nodeNumbersDisplayed[nodeNumber2]) {
          var dipoleId = dipoleInfo.[nodeNumber1].[nodeNumber2]..dipoleId;
          #print "  dipoleId=" + dipoleId;
          if (dipoleId != "") {
            dipole ID @dipoleId ON;
          }
        }
      }
    }
  }

  select @currentSelection;
}

function showRule(ruleId, nodeId) {
  if (ruleId != "") {
    if (nodeId == "") {
      nodeId = ruleId;
    }
    var currentSelection = {selected};
    var currentBondmodeOr = bondmodeOr;
    var x = selectByInfoKey("logicRuleId", ruleId);
    display atomno=@x or connected(atomno=@x) or [PW_GEN];
    set bondModeOr false;
    select [PW_GEN];
    color opaque;
    color bonds translucent 3;
    set bondModeOr true;
    select [PW_GEN] and not connected(atomno=@x);
    color translucent 5;
    color bonds translucent 7;
    select atomno=@nodeId;
    color opaque;
    #halo on;
    #color halo blue;
    hideDipoles;
    select @currentSelection;
    set BondModeOr currentBondModeOr;
  }
}

function addBondsV1(edgeInfo, edgeType, mode) {
  if (edgeType == "") {
    edgeType == "undirected";
  }
  if (mode == "") {
    mode = "noDipoles";
  }
  if (edgeInfo.type == "hash") {
    if (edgeInfo.size > 0) {
      if (mode != "onlyDipoles") {
        for (var edgeKey in edgeInfo) {
          nodeNumber1 = edgeInfo[edgeKey]..nodeNumber1;
          nodeNumber2 = edgeInfo[edgeKey]..nodeNumber2;
          if (nodeNumber1 > 0 && nodeNumber2 > 0) {
            connect (atomno=nodeNumber1) (atomno=nodeNumber2);
          }
        }
      }

      if (edgeType == "directed" && mode != "noDipoles") {
        
        for (var edgeKey in edgeInfo) {
          nodeNumber1 = edgeInfo[edgeKey]..nodeNumber1;
          nodeNumber2 = edgeInfo[edgeKey]..nodeNumber2;
          if (nodeNumber1 > 0 && nodeNumber2 > 0) {
            var dipoleId    = "dip_" + edgeInfo[edgeKey]..edgeNumber;
            var dipoleScale = distance({atomno=nodeNumber1}, {atomno=nodeNumber2}) * 1.0;
            dipole ID @dipoleId (atomno=nodeNumber1) (atomno=nodeNumber2) offsetSide 0 width 0.7 NOCROSS value @dipoleScale;
            #var dipoleIdRev    = "dipr_" + edgeInfo[edgeKey]..edgeNumber;
            #dipole ID @dipoleIdRev (atomno=nodeNumber2) (atomno=nodeNumber1) offsetSide 0 width 0.7 NOCROSS value @dipoleScale;
          }
        }
        hide bonds;
      }
    }
  } else {
    var msg = "ERROR: parameter 'edgeInfo' not provided or no hash in call of method 'addBonds' - NO BONDS ADDED";
  }
}

function getSubsetNumberList(nodeBitset) {
  if (nodeBitset.type != "bitset") {
    nodeBitset = {visible};
  }
  var subsetNumberInfo = nodeBitset.file.all.count();
  var subsetNumberList = [];

  if (subsetNumberInfo.type == "array") {
    for (var i from [1, subsetNumberInfo.size]) {
      var subsetNumber = subsetNumberInfo[i].[1];
      subsetNumberList.push(subsetNumber);
    }
  }
  return subsetNumberList;
}

function buildLegend(dataHashref) {
  var msg            = "";
  var nodeRadius     = 1.0;   # Angstrom
  var nodeDistance = 2.5 * nodeRadius;
  var nodeSubTypeInfo = {all}.group.count();
  var coordX = 0.0;
  var coordY = 0.0;
  var coordZ = 0.0;

  # Check required parameters
  if (dataHashref.type != "hash") {
  } else {
    if (dataHashref..nodeRadius != "") {
      nodeRadius = dataHashref..nodeRadius;
    }
    if (dataHashref..nodeDistance != "") {
      nodeDistance = dataHashref..nodedistance;
    } else {
      nodeDistance = 2.5 * nodeRadius;
    }
  }

  if (nodeSubTypeInfo.type == "array") {
    if (nodeSubTypeInfo.size > 0) {
      for (var i FROM [1, nodeSubTypeInfo.size]) {
        if (nodeSubTypeInfo[i].type == "array") {
          var nodeSubType = nodeSubTypeInfo[i].[1];
        }
      }
    }
  }
    
}

function updateStandardSubsetManagementMenu(dataHashref) {
  var msg              = "";
  var fullNodeInfo     = {};
  var subsetFilter     = false;
  var matchedNodeKeys  = {};
  var nodeFilter       = "";
  var filteredNodeInfo = {};

  # Check required parameters
  if (dataHashref.type != "hash") {
    if (networkData.type == "hash") {
      dataHashref = networkData;
    }
  }

  if (dataHashref..subsets.type == "hash") {
    if (dataHashref..subsets..full.type == "hash") {
      if (dataHashref..subsets..full..nodeInfo.type == "hash") {
	fullNodeInfo = dataHashref..subsets..full..nodeInfo;
	filteredNodeInfo = fullNodeInfo;
      }
      if (dataHashref..subsets..full..genesOfInterest.type == "hash") {
	if ("" + dataHashref..subsets..full..genesOfInterest..subsetFilter != "") {
	  subsetFilter = dataHashref..subsets..full..genesOfInterest..subsetFilter;
	}
	if (dataHashref..subsets..full..genesOfInterest..matchedNodeKeys.type == "hash") {
	  matchedNodeKeys = dataHashref..subsets..full..genesOfInterest..matchedNodeKeys;
	}
      }
    }
  }
  if (dataHashref..standardSubsetManagement.type == "hash") {
    if (dataHashref..standardSubsetManagement..menuNodeFilter != "") {
      nodeFilter = dataHashref..standardSubsetManagement..menuNodeFilter
    }
  }

  if (nodeFilter != "") {
    filteredNodeInfo = fullNodeInfo.select(nodeFilter);
  }

  var totalNodeCount = filteredNodeInfo.size;
  var nodeCounter = 0;
  logMsg([level: "info", msg: "Updating standard subset management menu (subsetFilter=" + subsetFilter + ", total=" + fullNodeInfo.size + ", filtered=" + totalNodeCount + ", matched=" + matchedNodeKeys.keys.size + ")..."]);

  if (totalNodeCount > 0) {
    var menuInnerHtml    = "";
    var optionHtml       = [];
    var firstOptionValue = "";
    var format_string    = "%0" + ("" + totalNodeCount).length + "d";
    for (var currentNodeKey IN filteredNodeInfo) {
      var skipNode = false;
      if (subsetFilter) {
	if (matchedNodeKeys[currentNodeKey] == "") {
	  skipNode = true;
	}
      }
      #logMsg("  nodeKey='" + currentNodeKey + "'  skip=" + skipNode);
      if (skipNode == false) {
	var nodeInfo               = filteredNodeInfo[currentNodeKey];
	var nodeId                 = nodeInfo..nodeId;
	var name                   = nodeInfo..ageingFactorName.replace("'","`");
	var nodeSubType            = nodeInfo..nodeSubType;
	var homologyAnalysisStatus = nodeInfo..homologyAnalysisStatus;
	var speciesInfo            = nodeInfo..species;
	var species_shortcut1      = "";
	var species_shortcut2      = "";
        var cssStyle               = "";
        var comment                = "";

        if (homologyAnalysisStatus == "ADDED") {
	  cssStyle = ' style="background-color: rgb(120,220,250);"';
          comment  = " [putative]";
	}
      
	nodeCounter++;
      
	if (nodeSubType == "gene") {
        # Determine species shortcut
	  var speciesData = [];
	  if (speciesInfo.type == "hash") {
	    if (speciesInfo.size == 1) {
	      species = speciesInfo.keys[1];
	      speciesData = speciesInfo.keys.[1].split(" ");
	    }
	  } else {
	    speciesData = speciesInfo.split(" ");
	  }
	  if (speciesData.size > 1) {
	    var firstWord = speciesData[1];
	    var firstCharacter = firstWord[1];
	    speciesShortcut1 = "" + firstCharacter + "."  + speciesData[2];
	    speciesShortcut2 = "" + firstCharacter + ". " + speciesData[2];
	  } else {
	    speciesShortcut = speciesInfo;
	  }

          if (firstOptionValue == "") {
            firstOptionValue = name + '_' + speciesShortcut1 + '||' + nodeId;
          }
	  optionHtml.push('<option value="' + name + '_' + speciesShortcut1 + '||' + nodeId + '"' + cssStyle + '>' + name + ' ' + speciesShortcut2 + ' - ' + nodeId + comment + '</option>');
	  #optionHtml.push('<option value="' + currentNodeKey + '">' + name + ' ' + speciesShortcut2 + ' - ' + nodeId + '</option>');
	} else {
          if (firstOptionValue == "") {
            firstOptionValue = name +  '||' + nodeId;
          }
	  optionHtml.push('<option value="' + name + '||' + nodeId + '">' + name + ' - ' + nodeId + comment + '</option>');
	}
      }
    }
    var optionHtmlSorted = optionHtml.sort;
    var firstOptionData = optionHtmlSorted.split('"');
    x = javascript("document.getElementById('standardsubset_menu').innerHTML = '" + optionHtml.sort.join("") + "';  menu_state['standardsubset_menu'] = '" + firstOptionData[2] + "'; idbSetSelected(document.getElementById('standardsubset_menu'),menu_state['standardsubset_menu']);");
  }


}


function pickAction(pickMode) {
  pickRangeNeighbourDistance = hoverRangeNeighbourDistance;
  # Set defaults (currently still global variables, SHOULD BE CHANGED)
  if (pickRange == "") {
    pickRange = "node";
  }
  if (pickRangeNeighbourMode == "") {
    pickRangeNeighbourMode = "replace";
  }
  if ("" + pickRangeNeighbourDistance == "") {
    pickRangeNeighbourDistance = 1;
  }
  if (mouseVisibilityMode == "") {
    mouseVisibilityMode = "only";
  }

  if (pickMode == "dummy") {  # dummy pick mode just to be able to update the selected node count in the JANet interface
    message "Script completed";
    return "";
  }

  var currentSelection = {selected};
  var pickedNodeSet    = {none};

  if (_atompicked >= 0) {
    var pickedAtomIndex = _atompicked;
    var pickedNode      = {atomindex=@pickedAtomIndex};
    var modifiers       = "" + _mouseModifiers;

    var modifierToString = {};
    modifierToString["16"] = "NONE";
    modifierToString["17"] = "SHIFT";
    modifierToString["24"] = "ALT";
    modifierToString["25"] = "ALT-SHIFT";

    var modifierString = "";
    if (modifierToString[modifiers] != "") {
      modifierString = modifierToString[modifiers];
    }
    logMsg("index=" + pickedAtomIndex + "  modifiers=" + modifiers);
print "DEBUG: index=" + pickedAtomIndex + "  modifiers=" + modifiers;

    switch(pickMode) {
      case "label":
        switch(pickRange) {
          case "neighbours":
            pickedNodeSet = getNeighbours(pickedNode, pickRangeNeighbourDistance, "add");
            break;
          case "subnetwork":
            pickedNodeSet ={within("molecule", atomindex=@pickedAtomIndex)};
            break;
          case "node":
            pickedNodeSet = pickedNode;
            break;
        }

        var unlabelledNodes = {@pickedNodeSet and (label="" OR label like "?*")};
        if (unlabelledNodes.size > 0) {
          logMsg([level: "info", msg: "Picked nodes with undefined labels - defining missing labels for " + unlabelledNodes.size + " nodes..."]);
          var currentFontScaling = fontScaling;
          set fontScaling off;
          setLabel(unlabelledNodes);
          set fontScaling currenFontScaling
        }

        switch(modifierString) {
          case "NONE":      # only
            #select @pickedNodeSet;
            #label display;
            #select @currentSelection;
            #select @pickedNodeSet;
            #set labelToggle;
            #select @currentSelection;
            break;
          case "SHIFT":     # toggle
            select @pickedNodeSet;
            set labelToggle;
            select @currentSelection;
            break;
          case "ALT":       # add
            select @pickedNodeSet;
            label display;
            select @currentSelection;
            break;
          case "ALT-SHIFT": # subtract
            select @pickedNodeSet;
            label hide;
            select @currentSelection;
            break;
        }

        break;

      case "info":
        switch(pickRange) {
          case "neighbours":
            pickedNodeSet = getNeighbours(pickedNode, pickRangeNeighbourDistance, "add");
            break;
          case "subnetwork":
            pickedNodeSet ={within("molecule", atomindex=@pickedAtomIndex)};
            break;
          case "node":
            pickedNodeSet = pickedNode;
            break;
        }

        switch(modifierString) {
          case "NONE":      # only
            showNodeInfo(pickedNodeSet);
            break;
          case "SHIFT":     # toggle
            break;
          case "ALT":       # add
            break;
          case "ALT-SHIFT": # subtract
            break;
        }

        break;

      case "visibility":
        switch(pickRange) {
          case "neighbours":
            pickedNodeSet = getNeighbours(pickedNode, pickRangeNeighbourDistance, "add");
            break;
          case "subnetwork":
            pickedNodeSet ={within("molecule", atomindex=@pickedAtomIndex)};
            break;
          case "node":
            pickedNodeSet = pickedNode;
            break;
        }

        switch(mouseVisibilityMode) {
          case "only":
            display @pickedNodeSet;
            if (lastHoverUnfinished && hoverMode=="only") {
              displayedBeforeHover = {displayed};   # new set needed for hover mode 'show only connected nodes', otherwise hover would counteract after moving mouse
            }
            break;
          case "add":
            if (lastHoverUnfinished && hoverMode=="only") {
              display @displayedBeforeHover OR @pickedNodeSet;
              displayedBeforeHover = {displayed};   # new set needed for hover mode 'show only connected nodes', otherwise hover would counteract after moving mouse
            } else {
              display add @pickedNodeSet;
            }
            break;
          case "subtract":
            if (lastHoverUnfinished && hoverMode=="only") {
              display @displayedBeforeHover AND NOT @pickedNodeSet;
              displayedBeforeHover = {displayed};   # new set needed for hover mode 'show only connected nodes', otherwise hover would counteract after moving mouse
            } else {
              display remove @pickedNodeSet;
            }
            displayedBeforeHover = {displayed};   # new set needed for hover mode 'show only connected nodes', otherwise hover would counteract after moving mouse
            break;
          case "and":
            if (lastHoverUnfinished && hoverMode=="only") {
              display @displayedBeforeHover AND @pickedNodeSet;
              displayedBeforeHover = {displayed};   # new set needed for hover mode 'show only connected nodes', otherwise hover would counteract after moving mouse
            } else {
              display displayed and @pickedNodeSet;
            }
            break;
          case "not":
            if (lastHoverUnfinished && hoverMode=="only") {
              display NOT @pickedNodeSet;
              displayedBeforeHover = {displayed};   # new set needed for hover mode 'show only connected nodes', otherwise hover would counteract after moving mouse
            } else {
              display not @pickedNodeSet;
            }
            break;
        }

        break;

      case "select":
        switch(pickRange) {
          case "neighbours":
            pickedNodeSet = getNeighbours(pickedNode, pickRangeNeighbourDistance, "replace");
            break;
          case "neighboursNoOthers":
            pickedNodeSet = getNeighbours(pickedNode, pickRangeNeighbourDistance, "replace-degree_1");
            break;
          case "subnetwork":
            pickedNodeSet ={within("molecule", atomindex=@pickedAtomIndex)};
            break;
          case "node":
            pickedNodeSet = pickedNode;
            break;
        }

        switch(modifierString) {
          case "NONE":      # only
            select @pickedNodeSet OR @pickedNode;
            break;
          case "SHIFT":     # toggle
            for (var node IN pickedNodeSet) {
              if ({@currentSelection and @node}.size == 1) {
                currentSelection = {@currentSelection AND NOT @node};
              } else {
                currentSelection = {@currentSelection OR @node};
              }
            }
            select @currentSelection;
            break;
          case "ALT":       # add
            select @currentSelection OR @pickedNodeSet;
            break;
          case "ALT-SHIFT": # subtract
            select @currentSelection AND NOT @pickedNodeSet;
            break;
        }
        message "Script completed";
        break;
    }
  }

}

function initPick(mode) {
  set pickCallback "jmolscript: pickAction(\"" + mode + "\");";
}

function showGui() {
  javascript jaDisplayGui("show");
}

function hideGui() {
  javascript jaDisplayGui("hide");
}

function displayLabel(action) {
  if (action == "") {
    action = "show";
  }

  if (action == "show") {
    var unlabelledNodes = {selected and (label="" OR label like "?*")};
    if (unlabelledNodes.size > 0) {
      logMsg([level: "info", msg: "Undefined labels for some selected nodes - defining missing labels for " + unlabelledNodes.size + " nodes..."]);
      var currentFontScaling = fontScaling;
      set fontScaling off;
      setLabel(unlabelledNodes);
      set fontScaling currenFontScaling;
    }
    set label display;
  } else {
    set label hide;
  }
}

#initHover;

message "NOTE: JANet script library loaded succesfully";
